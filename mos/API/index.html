
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../Star-Commands/">
      
      
        <link rel="next" href="../C-Functions/">
      
      
      <link rel="icon" href="../../assets/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>API - Community Agon Platform documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#rst" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Community Agon Platform documentation" class="md-header__button md-logo" aria-label="Community Agon Platform documentation" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Community Agon Platform documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="purple"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="deep-purple" data-md-color-accent="lime"  aria-label="Switch to your system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to your system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/AgonPlatform/agon-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    contribute
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Community Agon Platform documentation" class="md-nav__button md-logo" aria-label="Community Agon Platform documentation" data-md-component="logo">
      
  <img src="../../assets/logo.png" alt="logo">

    </a>
    Community Agon Platform documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/AgonPlatform/agon-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    contribute
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Welcome & getting started
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Welcome & getting started
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Start here
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../FAQ/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Theory-of-operation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Theory of operation
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    MOS
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            MOS
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../MOS/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Star-Commands/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Command line
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    API
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    API
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rst" class="md-nav__link">
    <span class="md-ellipsis">
      Usage from Z80 assembler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Usage from Z80 assembler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rst-08h-execute-a-mos-command" class="md-nav__link">
    <span class="md-ellipsis">
      RST 08h: Execute a MOS command
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rst-10h-output-a-single-character-to-the-vdp" class="md-nav__link">
    <span class="md-ellipsis">
      RST 10h: Output a single character to the VDP
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rst-18h-output-a-stream-of-characters-to-the-vdp-mos-103-or-above" class="md-nav__link">
    <span class="md-ellipsis">
      RST 18h: Output a stream of characters to the VDP (MOS 1.03 or above)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rst-38h-outputs-a-crash-report-mos-230-or-above" class="md-nav__link">
    <span class="md-ellipsis">
      RST 38h: Outputs a crash report (MOS 2.3.0 or above)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-mos-api" class="md-nav__link">
    <span class="md-ellipsis">
      The MOS API
    </span>
  </a>
  
    <nav class="md-nav" aria-label="The MOS API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#advice-on-file-handling" class="md-nav__link">
    <span class="md-ellipsis">
      Advice on file handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-note-on-system-variables" class="md-nav__link">
    <span class="md-ellipsis">
      A note on "system variables"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apis-that-use-32-bit-values" class="md-nav__link">
    <span class="md-ellipsis">
      APIs that use 32-bit values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core-mos-apis-and-modules" class="md-nav__link">
    <span class="md-ellipsis">
      Core MOS APIs, and Modules
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mos-api-calls" class="md-nav__link">
    <span class="md-ellipsis">
      MOS API calls
    </span>
  </a>
  
    <nav class="md-nav" aria-label="MOS API calls">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0x00-mos_getkey" class="md-nav__link">
    <span class="md-ellipsis">
      0x00: mos_getkey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x01-mos_load" class="md-nav__link">
    <span class="md-ellipsis">
      0x01: mos_load
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x02-mos_save" class="md-nav__link">
    <span class="md-ellipsis">
      0x02: mos_save
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x03-mos_cd" class="md-nav__link">
    <span class="md-ellipsis">
      0x03: mos_cd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x04-mos_dir" class="md-nav__link">
    <span class="md-ellipsis">
      0x04: mos_dir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x05-mos_del" class="md-nav__link">
    <span class="md-ellipsis">
      0x05: mos_del
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x06-mos_ren" class="md-nav__link">
    <span class="md-ellipsis">
      0x06: mos_ren
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x07-mos_mkdir" class="md-nav__link">
    <span class="md-ellipsis">
      0x07: mos_mkdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x08-mos_sysvars" class="md-nav__link">
    <span class="md-ellipsis">
      0x08: mos_sysvars
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x09-mos_editline" class="md-nav__link">
    <span class="md-ellipsis">
      0x09: mos_editline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0a-mos_fopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x0A: mos_fopen
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0x0A: mos_fopen">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#file-open-modes" class="md-nav__link">
    <span class="md-ellipsis">
      File open modes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0b-mos_fclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x0B: mos_fclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0c-mos_fgetc" class="md-nav__link">
    <span class="md-ellipsis">
      0x0C: mos_fgetc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0d-mos_fputc" class="md-nav__link">
    <span class="md-ellipsis">
      0x0D: mos_fputc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0e-mos_feof" class="md-nav__link">
    <span class="md-ellipsis">
      0x0E: mos_feof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0f-mos_geterror" class="md-nav__link">
    <span class="md-ellipsis">
      0x0F: mos_getError
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x10-mos_oscli" class="md-nav__link">
    <span class="md-ellipsis">
      0x10: mos_oscli
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x11-mos_copy" class="md-nav__link">
    <span class="md-ellipsis">
      0x11: mos_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x12-mos_getrtc" class="md-nav__link">
    <span class="md-ellipsis">
      0x12: mos_getrtc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x13-mos_setrtc" class="md-nav__link">
    <span class="md-ellipsis">
      0x13: mos_setrtc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x14-mos_setintvector" class="md-nav__link">
    <span class="md-ellipsis">
      0x14: mos_setintvector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x15-mos_uopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x15: mos_uopen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x16-mos_uclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x16: mos_uclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x17-mos_ugetc" class="md-nav__link">
    <span class="md-ellipsis">
      0x17: mos_ugetc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x18-mos_uputc" class="md-nav__link">
    <span class="md-ellipsis">
      0x18: mos_uputc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x19-mos_getfil" class="md-nav__link">
    <span class="md-ellipsis">
      0x19: mos_getfil
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1a-mos_fread" class="md-nav__link">
    <span class="md-ellipsis">
      0x1A: mos_fread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1b-mos_fwrite" class="md-nav__link">
    <span class="md-ellipsis">
      0x1B: mos_fwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1c-mos_flseek" class="md-nav__link">
    <span class="md-ellipsis">
      0x1C: mos_flseek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1d-mos_setkbvector" class="md-nav__link">
    <span class="md-ellipsis">
      0x1D: mos_setkbvector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1e-mos_getkbmap" class="md-nav__link">
    <span class="md-ellipsis">
      0x1E: mos_getkbmap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1f-mos_i2c_open" class="md-nav__link">
    <span class="md-ellipsis">
      0x1F: mos_i2c_open
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x20-mos_i2c_close" class="md-nav__link">
    <span class="md-ellipsis">
      0x20: mos_i2c_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x21-mos_i2c_write" class="md-nav__link">
    <span class="md-ellipsis">
      0x21: mos_i2c_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x22-mos_i2c_read" class="md-nav__link">
    <span class="md-ellipsis">
      0x22: mos_i2c_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x23-mos_unpackrtc" class="md-nav__link">
    <span class="md-ellipsis">
      0x23: mos_unpackrtc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x24-mos_flseek_p" class="md-nav__link">
    <span class="md-ellipsis">
      0x24: mos_flseek_p
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x28-0x2c-string-functions" class="md-nav__link">
    <span class="md-ellipsis">
      0x28-0x2C: String functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x28-mos_pmatch" class="md-nav__link">
    <span class="md-ellipsis">
      0x28: mos_pmatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x29-mos_getargument" class="md-nav__link">
    <span class="md-ellipsis">
      0x29: mos_getargument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x2a-mos_extractstring" class="md-nav__link">
    <span class="md-ellipsis">
      0x2A: mos_extractstring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x2b-mos_extractnumber" class="md-nav__link">
    <span class="md-ellipsis">
      0x2B: mos_extractnumber
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x2c-mos_escapestring" class="md-nav__link">
    <span class="md-ellipsis">
      0x2C: mos_escapestring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x30-0x37-system-variables-and-string-translations" class="md-nav__link">
    <span class="md-ellipsis">
      0x30-0x37: System variables and string translations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x30-mos_setvarval" class="md-nav__link">
    <span class="md-ellipsis">
      0x30: mos_setvarval
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x31-mos_readvarval" class="md-nav__link">
    <span class="md-ellipsis">
      0x31: mos_readvarval
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x32-mos_gsinit" class="md-nav__link">
    <span class="md-ellipsis">
      0x32: mos_gsinit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x33-mos_gsread" class="md-nav__link">
    <span class="md-ellipsis">
      0x33: mos_gsread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x34-mos_gstrans" class="md-nav__link">
    <span class="md-ellipsis">
      0x34: mos_gstrans
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x35-mos_substituteargs" class="md-nav__link">
    <span class="md-ellipsis">
      0x35: mos_substituteargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x36-mos_evaluateexpression" class="md-nav__link">
    <span class="md-ellipsis">
      0x36: mos_evaluateexpression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x38-0x3c-file-path-functions" class="md-nav__link">
    <span class="md-ellipsis">
      0x38-0x3C: File path functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x38-mos_resolvepath" class="md-nav__link">
    <span class="md-ellipsis">
      0x38: mos_resolvepath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x39-mos_getdirforpath" class="md-nav__link">
    <span class="md-ellipsis">
      0x39: mos_getdirforpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x3a-mos_getleafname" class="md-nav__link">
    <span class="md-ellipsis">
      0x3A: mos_getleafname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x3b-mos_isdirectory" class="md-nav__link">
    <span class="md-ellipsis">
      0x3B: mos_isdirectory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x3c-mos_getabsolutepath" class="md-nav__link">
    <span class="md-ellipsis">
      0x3C: mos_getabsolutepath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x40-0x50-vdp-protocol-and-miscellaneous-functions" class="md-nav__link">
    <span class="md-ellipsis">
      0x40-0x50: VDP protocol, and miscellaneous functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x40-mos_clearvdpflags" class="md-nav__link">
    <span class="md-ellipsis">
      0x40: mos_clearvdpflags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x41-mos_waitforvdpflags" class="md-nav__link">
    <span class="md-ellipsis">
      0x41: mos_waitforvdpflags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x50-mos_getfunction" class="md-nav__link">
    <span class="md-ellipsis">
      0x50: mos_getfunction
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#0x70-0x73-low-level-sd-card-access" class="md-nav__link">
    <span class="md-ellipsis">
      0x70-0x73: Low-level SD card access
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0x70-0x73: Low-level SD card access">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0x70-sd_getunlockcode" class="md-nav__link">
    <span class="md-ellipsis">
      0x70: sd_getunlockcode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x71-sd_init" class="md-nav__link">
    <span class="md-ellipsis">
      0x71: sd_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x72-sd_readblocks" class="md-nav__link">
    <span class="md-ellipsis">
      0x72: sd_readblocks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x73-sd_writeblocks" class="md-nav__link">
    <span class="md-ellipsis">
      0x73: sd_writeblocks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fatfs-commands" class="md-nav__link">
    <span class="md-ellipsis">
      0x80-0xA6: FatFS APIs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0x80-0xA6: FatFS APIs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0x80-ffs_fopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x80: ffs_fopen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x81-ffs_fclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x81: ffs_fclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x82-ffs_fread" class="md-nav__link">
    <span class="md-ellipsis">
      0x82: ffs_fread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x83-ffs_fwrite" class="md-nav__link">
    <span class="md-ellipsis">
      0x83: ffs_fwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x84-ffs_flseek" class="md-nav__link">
    <span class="md-ellipsis">
      0x84: ffs_flseek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x85-ffs_ftruncate" class="md-nav__link">
    <span class="md-ellipsis">
      0x85: ffs_ftruncate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x86-ffs_fsync" class="md-nav__link">
    <span class="md-ellipsis">
      0x86: ffs_fsync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x87-ffs_fforward" class="md-nav__link">
    <span class="md-ellipsis">
      0x87: ffs_fforward
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x88-ffs_fexpand" class="md-nav__link">
    <span class="md-ellipsis">
      0x88: ffs_fexpand
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x89-ffs_fgets" class="md-nav__link">
    <span class="md-ellipsis">
      0x89: ffs_fgets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8a-ffs_fputc" class="md-nav__link">
    <span class="md-ellipsis">
      0x8A: ffs_fputc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8b-ffs_fputs" class="md-nav__link">
    <span class="md-ellipsis">
      0x8B: ffs_fputs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8c-ffs_fprintf" class="md-nav__link">
    <span class="md-ellipsis">
      0x8C: ffs_fprintf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8d-ffs_ftell" class="md-nav__link">
    <span class="md-ellipsis">
      0x8D: ffs_ftell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8e-ffs_feof" class="md-nav__link">
    <span class="md-ellipsis">
      0x8E: ffs_feof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8f-ffs_fsize" class="md-nav__link">
    <span class="md-ellipsis">
      0x8F: ffs_fsize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x90-ffs_ferror" class="md-nav__link">
    <span class="md-ellipsis">
      0x90: ffs_ferror
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x91-ffs_dopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x91: ffs_dopen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x92-ffs_dclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x92: ffs_dclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x93-ffs_dread" class="md-nav__link">
    <span class="md-ellipsis">
      0x93: ffs_dread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x94-ffs_dfindfirst" class="md-nav__link">
    <span class="md-ellipsis">
      0x94: ffs_dfindfirst
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x95-ffs_dfindnext" class="md-nav__link">
    <span class="md-ellipsis">
      0x95: ffs_dfindnext
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x96-ffs_stat" class="md-nav__link">
    <span class="md-ellipsis">
      0x96: ffs_stat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x97-ffs_unlink" class="md-nav__link">
    <span class="md-ellipsis">
      0x97: ffs_unlink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x98-ffs_rename" class="md-nav__link">
    <span class="md-ellipsis">
      0x98: ffs_rename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x99-ffs_chmod" class="md-nav__link">
    <span class="md-ellipsis">
      0x99: ffs_chmod
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9a-ffs_utime" class="md-nav__link">
    <span class="md-ellipsis">
      0x9A: ffs_utime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9b-ffs_mkdir" class="md-nav__link">
    <span class="md-ellipsis">
      0x9B: ffs_mkdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9c-ffs_chdir" class="md-nav__link">
    <span class="md-ellipsis">
      0x9C: ffs_chdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9d-ffs_chdrive" class="md-nav__link">
    <span class="md-ellipsis">
      0x9D: ffs_chdrive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9e-ffs_getcwd" class="md-nav__link">
    <span class="md-ellipsis">
      0x9E: ffs_getcwd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9f-ffs_mount" class="md-nav__link">
    <span class="md-ellipsis">
      0x9F: ffs_mount
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa0-ffs_mkfs" class="md-nav__link">
    <span class="md-ellipsis">
      0xA0: ffs_mkfs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa1-ffs_fdisk" class="md-nav__link">
    <span class="md-ellipsis">
      0xA1: ffs_fdisk
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa2-ffs_getfree" class="md-nav__link">
    <span class="md-ellipsis">
      0xA2: ffs_getfree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa3-ffs_getlabel" class="md-nav__link">
    <span class="md-ellipsis">
      0xA3: ffs_getlabel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa4-ffs_setlabel" class="md-nav__link">
    <span class="md-ellipsis">
      0xA4: ffs_setlabel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa5-ffs_setcp" class="md-nav__link">
    <span class="md-ellipsis">
      0xA5: ffs_setcp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa6-ffs_flseek_p" class="md-nav__link">
    <span class="md-ellipsis">
      0xA6: ffs_flseek_p
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#status-codes" class="md-nav__link">
    <span class="md-ellipsis">
      Status Codes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sysvars" class="md-nav__link">
    <span class="md-ellipsis">
      System State Information (SysVars)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="System State Information (SysVars)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sysvar_rtc" class="md-nav__link">
    <span class="md-ellipsis">
      Real Time Clock
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../C-Functions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    C functions
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Executables/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Executable format
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Modules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Modules
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../System-Variables/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    System Variables
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Argument-Substitution/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Argument Substitution
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    VDP
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            VDP
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../VDP/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/VDU-Commands/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Main Commands
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Screen-Modes/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Screen Modes
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/PLOT-Commands/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PLOT Commands
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/System-Commands/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    System Commands
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Enhanced-Audio-API/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Audio API
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Bitmaps-API/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Bitmaps and Sprites API
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Buffered-Commands-API/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Buffered Commands API
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Context-Management-API/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Context Management API
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Font-API/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Font Management API
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/VDP-Variables/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    VDP Variables
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../vdp/Copper-API/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Copper Effects API
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../BBC-BASIC-for-Agon/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    BBC Basic
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../GPIO/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    GPIO
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Guides
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Guides
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Updating-Firmware/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Updating Firmware
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Additional resources
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            Additional resources
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../External-Documentation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    External documentation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Third-Party-Projects/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Third party projects
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#rst" class="md-nav__link">
    <span class="md-ellipsis">
      Usage from Z80 assembler
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Usage from Z80 assembler">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rst-08h-execute-a-mos-command" class="md-nav__link">
    <span class="md-ellipsis">
      RST 08h: Execute a MOS command
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rst-10h-output-a-single-character-to-the-vdp" class="md-nav__link">
    <span class="md-ellipsis">
      RST 10h: Output a single character to the VDP
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rst-18h-output-a-stream-of-characters-to-the-vdp-mos-103-or-above" class="md-nav__link">
    <span class="md-ellipsis">
      RST 18h: Output a stream of characters to the VDP (MOS 1.03 or above)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rst-38h-outputs-a-crash-report-mos-230-or-above" class="md-nav__link">
    <span class="md-ellipsis">
      RST 38h: Outputs a crash report (MOS 2.3.0 or above)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-mos-api" class="md-nav__link">
    <span class="md-ellipsis">
      The MOS API
    </span>
  </a>
  
    <nav class="md-nav" aria-label="The MOS API">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#advice-on-file-handling" class="md-nav__link">
    <span class="md-ellipsis">
      Advice on file handling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-note-on-system-variables" class="md-nav__link">
    <span class="md-ellipsis">
      A note on "system variables"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apis-that-use-32-bit-values" class="md-nav__link">
    <span class="md-ellipsis">
      APIs that use 32-bit values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#core-mos-apis-and-modules" class="md-nav__link">
    <span class="md-ellipsis">
      Core MOS APIs, and Modules
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mos-api-calls" class="md-nav__link">
    <span class="md-ellipsis">
      MOS API calls
    </span>
  </a>
  
    <nav class="md-nav" aria-label="MOS API calls">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0x00-mos_getkey" class="md-nav__link">
    <span class="md-ellipsis">
      0x00: mos_getkey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x01-mos_load" class="md-nav__link">
    <span class="md-ellipsis">
      0x01: mos_load
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x02-mos_save" class="md-nav__link">
    <span class="md-ellipsis">
      0x02: mos_save
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x03-mos_cd" class="md-nav__link">
    <span class="md-ellipsis">
      0x03: mos_cd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x04-mos_dir" class="md-nav__link">
    <span class="md-ellipsis">
      0x04: mos_dir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x05-mos_del" class="md-nav__link">
    <span class="md-ellipsis">
      0x05: mos_del
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x06-mos_ren" class="md-nav__link">
    <span class="md-ellipsis">
      0x06: mos_ren
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x07-mos_mkdir" class="md-nav__link">
    <span class="md-ellipsis">
      0x07: mos_mkdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x08-mos_sysvars" class="md-nav__link">
    <span class="md-ellipsis">
      0x08: mos_sysvars
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x09-mos_editline" class="md-nav__link">
    <span class="md-ellipsis">
      0x09: mos_editline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0a-mos_fopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x0A: mos_fopen
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0x0A: mos_fopen">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#file-open-modes" class="md-nav__link">
    <span class="md-ellipsis">
      File open modes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0b-mos_fclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x0B: mos_fclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0c-mos_fgetc" class="md-nav__link">
    <span class="md-ellipsis">
      0x0C: mos_fgetc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0d-mos_fputc" class="md-nav__link">
    <span class="md-ellipsis">
      0x0D: mos_fputc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0e-mos_feof" class="md-nav__link">
    <span class="md-ellipsis">
      0x0E: mos_feof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x0f-mos_geterror" class="md-nav__link">
    <span class="md-ellipsis">
      0x0F: mos_getError
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x10-mos_oscli" class="md-nav__link">
    <span class="md-ellipsis">
      0x10: mos_oscli
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x11-mos_copy" class="md-nav__link">
    <span class="md-ellipsis">
      0x11: mos_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x12-mos_getrtc" class="md-nav__link">
    <span class="md-ellipsis">
      0x12: mos_getrtc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x13-mos_setrtc" class="md-nav__link">
    <span class="md-ellipsis">
      0x13: mos_setrtc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x14-mos_setintvector" class="md-nav__link">
    <span class="md-ellipsis">
      0x14: mos_setintvector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x15-mos_uopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x15: mos_uopen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x16-mos_uclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x16: mos_uclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x17-mos_ugetc" class="md-nav__link">
    <span class="md-ellipsis">
      0x17: mos_ugetc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x18-mos_uputc" class="md-nav__link">
    <span class="md-ellipsis">
      0x18: mos_uputc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x19-mos_getfil" class="md-nav__link">
    <span class="md-ellipsis">
      0x19: mos_getfil
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1a-mos_fread" class="md-nav__link">
    <span class="md-ellipsis">
      0x1A: mos_fread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1b-mos_fwrite" class="md-nav__link">
    <span class="md-ellipsis">
      0x1B: mos_fwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1c-mos_flseek" class="md-nav__link">
    <span class="md-ellipsis">
      0x1C: mos_flseek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1d-mos_setkbvector" class="md-nav__link">
    <span class="md-ellipsis">
      0x1D: mos_setkbvector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1e-mos_getkbmap" class="md-nav__link">
    <span class="md-ellipsis">
      0x1E: mos_getkbmap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x1f-mos_i2c_open" class="md-nav__link">
    <span class="md-ellipsis">
      0x1F: mos_i2c_open
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x20-mos_i2c_close" class="md-nav__link">
    <span class="md-ellipsis">
      0x20: mos_i2c_close
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x21-mos_i2c_write" class="md-nav__link">
    <span class="md-ellipsis">
      0x21: mos_i2c_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x22-mos_i2c_read" class="md-nav__link">
    <span class="md-ellipsis">
      0x22: mos_i2c_read
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x23-mos_unpackrtc" class="md-nav__link">
    <span class="md-ellipsis">
      0x23: mos_unpackrtc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x24-mos_flseek_p" class="md-nav__link">
    <span class="md-ellipsis">
      0x24: mos_flseek_p
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x28-0x2c-string-functions" class="md-nav__link">
    <span class="md-ellipsis">
      0x28-0x2C: String functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x28-mos_pmatch" class="md-nav__link">
    <span class="md-ellipsis">
      0x28: mos_pmatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x29-mos_getargument" class="md-nav__link">
    <span class="md-ellipsis">
      0x29: mos_getargument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x2a-mos_extractstring" class="md-nav__link">
    <span class="md-ellipsis">
      0x2A: mos_extractstring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x2b-mos_extractnumber" class="md-nav__link">
    <span class="md-ellipsis">
      0x2B: mos_extractnumber
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x2c-mos_escapestring" class="md-nav__link">
    <span class="md-ellipsis">
      0x2C: mos_escapestring
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x30-0x37-system-variables-and-string-translations" class="md-nav__link">
    <span class="md-ellipsis">
      0x30-0x37: System variables and string translations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x30-mos_setvarval" class="md-nav__link">
    <span class="md-ellipsis">
      0x30: mos_setvarval
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x31-mos_readvarval" class="md-nav__link">
    <span class="md-ellipsis">
      0x31: mos_readvarval
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x32-mos_gsinit" class="md-nav__link">
    <span class="md-ellipsis">
      0x32: mos_gsinit
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x33-mos_gsread" class="md-nav__link">
    <span class="md-ellipsis">
      0x33: mos_gsread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x34-mos_gstrans" class="md-nav__link">
    <span class="md-ellipsis">
      0x34: mos_gstrans
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x35-mos_substituteargs" class="md-nav__link">
    <span class="md-ellipsis">
      0x35: mos_substituteargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x36-mos_evaluateexpression" class="md-nav__link">
    <span class="md-ellipsis">
      0x36: mos_evaluateexpression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x38-0x3c-file-path-functions" class="md-nav__link">
    <span class="md-ellipsis">
      0x38-0x3C: File path functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x38-mos_resolvepath" class="md-nav__link">
    <span class="md-ellipsis">
      0x38: mos_resolvepath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x39-mos_getdirforpath" class="md-nav__link">
    <span class="md-ellipsis">
      0x39: mos_getdirforpath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x3a-mos_getleafname" class="md-nav__link">
    <span class="md-ellipsis">
      0x3A: mos_getleafname
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x3b-mos_isdirectory" class="md-nav__link">
    <span class="md-ellipsis">
      0x3B: mos_isdirectory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x3c-mos_getabsolutepath" class="md-nav__link">
    <span class="md-ellipsis">
      0x3C: mos_getabsolutepath
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x40-0x50-vdp-protocol-and-miscellaneous-functions" class="md-nav__link">
    <span class="md-ellipsis">
      0x40-0x50: VDP protocol, and miscellaneous functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x40-mos_clearvdpflags" class="md-nav__link">
    <span class="md-ellipsis">
      0x40: mos_clearvdpflags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x41-mos_waitforvdpflags" class="md-nav__link">
    <span class="md-ellipsis">
      0x41: mos_waitforvdpflags
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x50-mos_getfunction" class="md-nav__link">
    <span class="md-ellipsis">
      0x50: mos_getfunction
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#0x70-0x73-low-level-sd-card-access" class="md-nav__link">
    <span class="md-ellipsis">
      0x70-0x73: Low-level SD card access
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0x70-0x73: Low-level SD card access">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0x70-sd_getunlockcode" class="md-nav__link">
    <span class="md-ellipsis">
      0x70: sd_getunlockcode
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x71-sd_init" class="md-nav__link">
    <span class="md-ellipsis">
      0x71: sd_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x72-sd_readblocks" class="md-nav__link">
    <span class="md-ellipsis">
      0x72: sd_readblocks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x73-sd_writeblocks" class="md-nav__link">
    <span class="md-ellipsis">
      0x73: sd_writeblocks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fatfs-commands" class="md-nav__link">
    <span class="md-ellipsis">
      0x80-0xA6: FatFS APIs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="0x80-0xA6: FatFS APIs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#0x80-ffs_fopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x80: ffs_fopen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x81-ffs_fclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x81: ffs_fclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x82-ffs_fread" class="md-nav__link">
    <span class="md-ellipsis">
      0x82: ffs_fread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x83-ffs_fwrite" class="md-nav__link">
    <span class="md-ellipsis">
      0x83: ffs_fwrite
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x84-ffs_flseek" class="md-nav__link">
    <span class="md-ellipsis">
      0x84: ffs_flseek
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x85-ffs_ftruncate" class="md-nav__link">
    <span class="md-ellipsis">
      0x85: ffs_ftruncate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x86-ffs_fsync" class="md-nav__link">
    <span class="md-ellipsis">
      0x86: ffs_fsync
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x87-ffs_fforward" class="md-nav__link">
    <span class="md-ellipsis">
      0x87: ffs_fforward
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x88-ffs_fexpand" class="md-nav__link">
    <span class="md-ellipsis">
      0x88: ffs_fexpand
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x89-ffs_fgets" class="md-nav__link">
    <span class="md-ellipsis">
      0x89: ffs_fgets
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8a-ffs_fputc" class="md-nav__link">
    <span class="md-ellipsis">
      0x8A: ffs_fputc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8b-ffs_fputs" class="md-nav__link">
    <span class="md-ellipsis">
      0x8B: ffs_fputs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8c-ffs_fprintf" class="md-nav__link">
    <span class="md-ellipsis">
      0x8C: ffs_fprintf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8d-ffs_ftell" class="md-nav__link">
    <span class="md-ellipsis">
      0x8D: ffs_ftell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8e-ffs_feof" class="md-nav__link">
    <span class="md-ellipsis">
      0x8E: ffs_feof
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x8f-ffs_fsize" class="md-nav__link">
    <span class="md-ellipsis">
      0x8F: ffs_fsize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x90-ffs_ferror" class="md-nav__link">
    <span class="md-ellipsis">
      0x90: ffs_ferror
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x91-ffs_dopen" class="md-nav__link">
    <span class="md-ellipsis">
      0x91: ffs_dopen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x92-ffs_dclose" class="md-nav__link">
    <span class="md-ellipsis">
      0x92: ffs_dclose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x93-ffs_dread" class="md-nav__link">
    <span class="md-ellipsis">
      0x93: ffs_dread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x94-ffs_dfindfirst" class="md-nav__link">
    <span class="md-ellipsis">
      0x94: ffs_dfindfirst
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x95-ffs_dfindnext" class="md-nav__link">
    <span class="md-ellipsis">
      0x95: ffs_dfindnext
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x96-ffs_stat" class="md-nav__link">
    <span class="md-ellipsis">
      0x96: ffs_stat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x97-ffs_unlink" class="md-nav__link">
    <span class="md-ellipsis">
      0x97: ffs_unlink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x98-ffs_rename" class="md-nav__link">
    <span class="md-ellipsis">
      0x98: ffs_rename
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x99-ffs_chmod" class="md-nav__link">
    <span class="md-ellipsis">
      0x99: ffs_chmod
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9a-ffs_utime" class="md-nav__link">
    <span class="md-ellipsis">
      0x9A: ffs_utime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9b-ffs_mkdir" class="md-nav__link">
    <span class="md-ellipsis">
      0x9B: ffs_mkdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9c-ffs_chdir" class="md-nav__link">
    <span class="md-ellipsis">
      0x9C: ffs_chdir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9d-ffs_chdrive" class="md-nav__link">
    <span class="md-ellipsis">
      0x9D: ffs_chdrive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9e-ffs_getcwd" class="md-nav__link">
    <span class="md-ellipsis">
      0x9E: ffs_getcwd
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0x9f-ffs_mount" class="md-nav__link">
    <span class="md-ellipsis">
      0x9F: ffs_mount
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa0-ffs_mkfs" class="md-nav__link">
    <span class="md-ellipsis">
      0xA0: ffs_mkfs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa1-ffs_fdisk" class="md-nav__link">
    <span class="md-ellipsis">
      0xA1: ffs_fdisk
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa2-ffs_getfree" class="md-nav__link">
    <span class="md-ellipsis">
      0xA2: ffs_getfree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa3-ffs_getlabel" class="md-nav__link">
    <span class="md-ellipsis">
      0xA3: ffs_getlabel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa4-ffs_setlabel" class="md-nav__link">
    <span class="md-ellipsis">
      0xA4: ffs_setlabel
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa5-ffs_setcp" class="md-nav__link">
    <span class="md-ellipsis">
      0xA5: ffs_setcp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0xa6-ffs_flseek_p" class="md-nav__link">
    <span class="md-ellipsis">
      0xA6: ffs_flseek_p
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#status-codes" class="md-nav__link">
    <span class="md-ellipsis">
      Status Codes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sysvars" class="md-nav__link">
    <span class="md-ellipsis">
      System State Information (SysVars)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="System State Information (SysVars)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sysvar_rtc" class="md-nav__link">
    <span class="md-ellipsis">
      Real Time Clock
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/AgonPlatform/agon-docs/edit/main/docs/mos/API.md" title="Edit this page" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg>
    </a>
  
  


<h1 id="what-is-the-mos-api">What is the MOS API</h1>
<p>The MOS API can be used by external applications to access MOS functionality.</p>
<p>Please note that this documentation uses assembler in the examples in a format that is compatible with the Zilog ZDS II assembler.  The assembler syntax used in BBC BASIC is similar, but not identical.  Additionally you will need to use the new ADL version of BBC BASIC to use the new eZ80 ADL mode and extended instruction set.</p>
<p>This documentation is not intended as a tutorial on eZ80 assembler, but as a reference for those who are already familiar with the eZ80 or Z80 instruction set and wish to use MOS APIs in their programs.</p>
<h2 id="rst">Usage from Z80 assembler</h2>
<p>There are four RST instructions for accessing MOS functionality from Z80.</p>
<ul>
<li><code>RST 00h</code>: Reset the eZ80</li>
<li><code>RST 08h</code>: Execute a MOS command</li>
<li><code>RST 10h</code>: Output a single character to the VDP</li>
<li><code>RST 18h</code>: Output a stream of characters to the VDP (MOS 1.03 or above)</li>
<li><code>RST 38h</code>: Outputs a crash report (MOS 2.3.0 or above)</li>
</ul>
<p>In addition, if you are using the Zilog ZDS II assembler you may wish to include the file <code>mos_api.inc</code> in your project.  The latest Agon Platform (previously known as Console8) version can be found in the folder <a href="https://github.com/AgonPlatform/agon-mos/tree/main/src">src</a> of project <a href="https://github.com/AgonPlatform/agon-mos">agon-mos</a>.  The original Quark versions of this file can be found in the folder <a href="https://github.com/breakintoprogram/agon-./tree/main/src">src</a> of project <a href="https://github.com/breakintoprogram/agon-mos">agon-mos</a>.</p>
<p>NB:</p>
<ul>
<li>Using the <code>RST.LIS</code> opcode in an eZ80 assembler will ensure the MOS <code>RST</code> instructions are called regardless of the eZ80s current addressing mode<ul>
<li>The Agon MOS RST handlers are written with the assumption that they have been called using <code>RST.LIS</code></li>
<li>Programs written to run in Z80 mode, using only plain Z80 opcodes, would therefore need to set up their own RST handlers to call through to to MOS using <code>RST.LIS</code></li>
</ul>
</li>
<li>This documentation generally uses the term <code>RST</code> in place of <code>RST.LIS</code> for simplicity</li>
<li>In the <code>mos_api.inc</code> file you will find:<ul>
<li>EQUs for all the MOS commands, data structures and <a href="#sysvars">system state variables (sysvars)</a></li>
<li>An incomplete list of VDP control variables.  For a full list, see the <a href="../../VDP/">VDP documentation</a></li>
<li>A complete list FatFS APIs, however it should be noted that many these are not implemented in MOS prior to MOS 3.0</li>
</ul>
</li>
</ul>
<p>Further information on the <code>RST</code> handlers provided by MOS are as follows:</p>
<h3 id="rst-08h-execute-a-mos-command"><code>RST 08h</code>: Execute a MOS command</h3>
<p>Parameters:</p>
<ul>
<li><code>A</code>: MOS command number to execute</li>
</ul>
<p>NB:</p>
<ul>
<li>There is a macro in <code>mos_api.inc</code> with EQUs for all the MOS commands</li>
<li>Other MOS-command dependant parameters may be required</li>
</ul>
<p>Macro:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>;
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a>; Macro for calling the API
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a>; Parameters:
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a>; - `F`unction: One of the function numbers listed above
<a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a>;
<a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a>MOSCALL:    MACRO   function
<a id="__codelineno-0-7" name="__codelineno-0-7" href="#__codelineno-0-7"></a>            LD  A, function
<a id="__codelineno-0-8" name="__codelineno-0-8" href="#__codelineno-0-8"></a>            RST.LIS 08h
<a id="__codelineno-0-9" name="__codelineno-0-9" href="#__codelineno-0-9"></a>            ENDMACRO
</code></pre></div>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>; OSRDCH: Read a character in from the ESP32 keyboard handler
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>;
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>OSRDCH: MOSCALL mos_getkey
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>        OR  A
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>        JR  Z, OSRDCH       ; Loop until key is pressed
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>        RET
</code></pre></div>
<h3 id="rst-10h-output-a-single-character-to-the-vdp"><code>RST 10h</code>: Output a single character to the VDP</h3>
<p>Parameters:</p>
<ul>
<li><code>A</code>: Character to output</li>
</ul>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a>; A: Character to write
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>;
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>OSWRCH: RST.LIS 10h         ; This calls a RST in the eZ80 address space
<a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a>        RET
</code></pre></div>
<h3 id="rst-18h-output-a-stream-of-characters-to-the-vdp-mos-103-or-above"><code>RST 18h</code>: Output a stream of characters to the VDP (MOS 1.03 or above)</h3>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of the data stream (16-bit for Z80 mode, 24-bit for ADL mode)</li>
<li><code>BC</code>: Length of stream (or 0 if the stream is delimited)</li>
<li><code>A</code>: Stream delimiter (if <code>BC</code>=0)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Last character displayed (length mode) OR Delimiter (delimiter mode)</li>
<li><code>BC</code>: 0</li>
<li><code>HL(U)</code>: Address of last character displayed + 1 (length mode) OR location of delimiter (delimiter mode)</li>
<li><code>E</code>: Value of <code>A</code> upon entry</li>
</ul>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>; Write a stream of characters to the VDP
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>; HLU: Address of buffer containing data - if in 16-bit segment, U will be replaced by MB
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>;  BC: Number of characters to write out, or 0 if the data is delimited
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a>;   A: End of data delimiter, i.e. 0 for C strings
<a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a>;
<a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a>        LD  HL, text        ; Address of text
<a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a>        LD  BC, 0           ; Set to 0, so length ignored...
<a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a>        LD  A, 0            ; Use character in A as delimiter
<a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a>        RST.LIS 18h         ; This calls a RST in the eZ80 address space
<a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a>        RET
<a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a>;
<a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a>text:   DB  &quot;Hello World&quot;, 0
</code></pre></div>
<h3 id="rst-38h-outputs-a-crash-report-mos-230-or-above"><code>RST 38h</code>: Outputs a crash report (MOS 2.3.0 or above)</h3>
<p>This command will output a crash report to the screen.  This report will show the current processor state, and the top of the stack.  This can be useful for debugging purposes.</p>
<p>This command works in conjunction with the fact that as of MOS 2.3.0, on initial startup memory will be reset to contain <code>0xFF</code> bytes in every location, which equates to a <code>RST 38h</code> instruction.  This means that for many system crashes execution will end up at the <code>RST 38h</code> instruction, and a crash report will be displayed on the screen.</p>
<h2 id="the-mos-api">The MOS API</h2>
<p>MOS API calls can be executed from a classic 64K Z80 segment or whilst the eZ80 is running in 24-bit ADL mode. For classic mode, 16 bit registers are passed as pointers to the MOS commands; these are automatically promoted to 24 bit by adding the MB register to bits 16-23 of the register. When running in ADL mode, a 24-bit register will be passed, but MB must be set to <code>0</code>.</p>
<p>Many, but not all, of the MOS API calls will return a <a href="#status-codes">status code</a> in the <code>A</code> register.  This status code will indicate the success or failure of the operation.  If the operation was successful, the status code will be <code>0</code>.  If the operation failed, the status code will be non-zero, and will indicate the nature of the failure.  Some API calls, such as those for I2C communications or string comparisons, use different sets of status codes, which are documented in the API call's description.</p>
<p>The APIs available from MOS have changed over time, and some of the APIs described are only available in later versions of MOS.  If you attempt to call an API that is not available in the version of MOS you are using the API will return the status value <code>23</code> in the <code>A</code> register to indicate it is not supported.  Please note that MOS 2.1.0 and earlier, including Quark MOS 1.04, do support detecting unknown/unsupported API calls and will produce unexpected results if you attempt to call an API that is not supported.  This is a known issue with these versions of MOS, and it is recommended to upgrade to a later version of MOS if you are using these versions.</p>
<h3 id="advice-on-file-handling">Advice on file handling</h3>
<p>As of MOS 3.0, all the MOS API calls that accept any kind of filepath string as a parameter, whether that is to a filename or a directory, will support the use of <a href="../System-Variables/">system variables</a> and <a href="../System-Variables/#path-variables">custom file paths</a> within the string.  These will automatically be handled in native MOS file handling API calls.  This allows for more flexible and powerful file handling in your applications.</p>
<p>Please note that the FatFS API calls (which named with an <code>ffs_</code> prefix) do <em>not</em> support this behaviour, and will only work with fully resolved file paths.  There is an API to <a href="#0x38-mos_resolvepath">resolve the path</a> which can be used to convert a path with system variables into a path suitable for use with the fatfs APIs.</p>
<p>In general, to read and/or write files files, it is recommended to use the MOS file APIs as these will automatically handle system variables and file paths.  MOS file APIs use a "file handle" to reference an open file, whereas the FatFS APIs expect a pointer to a <code>FIL</code> structure.  You can get a <code>FIL</code> structure for a MOS file handle by using the <a href="#0x19-mos_getfil"><code>mos_getfil</code> API</a>.  This will allow you to use the FatFS APIs directly if you need to, but in most cases it is recommended to use the MOS file APIs.  It is planned that future versions of MOS (beyond 3.0) will support using the MOS file APIs to open data streams other than files, such as the serial UART, I2C devices, and the VDP connection.  This will allow you to use the same APIs to read/write data across different all data streams.</p>
<h3 id="a-note-on-system-variables">A note on "system variables"</h3>
<p>Please note that MOS 3.0 <a href="../System-Variables/">system variables</a> are a distinct and different feature from <a href="#sysvars">system state information (sysvars)</a>.  Some older code and documentation may use the term "system variables" to refer to sysvars.</p>
<h3 id="apis-that-use-32-bit-values">APIs that use 32-bit values</h3>
<p>As of MOS 3.0 the standard for APIs that either require or return a 32-bit value is to pass a pointer to the value in a register.  Care should be taken to ensure that the pointer is pointing to a valid 4-byte block of memory.  There are two older APIs that date back to MOS 1.03, namely <a href="#0x1c-mos_flseek"><code>mos_flseek</code></a> and <a href="#0x84-ffs_flseek"><code>ffs_flseek</code></a> that used a different approach and return a 32-bit value spread across two registers, with the lower 24-bits in one register and the upper byte in a separate register.  As this is not friendly to Z80 code, MOS 3.0 has added new equivalent APIs that use the new 32-bit pointer approach.  The old APIs are still available for backwards compatibility, but it is recommended to use the new APIs where possible.</p>
<h3 id="core-mos-apis-and-modules">Core MOS APIs, and Modules</h3>
<p>A future version of MOS may support the use of <a href="../Modules/">modules</a> to extend the functionality of the system.  This may include adding new APIs, commands, and functions.</p>
<p>When this happens, the concept of "Core MOS" will be introduced.  Core MOS will be the set of APIs, commands, and functions that are guaranteed to be available to all programs.  </p>
<p>The exact set of APIs and commands that Core MOS will be comprised of has yet to be determined, but for compatibility with existing programs they will definitely include all commands and APIs that were available in MOS 2.3 and earlier.  It is expected that many of the APIs added in MOS 3.0 will also be included in Core MOS, but this is not guaranteed.</p>
<p>Functionality provided by modules would only be available to programs that are "module safe" or "module compatible".  Guidance on how to ensure that your program is "module safe" or "module compatible" will be provided in the <a href="../Modules/">MOS Modules</a> documentation.</p>
<h2 id="mos-api-calls">MOS API calls</h2>
<p>The following MOS commands are supported:</p>
<h3 id="0x00-mos_getkey"><code>0x00</code>: mos_getkey</h3>
<p>Read a keypress from the VDP</p>
<p>Parameters: None</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: The keycode of the character pressed</li>
</ul>
<p>NB: This is a blocking function. This routine will wait and only return once a key is pressed.</p>
<h3 id="0x01-mos_load"><code>0x01</code>: mos_load</h3>
<p>Load a file from SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of filename (zero terminated)</li>
<li><code>DE(U)</code>: Address at which to load</li>
<li><code>BC(U)</code>: Maximum allowed size (bytes)</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>F</code>: Carry reset if no room for file, otherwise set</li>
</ul>
<h3 id="0x02-mos_save"><code>0x02</code>: mos_save</h3>
<p>Save a file to SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of filename (zero terminated)</li>
<li><code>DE(U)</code>: Address to save from</li>
<li><code>BC(U)</code>: Number of bytes to save</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>F</code>: Carry set</li>
</ul>
<h3 id="0x03-mos_cd"><code>0x03</code>: mos_cd</h3>
<p>Change current directory on the SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of directory path (zero terminated)</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<h3 id="0x04-mos_dir"><code>0x04</code>: mos_dir</h3>
<p>List SD card folder contents to screen.</p>
<p>This is a simple directory listing command that will list the contents of the current directory to the screen.  More advanced directory listing functionality for applications to use is available via the <a href="#fatfs-commands">FatFS commands API</a>.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of directory path (zero terminated)</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<h3 id="0x05-mos_del"><code>0x05</code>: mos_del</h3>
<p>Delete a file or folder from the SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of filepath (zero terminated)</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<h3 id="0x06-mos_ren"><code>0x06</code>: mos_ren</h3>
<p>Rename a file on the SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of source filepath string (zero terminated)</li>
<li><code>DE(U)</code>: Address of destination filepath string (zero terminated)</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<p>As of MOS 3.0 the <code>mos_ren</code> API can support the use of wildcards in the source filepath leaf name.  This allows you to rename multiple files at once.  The destination filepath must point to a directory in this case.  Destination paths cannot include wildcards.</p>
<h3 id="0x07-mos_mkdir"><code>0x07</code>: mos_mkdir</h3>
<p>Make a folder on the SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of path (zero terminated)</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<h3 id="0x08-mos_sysvars"><code>0x08</code>: mos_sysvars</h3>
<p>Fetch a pointer to the <a href="#sysvars">system state variables</a></p>
<p>NB as this returns a pointer in <code>IXU</code>, and is therefore difficult to use from C code, as of MOS 3.0 an alternative way to access the sysvars address is available via a C function obtainable from the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Parameters: None</p>
<p>Returns:</p>
<ul>
<li><code>IXU</code>: Pointer to the MOS SysVars area (this is always 24 bit)</li>
</ul>
<h3 id="0x09-mos_editline"><code>0x09</code>: mos_editline</h3>
<p>Invoke the line editor</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of the buffer</li>
<li><code>BC(U)</code>: Buffer length</li>
<li><code>E</code>: Flags to control editor behaviour</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Key that was used to exit the input loop (CR=13, ESC=27)</li>
</ul>
<p>Editor behaviour flags are as follows:</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>When set, buffer will be cleared before use</td>
</tr>
<tr>
<td>1</td>
<td>When set, tab-completion for MOS commands and files is enabled *</td>
</tr>
<tr>
<td>2</td>
<td>When set, hotkeys are <em>disabled</em> *</td>
</tr>
<tr>
<td>3</td>
<td>When set, input history will be <em>disabled</em> *</td>
</tr>
<tr>
<td>4-7</td>
<td>Reserved for future use (for future compatibility, ensure these are set to zero)</td>
</tr>
</tbody>
</table>
<p>* Support for editor control flags was added in MOS 2.2.0.  Prior to this the only documented values for <code>E</code> were 0 and 1 to indicate whether the buffer should be cleared.</p>
<h3 id="0x0a-mos_fopen"><code>0x0A</code>: mos_fopen</h3>
<p>Get a file handle</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of filename (zero terminated)</li>
<li><code>C</code>: File open mode</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: File handle, or 0 if couldn't open</li>
</ul>
<p>Please note that whilst this API has always been documented as requiring a zero-terminated string for the filename, this was not actually <em>strictly</em> true.  It actually interpreted any control character (0-31) as a termination character.  MOS 3.0.0 changed this behaviour to be a strict zero-terminated string, but it was found that several keywords in BBC BASIC (<code>OPENIN</code>, <code>OPENOUT</code> and <code>OPENUP</code>) were failing to work because they were sending a carriage-return (13) as their termination character.  MOS 3.0.1 has been changed to support control-character termination again, thus fixing compatibility with BBC BASIC.  You are, however, strongly advised to use zero-terminated strings in your code, as relying on control character termination can cause other issues.</p>
<h4 id="file-open-modes">File open modes</h4>
<p>The mode is a number that indicates rules as to how the file will be opened.  Several different modes are available, and these values can be combined using a bitwise OR operation.  The values supported are inherited from FatFS, and are as follows:</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>FatFS constant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x01</td>
<td><code>FA_READ</code></td>
<td>Open file for reading</td>
</tr>
<tr>
<td>0x02</td>
<td><code>FA_WRITE</code></td>
<td>Open file for writing.  Combine with <code>FA_READ</code> for read/write access</td>
</tr>
<tr>
<td>0x00</td>
<td><code>FA_OPEN_EXISTING</code></td>
<td>Open file if it exists, fail if it doesn't</td>
</tr>
<tr>
<td>0x04</td>
<td><code>FA_CREATE_NEW</code></td>
<td>Create a new file, fail if it already exists</td>
</tr>
<tr>
<td>0x08</td>
<td><code>FA_CREATE_ALWAYS</code></td>
<td>Create a new file.  If the file already exists it will be truncated and overwritten</td>
</tr>
<tr>
<td>0x10</td>
<td><code>FA_OPEN_ALWAYS</code></td>
<td>Open file if it exists, create it if it doesn't</td>
</tr>
<tr>
<td>0x30</td>
<td><code>FA_OPEN_APPEND</code></td>
<td>Same as <code>FA_OPEN_ALWAYS</code>, except the read/write pointer will be set to the end of the file</td>
</tr>
</tbody>
</table>
<p>You may note that the "open existing" mode has a value of zero.  Setting either, or both, of the "create" options will override this.</p>
<p>NB: If you open the file using <code>mos_fopen</code>, you must close it using <code>mos_fclose</code>, not <code>ffs_api_fclose</code></p>
<h3 id="0x0b-mos_fclose"><code>0x0B</code>: mos_fclose</h3>
<p>Close a file handle</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle, or 0 to close all open files</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Number of files still open</li>
</ul>
<h3 id="0x0c-mos_fgetc"><code>0x0C</code>: mos_fgetc</h3>
<p>Get a character from an open file</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Character read</li>
<li><code>F</code>: C set if last character in file, otherwise NC (MOS 1.04 or greater)</li>
</ul>
<h3 id="0x0d-mos_fputc"><code>0x0D</code>: mos_fputc</h3>
<p>Write a character to an open file</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
<li><code>B</code>: Character to write</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<p>None</p>
<h3 id="0x0e-mos_feof"><code>0x0E</code>: mos_feof</h3>
<p>Check for end of file</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: 1 if at end of file, otherwise 0</li>
</ul>
<h3 id="0x0f-mos_geterror"><code>0x0F</code>: mos_getError</h3>
<p>Translates a status code into a human-readable message.</p>
<p>Parameters:</p>
<ul>
<li><code>E</code>: The status code</li>
<li><code>HL(U)</code>: Address of buffer to copy message into</li>
<li><code>BC(U)</code>: Size of buffer</li>
</ul>
<p>Preserves: <code>DE(U)</code>, <code>HL(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<p>None</p>
<h3 id="0x10-mos_oscli"><code>0x10</code>: mos_oscli</h3>
<p>Execute a MOS command</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer the the MOS command string</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<p>NB previously documentation for this command was incorrect, as it documented additional parameters in <code>DE(U)</code> and <code>BC(U)</code>.  These registers are not currently used.</p>
<h3 id="0x11-mos_copy"><code>0x11</code>: mos_copy</h3>
<p>Copy a file on the SD card</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of source filepath string (zero terminated)</li>
<li><code>DE(U)</code>: Address of destination filepath string (zero terminated)</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<p>NB: Requires MOS 1.03 or greater</p>
<p>Please note that this API only supports copying files; it does not support copying directories.</p>
<p>As of MOS 3.0, the <code>mos_copy</code> API supports the use of wildcards in the source filepath leaf name.  This allows you to copy multiple files at once.  The destination filepath must point to a directory in this case.  Destination paths cannot include wildcards.</p>
<h3 id="0x12-mos_getrtc"><code>0x12</code>: mos_getrtc</h3>
<p>Get a time string from the RTC (Requires MOS 1.03 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a buffer to copy the string to (at least 32 bytes)</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Length of time string</li>
</ul>
<h3 id="0x13-mos_setrtc"><code>0x13</code>: mos_setrtc</h3>
<p>Set the RTC (Requires MOS 1.03 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a 6-byte buffer with the time data in</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>+0: Year (offset from 1980, so 1989 is 9)
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a>+1: Month (1 to 12)
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a>+2: Day of Month (1 to 31)
<a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a>+3: Hour (0 to 23)
<a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a>+4: Minute (0 to 59)
<a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a>+5: Second (0 to 59)
</code></pre></div>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<p>None</p>
<h3 id="0x14-mos_setintvector"><code>0x14</code>: mos_setintvector</h3>
<p>Set an interrupt vector (Requires MOS 1.03 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>E</code>: Interrupt vector number to set</li>
<li><code>HLU</code>: Address of new interrupt vector (24-bit pointer)</li>
</ul>
<p>Preserves: <code>HLU</code>, <code>DEU</code></p>
<p>Returns:</p>
<ul>
<li><code>HL(U)</code>: Address of the previous interrupt vector (24-bit pointer)</li>
</ul>
<h3 id="0x15-mos_uopen"><code>0x15</code>: mos_uopen</h3>
<p>Open UART1 (Requires MOS 1.03 or above)</p>
<p>To handle the received interrupts, you will need to assign a handler to UART1's interrupt vector (0x1A).</p>
<p>NB as this API uses a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, as of MOS 3.0 th underlying function this API uses is available via a C function accessible using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Parameters:</p>
<ul>
<li><code>IX(U)</code>: Pointer to a UART struct</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>+0: Baud rate (24-bit, little endian)
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>+3: Data bits (5, 6, 7 or 8)
<a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>+4: Stop bits (1 or 2)
<a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>+5: Parity bits (0: None, 1: Odd, 3: Even)
<a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>+6: Flow control (0: None, 1: Hardware)
<a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a>+7: Enabled interrupts
<a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a>    - Bit 0: Set to enable received data interrupt
<a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a>    - Bit 1: Set to enable transmit data interrupt
<a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a>    - Bit 2: Set to enable line status change interrupt
<a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a>    - Bit 3: Set to enable modem status change interrupt
<a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a>    - Bit 4: Set to enable transmit complete interrupt
</code></pre></div>
<p>Preserves: <code>HL(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Error code (always 0)</li>
</ul>
<p>Please note that before MOS 3.0 the return value from this API was not always <code>0</code> owing to a bug in how the return value was handled.  This has been fixed in MOS 3.0 and later.</p>
<h3 id="0x16-mos_uclose"><code>0x16</code>: mos_uclose</h3>
<p>Close UART1 (Requires MOS 1.03 or above)</p>
<h3 id="0x17-mos_ugetc"><code>0x17</code>: mos_ugetc</h3>
<p>Read a character from UART1 (Requires MOS 1.03 or above)</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: The character read</li>
<li><code>F</code>: C if successful, NC if the UART is closed</li>
</ul>
<p>NB: If UART1 is open, this is a blocking function which means this routine will wait and only return once a character is received.</p>
<h3 id="0x18-mos_uputc"><code>0x18</code>: mos_uputc</h3>
<p>Write a character to UART1 (Requires MOS 1.03 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: The character to write</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>F</code>: C if successful, NC if the UART is closed</li>
</ul>
<h3 id="0x19-mos_getfil"><code>0x19</code>: mos_getfil</h3>
<p>Get a pointer to a <code>FIL</code> structure in MOS (Requires MOS 1.03 or above)</p>
<p>This call is useful if you wish to use the FatFS API directly, but need to pass a <code>FIL</code> structure to a FatFS API call.</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
</ul>
<p>Preserves: <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>HLU</code>: 24-bit pointer to a <code>FIL</code> structure (in MOS RAM)</li>
</ul>
<h3 id="0x1a-mos_fread"><code>0x1A</code>: mos_fread</h3>
<p>Read a block of data from a file (Requires MOS 1.03 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
<li><code>HLU</code>: Pointer to a buffer to read the data into</li>
<li><code>DEU</code>: Number of bytes to read</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>DEU</code>: Number of bytes read</li>
</ul>
<h3 id="0x1b-mos_fwrite"><code>0x1B</code>: mos_fwrite</h3>
<p>Write a block of data to a file (Requires MOS 1.03 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
<li><code>HLU</code>: Pointer to a buffer that contains the data to write</li>
<li><code>DEU</code>: Number of bytes to write out</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>DEU</code>: Number of bytes written</li>
</ul>
<h3 id="0x1c-mos_flseek"><code>0x1C</code>: mos_flseek</h3>
<p>Move the read/write pointer in a file (Requires MOS 1.03 or above)</p>
<p>NB this API is deprecated and kept for compatibility reasons.  You are advised to use the <a href="#0x24-mos_flseek_p"><code>mos_flseek_p</code></a> API instead.  As this API requires a full 24-bit value to be provided in the <code>HLU</code> register it is not directly compatible with programs written to run in Z80 mode.</p>
<p>This API can be used to expand the size of a file, although you should note that the file data in the expanded part will be undefined.</p>
<p>Please note that on MOS releases prior to MOS 3.0, the status code returned in the <code>A</code> register will be incorrect.</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
<li><code>HLU</code>: Least significant 3 bytes of the offset from the start of the file</li>
<li><code>E</code>: Most significant byte of the offset (set to 0 for files &lt; 16MB)</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<h3 id="0x1d-mos_setkbvector"><code>0x1D</code>: mos_setkbvector</h3>
<p>Allows user programs to access VDP keyboard packets without overriding the entire uart0 interrupt handler.
The user program registered, will be called during the uart0 interrupt handler, being passed the address of the full VDP keyboard packet.</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: Address length in HL (0 = 24bit, 1 = 16bit). If 1 then set the top byte of HLU (callback address) to MB (for ADL=0 callers)</li>
<li><code>HL(U)</code>: Callback address of user program to register, or 0 to clear any previously registered vector</li>
</ul>
<p>Returns: Nothing upon registration. The user program can expect the full VDP packet address in DE(24-bit) upon entry.</p>
<p>Be sure to clear the kbvector before your program exits (call mos_setkbvector again with HL=0).</p>
<p><a href="https://github.com/tomm/toms-agon-experiments/blob/main/custom_kbvector_demo/custom_kbvector_demo.asm">example code</a> that registers a custom handler.</p>
<h3 id="0x1e-mos_getkbmap"><code>0x1E</code>: mos_getkbmap</h3>
<p>Fetch a pointer to the virtual keyboard map (Requires MOS 1.04 RC2 or above)</p>
<p>NB as this returns a pointer in IXU, and is therefore difficult to use from C code, as of MOS 3.0 an alternative way to access the keyboard bitmap address is available via a C function obtainable from the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Parameters: None</p>
<p>Returns:</p>
<ul>
<li><code>IXU</code>: Pointer to the keyboard bitmap (this is always 24 bit)</li>
</ul>
<h3 id="0x1f-mos_i2c_open"><code>0x1F</code>: mos_i2c_open</h3>
<p>Open the I2C bus as Master (Requires MOS 1.04 RC3 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: Frequency ID (1: 57600, 2: 115200, 3: 230400)</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns: None</p>
<h3 id="0x20-mos_i2c_close"><code>0x20</code>: mos_i2c_close</h3>
<p>Close the I2C bus (Requires MOS 1.04 RC3 or above)</p>
<p>Parameters: None</p>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns: None</p>
<h3 id="0x21-mos_i2c_write"><code>0x21</code>: mos_i2c_write</h3>
<p>Write a block of bytes to the I2C bus (Requires MOS 1.04 RC3 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: I2C Address</li>
<li><code>B</code>: Number of bytes to write (maximum 32)</li>
<li><code>HL(U)</code>: Pointer to a buffer to read the bytes from</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status<ul>
<li><code>0</code>: OK</li>
<li><code>1</code>: No response from I2C slave</li>
<li><code>2</code>: Data NACK</li>
<li><code>4</code>: Bus arbitration lost</li>
<li><code>8</code>: Bus error</li>
</ul>
</li>
</ul>
<h3 id="0x22-mos_i2c_read"><code>0x22</code>: mos_i2c_read</h3>
<p>Read a block of bytes from the I2C bus (Requires MOS 1.04 RC3 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: I2C Address</li>
<li><code>B</code>: Number of bytes to read (maximum 32)</li>
<li><code>HL(U)</code>: Pointer to a buffer to write the bytes to</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status<ul>
<li><code>0</code>: OK</li>
<li><code>1</code>: No response from I2C slave</li>
<li><code>2</code>: Data NACK</li>
<li><code>4</code>: Bus arbitration lost</li>
<li><code>8</code>: Bus error</li>
</ul>
</li>
</ul>
<h3 id="0x23-mos_unpackrtc"><code>0x23</code>: mos_unpackrtc</h3>
<p>Unpack the RTC (Real-Time Clock) data into a buffer (Requires MOS 3.0 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a buffer to copy the RTC data to</li>
<li><code>C</code>: Flags</li>
</ul>
<p>The buffer should be at least 10 bytes long.</p>
<p>Flags are a bit-field to enable various different options.  Currently the following bits are supported:</p>
<ul>
<li>bit 0 = refresh RTC sysvar before unpacking</li>
<li>bit 1 = refresh RTC sysvar after unpacking</li>
</ul>
<p>The RTC data sysvar is updated by sending a command to the VDP to request the current time, and MOS will store the response in the <a href="#sysvar_rtc">RTC system state information area</a>.  If you set bit 0, this API call will send the command to the VDP to request updated RTC data and wait for the response before unpacking the data.  When you set bit 1, the command will be sent after the data has been unpacked, and the API will return without waiting for the response.</p>
<p>If you do not want to refresh the RTC data stored in MOS, set the flags to 0.  You should note that if you do this the data may be stale or, if no request has been sent to the VDP at all for RTC information, be invalid.</p>
<p>NB you should not set either refresh flag if you are in the middle of sending a command to the VDP, as that will both cause the update command to not be understood by the VDP, and will cause your command to fail or produce unexpected results.</p>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<p>Data returned in the buffer at <code>HL(U)</code> will be in the following order, with 16-bit values stored in little-endian order:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>    UINT16 year;
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a>    UINT8  month;
<a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a>    UINT8  day;
<a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a>    UINT8  dayOfWeek;
<a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a>    UINT16 dayOfYear;
<a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a>    UINT8  hour;
<a id="__codelineno-6-7" name="__codelineno-6-7" href="#__codelineno-6-7"></a>    UINT8  minute;
<a id="__codelineno-6-8" name="__codelineno-6-8" href="#__codelineno-6-8"></a>    UINT8  second;
</code></pre></div>
<h3 id="0x24-mos_flseek_p"><code>0x24</code>: mos_flseek_p</h3>
<p>Move the read/write offset pointer in a file (Requires MOS 3.0 or above)</p>
<p>This API can be used to expand the size of a file, although you should note that the file data in the expanded part will be undefined.</p>
<p>Whilst the <a href="#0x1c-mos_flseek"><code>mos_flseek</code></a> API can essentially perform the same function as this API, this is the preferred API to use for moving the current read/write pointer offset within a file.  As it accepts a pointer to the 32-bit offset value, it is compatible with both Z80-mode and ADL-mode code.</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: File handle</li>
<li><code>HL(U)</code>: Pointer to a 32-bit value for the desired new offset from the start of the file</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<hr />
<h3 id="0x28-0x2c-string-functions"><code>0x28-0x2C</code>: String functions</h3>
<p>API calls in this range are string manipulation functions.</p>
<p>All of the API calls in this range require MOS 3.0 or above.</p>
<h3 id="0x28-mos_pmatch"><code>0x28</code>: mos_pmatch</h3>
<p>Pattern matching function, with support for various flags to control how the comparison is made.</p>
<p>This exposes the pattern matching function that MOS 3.0 uses internally for matching commands and filenames.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Address of pattern (zero terminated)</li>
<li><code>DE(U)</code>: Address at string to compare against pattern (zero terminated)</li>
<li><code>C</code>: Flags</li>
</ul>
<p>The flags are a bit-field to enable various different pattern matching options</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Case insensitive</td>
</tr>
<tr>
<td>1</td>
<td>Disable star (<code>*</code>) wildcard matching</td>
</tr>
<tr>
<td>2</td>
<td>Disable hash (<code>#</code>) wildcard matching</td>
</tr>
<tr>
<td>3</td>
<td>"Dot as star" mode (treats <code>.</code> at the end of pattern as a star, used in MOS for matching abbreviated commands)</td>
</tr>
<tr>
<td>4</td>
<td>"Begins with" mode (only matches if the string starts with the pattern)</td>
</tr>
<tr>
<td>5</td>
<td>"Up to space" mode (only matches up to the first space in the pattern)</td>
</tr>
</tbody>
</table>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code> and <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status<ul>
<li><code>0</code> if pattern matches</li>
<li>Positive number if string does not match, and is logically sorted after the pattern</li>
<li>Negative number if string does not match, and is logically sorted before the pattern</li>
</ul>
</li>
</ul>
<h3 id="0x29-mos_getargument"><code>0x29</code>: mos_getargument</h3>
<p>Extract a (numbered) argument from a string</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to source string</li>
<li><code>BC(U)</code>: Argument number</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>HL(U)</code>: Address of the argument or zero if not found</li>
<li><code>DE(U)</code>: Address of the argument end (next character after the argument)</li>
</ul>
<p>Preserves: <code>BC(U)</code></p>
<h3 id="0x2a-mos_extractstring"><code>0x2A</code>: mos_extractstring</h3>
<p>Extract a string, using a given divider.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated source string to extract from</li>
<li><code>DE(U)</code>: Pointer to string for divider matching, or <code>0</code> for default (space)</li>
<li><code>C</code>: Flags. Depending on flags, the result string will be zero terminated or not</li>
</ul>
<p>The flags are a bit-field to enable various different options</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Zero terminate the result string</td>
</tr>
<tr>
<td>1</td>
<td>Omit skipping of divider characters at beginning of source string</td>
</tr>
<tr>
<td>2</td>
<td>Disable matching of double-quotes</td>
</tr>
<tr>
<td>3</td>
<td>Include double-quotes in results string</td>
</tr>
</tbody>
</table>
<p>If string extraction is matching double-quotes and an end quote is not found, a status code of <code>25</code> (Bad string) will be returned.  If it is not possible to extract a result, a status code of <code>19</code> (Invalid parameter) will be returned.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: status code (<code>0</code> = OK, <code>19</code> = Invalid parameter, <code>25</code> = Bad string)</li>
<li><code>HL(U)</code>: Address of the result string</li>
<li><code>DE(U)</code>: Address of next character after end of result string</li>
</ul>
<p>Preserves: <code>BC(U)</code></p>
<h3 id="0x2b-mos_extractnumber"><code>0x2B</code>: mos_extractnumber</h3>
<p>Extract a number, using given divider.  Various number formats are supported - for more information see notes on numbers interpreted by the <a href="../Star-Commands/">MOS CLI</a></p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated source string to extract from</li>
<li><code>DE(U)</code>: Pointer to string for divider matching, or 0 for default (space)</li>
<li><code>C</code>: Flags</li>
</ul>
<p>The flags are a bit-field to enable various different options</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Decimal numbers only</td>
</tr>
<tr>
<td>1</td>
<td>Positive numbers only</td>
</tr>
<tr>
<td>2</td>
<td>Allow <code>h</code> suffix to indicate hexadecimal numbers</td>
</tr>
</tbody>
</table>
<p>If the source string does not contain a valid number, in accordance with the flags, a status code of <code>19</code> (Invalid parameter) will be returned.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: status code (<code>0</code> = OK, <code>19</code> = Invalid parameter)</li>
<li><code>HL(U)</code>: Number extracted</li>
<li><code>DE(U)</code>: Address of next character after end of number</li>
</ul>
<p>Preserves: <code>BC(U)</code></p>
<h3 id="0x2c-mos_escapestring"><code>0x2C</code>: mos_escapestring</h3>
<p>"Escape" a string for display, converting control characters to be pipe-prefixed</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to source string</li>
<li><code>DE(U)</code>: Pointer to destination buffer (optional)</li>
<li><code>BC(U)</code>: Length of destination buffer</li>
</ul>
<p>If no destination buffer is provided (i.e. <code>DE</code> is zero), the function will return the length of the escaped string.</p>
<p>If the destination buffer is too short then a status code of <code>22</code> (Out of memory) will be returned, and as much of the source string that could be converted will be copied to the destination buffer.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>BC(U)</code>: Length of escaped string</li>
</ul>
<hr />
<h3 id="0x30-0x37-system-variables-and-string-translations"><code>0x30-0x37</code>: System variables and string translations</h3>
<p>API calls in this range are used for setting and reading system variables, and for performing string translations.</p>
<p>All of the API calls in this range require MOS 3.0 or above.</p>
<h3 id="0x30-mos_setvarval"><code>0x30</code>: mos_setvarval</h3>
<p>Set, update, replace or remove a <a href="../System-Variables/">System Variable</a></p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to variable name (zero-terminated string, can include wildcards)</li>
<li><code>IX(U)</code>: Variable value (number, or pointer to zero-terminated string)</li>
<li><code>IY(U)</code>: Pointer to variable name (0 for first call)</li>
<li><code>C</code>: Variable type, or -1 (255) to delete the variable</li>
</ul>
<p>If the name used includes a wildcard, then the first matching variable will be set.  Subsequent calls can be made to set the next variable that matches the pattern, so long as you preserve <code>IY(U)</code> between calls.</p>
<p>Variable types supported are:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>String (Will be run through GSTrans before storing)</td>
</tr>
<tr>
<td>1</td>
<td>Number (a 24-bit integer value)</td>
</tr>
<tr>
<td>2</td>
<td>Macro (A string that will be GSTrans'd each time it is used)</td>
</tr>
<tr>
<td>3</td>
<td>"Expanded" (Expression that will be evaluated before stored)</td>
</tr>
<tr>
<td>4</td>
<td>Literal string (GSTrans will not be called before storage)</td>
</tr>
</tbody>
</table>
<p>NB at the time of writing the expression engine has yet to be written in MOS 3 so type 3 support is limited to either a number or a string to indicate a variable name to copy as a string type.</p>
<p>If either a type of 3 or 4 is used then the variable type used for storage of the variable will be either a string or a number.</p>
<p>Internally MOS also supports "Code" type variables, which are used for several things, such as exposing date/time information.  If such a variable variable supports being set then you can call the "set" functions of these variables by using the String type with a matching name.  You cannot remove a "Code" type variable using this function.</p>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>C</code>: Actual variable type</li>
<li><code>IY(U)</code>: Pointer to actual variable name (for next call)</li>
</ul>
<p>Other registers will be preserved.</p>
<h3 id="0x31-mos_readvarval"><code>0x31</code>: mos_readvarval</h3>
<p>Read a variable value</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to variable name (can include wildcards)</li>
<li><code>DE(U)</code>: Length of buffer to store the value</li>
<li><code>IX(U)</code>: Pointer to buffer to store the value (null/0 to read length only)</li>
<li><code>IY(U)</code>: Pointer to variable name (0 for first call)</li>
<li><code>C</code>: Flags (3 = expand value into string - other values will be ignored)</li>
</ul>
<p>If the name includes a wildcard then the first matching variable will be read.  Subsequent calls can be made to read the next value that matches the pattern, so long as you preserve <code>IY(U)</code> between calls.</p>
<p>Please note that whilst numeric variables are set using <a href="#0x30-mos_setvarval"><code>mos_setvarval</code></a> by providing their value directly in a register, when reading a numeric variable the value will be returned in the buffer pointed to by <code>IX(U)</code>.  That buffer must be at least 3 bytes long, unless the "flag" value is set to <code>3</code>, in which case it must be large enough to contain a string representation of the number in decimal.</p>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>C</code>: Actual variable type</li>
<li><code>DE(U)</code>: Length of variable value</li>
<li><code>IY(U)</code>: Pointer to variable name (for next call)</li>
</ul>
<h3 id="0x32-mos_gsinit"><code>0x32</code>: mos_gsinit</h3>
<p>Initialises a GSTrans operation.</p>
<p>GSTrans is a process of taking a source string and translating it, replacing any variables referenced, and converting any control codes into raw control bytes.  The <a href="../Star-Commands/#echo"><code>echo</code> command</a> in MOS is an example of a command that uses the GSTrans process, and the documentation for that command contains a more complete description of how the source string will be interpreted.</p>
<p>The process of translating a string is a two-step process.  The first step is to call <code>mos_gsinit</code> to initialise the process, and the second step is to repeatedly call <code>mos_gsread</code> to actually perform the translation, fetching one character at a time until the whole string has been translated, and a zero character is read.</p>
<p>Various options are available to control how the translation process operates, and these are set using the flags parameter.  By default, the translation process will continue until the end of the source string is reached.  It is possible to instead translate only up to the first space.  The process also supports detecting double-quotes to surround a string, in which case a request to terminate at a space will be ignored if the space is inside the double-quotes.  (It should be noted that the <code>echo</code> command sets this flag.)  Finally by default the process will translate characters preceeded by a <code>|</code> character as control codes, as explained in the documentation for the <a href="../Star-Commands/#echo"><code>echo</code> command</a>.  If you wish to disable this behaviour then you can set the "no pipe" flag.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to source buffer to translate</li>
<li><code>DE(U)</code>: Address of pointer used to store trans info</li>
<li><code>C</code>: Flags</li>
</ul>
<p><code>DE(U)</code> must point to an address that will be used to store a (3-byte) pointer to an information block used by the GSTrans process.  It should be noted that failing to complete the GSTrans process can result in a memory leak.</p>
<p>The flags are a bit-field with options to control how the translation process operates.  Their meanings are as follows:</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Terminate at first space character in source buffer</td>
</tr>
<tr>
<td>1</td>
<td>No pipe (do not treat <code>|</code> as a control code)</td>
</tr>
<tr>
<td>2</td>
<td>Do not treat double-quotes <code>"</code> as markers surrounding a string</td>
</tr>
<tr>
<td>3-6</td>
<td>Reserved for future use (for future compatibility, ensure these are set to zero)</td>
</tr>
<tr>
<td>7</td>
<td>No tracking (do not automatically track memory used by GSTrans)</td>
</tr>
</tbody>
</table>
<p>It should be noted that failing to complete translation of a string will result in some memory inside MOS remaining set aside to store the GSTrans process information.  This memory will either be freed when the GSTrans process is completed, or a new call to <code>mos_gsinit</code> is made.  If the "No tracking" flag is set however then MOS will not track the memory being used, and it will not be freed on a subsequent call to <code>mos_gsinit</code> - you must complete the process of reading through the string to free the memory, or you will cause a memory leak inside MOS.</p>
<p>In general you should not use the "No tracking" flag unless you have a need to perform two or more gstrans operations simultaneously.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<h3 id="0x33-mos_gsread"><code>0x33</code>: mos_gsread</h3>
<p>Perform a GSTrans "read" operation.</p>
<p>When the final character of the translated string has been read, this function will return a null character (<code>0</code>) to indicate the end of the string.</p>
<p>Parameters:</p>
<ul>
<li><code>DE(U)</code>: Address of pointer used to store trans info (same pointer as used with gsInit)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code (<code>0</code> = Success, various other values may indicate an invalid GSTrans string)</li>
<li><code>C</code>: Character read.  This will be <code>0</code> if the end of the string has been reached.</li>
</ul>
<h3 id="0x34-mos_gstrans"><code>0x34</code>: mos_gstrans</h3>
<p>Perform a complete GSTrans operation from source into dest buffer</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to source buffer</li>
<li><code>IX(U)</code>: Pointer to destination buffer (can be null to just count size)</li>
<li><code>DE(U)</code>: Length of destination buffer</li>
<li><code>C</code>: Flags</li>
</ul>
<p>If the destination buffer given for this command is less than the size required for the translated string, then the API call will succeed, but the translated string will be truncated to fit in the buffer.</p>
<p>The flags here are identical those used with <code>mos_gsinit</code>, with the exception that the "No tracking" flag will be ignored.</p>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>BC(U)</code>: Calculated total length of translated string</li>
</ul>
<h3 id="0x35-mos_substituteargs"><code>0x35</code>: mos_substituteargs</h3>
<p>Substitute arguments into a string from template</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to template string</li>
<li><code>IX(U)</code>: Pointer to arguments string</li>
<li><code>DE(U)</code>: Length of destination buffer</li>
<li><code>IY(U)</code>: Pointer to destination buffer (can be null to just count size)</li>
<li><code>C</code>: Flags</li>
</ul>
<p>The only flag currently supported is bit 0, which when set indicates that the "rest" arguments (i.e. those not explicitly used in the template) should be omitted from the destination string.  When this bit is clear they will be automatically appended.</p>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>BC(U)</code>: Calculated length of destination string</li>
</ul>
<h3 id="0x36-mos_evaluateexpression"><code>0x36</code>: mos_evaluateexpression</h3>
<p>As of MOS 3.0 this function has not yet been implemented.  Support for this function is planned for a future release.</p>
<hr />
<h3 id="0x38-0x3c-file-path-functions"><code>0x38-0x3C</code>: File path functions</h3>
<p>These APIs provide a set of functions for working with and manipulating file paths.</p>
<p>All of the API calls in this range require MOS 3.0 or above.</p>
<h3 id="0x38-mos_resolvepath"><code>0x38</code>: mos_resolvepath</h3>
<p>Resolves a path, creating a new resolved path string that expands <a href="../System-Variables/">system variables</a>, and also replaces <a href="../System-Variables/#path-variables">prefixes</a> and leafnames with actual values.  System variables will be expanded first, and then the prefix and leafname will be resolved.  The result is a fully resolved path that can be used with the FatFS API calls.</p>
<p>If the leafname contains wildcards then the first matching file will be returned.  Please note that this will be the first match found in a directory, and owing to how directories are managed this may not be the first alphabetical match.  Subsequent calls can be made to find the next matching file, so long as you provide a pointer to an empty directory object to persist between calls, and preserve the <code>C</code> register between calls too.</p>
<p>NB path resolution does not support resolving paths that contain wildcards in the directory part of the path.  If you need to do this then you should gradually build the path up by calling <code>mos_resolvepath</code> multiple times to resolve the path up to each wildcard, using flags to filter for results that are a directory matching the wildcard until the directory part of the path is fully resolved.  You can then call <code>mos_resolvepath</code> again with different flags to resolve the leafname part of the path.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the path to resolve (zero terminated)</li>
<li><code>IX(U)</code>: Pointer to destination buffer to store the resolved path (optional - set to zero for length count only)</li>
<li><code>DE(U)</code>: Length of the destination buffer</li>
<li><code>IY(U)</code>: Pointer to a directory object to persist between calls (optional, set to zero to omit)</li>
<li><code>B</code>: Flags</li>
<li><code>C</code>: Index of the resolved path (zero for first call)</li>
</ul>
<p>Path resolution will resolve prefixes in files paths, which are a string followed by a colon character, such as <code>Library:</code>.  The string must match up with a corresponding system variable, in this example the variable would be named <code>Library$Path</code>.  Prefixes are not case-sensitive, so <code>library:</code>, <code>Library:</code> and <code>LIBRARY:</code> would all match in this example.  Such path variables can contain multiple values separated by commas.  The "index" argument in the <code>C</code> register is used to work out which prefix to use when there are multiple matches, and must be set to zero on a first call.</p>
<p>If you are resolving for a file that does not exist, the path will be resolved to the first matching directory, returning a "no file" (<code>4</code> status code).  If no matching directory can be found the path will not be resolved, and a "no path" (<code>5</code> status code) will be returned, and the returned path will be empty.  If the path is resolved successfully to an existing file the status code will be <code>0</code>.</p>
<p>The <code>flags</code> argument is a bit-field used to indicate which files are valid to be returned.  These bits are used to filter the results based on the file attributes, which are inherited from the file system (FatFS).  If you wish to always return all results you should set the flags to <code>0</code>.  The bits are as follows:</p>
<table>
<thead>
<tr>
<th>Bit</th>
<th>FatFS constant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>AM_RDO</code></td>
<td>Read only</td>
</tr>
<tr>
<td>1</td>
<td><code>AM_HID</code></td>
<td>Hidden</td>
</tr>
<tr>
<td>2</td>
<td><code>AM_SYS</code></td>
<td>System</td>
</tr>
<tr>
<td>3</td>
<td>n/a</td>
<td>Reserved/Unused - set to zero</td>
</tr>
<tr>
<td>4</td>
<td><code>AM_DIR</code></td>
<td>Directory</td>
</tr>
<tr>
<td>5</td>
<td><code>AM_ARC</code></td>
<td>Archive</td>
</tr>
<tr>
<td>6</td>
<td>n/a</td>
<td>Set to disable system variable expansion</td>
</tr>
<tr>
<td>7</td>
<td>n/a</td>
<td>Include/exclude in results</td>
</tr>
</tbody>
</table>
<p>System variable expansion passes the source path through the <a href="#0x34-mos_gstrans">GSTrans</a> process, replacing any system variables used in the path with their values.  If you have already performed this step then you can set bit 6 to disable the expansion.</p>
<p>Bit 7 is used to indicate how to apply the attributes to filter results.  When it is set, any result must include <em>all</em> of the attributes set.  When it is clear, the result will not include any of the attributes set.  This can be used, for example, to filter out hidden or system files, or alternatively to only include results that are directories.</p>
<p>NB any attributes that are not set in the <code>flags</code> argument will be ignored, so if you perform a search with a flags value of <code>0x06</code>, which will filter out hidden and system files, your results may include items that have their directory, read-only, and/or archive bits set.  Similarly a search with a flags value of <code>0x90</code> will only include directories, but those directories could have any of the other attributes set.</p>
<p>If you wish to further filter results you should pass in a <code>DIR</code> object in <code>IY(U)</code> to persist between calls, and use the <a href="#0x96-ffs_stat"><code>ffs_stat</code></a> API call to get a <code>FILINFO</code> object where you can check the full attributes of the the returned result (stored in the <code>fattrib</code> field).  If the results do not match your requirements you can then call <code>mos_resolvepath</code> again to find the next matching file.</p>
<p>If the leafname in your path contains wildcards then the first matching file will be returned.  If you wish to find the next matching file then you should provide a pointer to an empty directory object in <code>IY(U)</code> with your first call, and use the same object with subsequent calls (also using the same <code>C</code> register value).  If you do not include a pointer to a directory object then only the first matching file within a single directory will be returned.</p>
<p>Besides finding filecard matches, the other main use for this API is to resolve a path so that it can be used with <a href="#fatfs-commands">FatFS API calls</a>.  This step is needed to ensure that the path is fully resolved, as the FatFS API calls do not support using path prefixes or system variables.  Attempting to use an unresolved path with a fatfs API call may either fail or produce unexpected results.</p>
<p>It is not necessary to use this API call to resolve paths for use with the MOS-native API calls, as those will all automatically resolve paths for you.</p>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code (<code>0</code> = Success, <code>22</code> = Out of memory, <code>5</code> = No path, <code>4</code> = No file)</li>
<li><code>C</code>: Index of the resolved path (for next call)</li>
<li><code>DE(U)</code>: Length of the resolved path</li>
</ul>
<p>If this is called with a null pointer in <code>IX(U)</code> then the maximum possible length of of all possible resolved paths will be returned in <code>DE(U)</code>.  This is useful if you wish to allocate a buffer for the resolved path, but do not know how long it will be.</p>
<p>A result of <code>5</code> indicates that no matching directory could be found in the filing system.  A result of <code>4</code> indicates that a matching directory was found, but no matching file for that directory.</p>
<p>A result of <code>22</code> indicates that either the resolved path was too long for the buffer provided, or that there was an error allocating memory whilst searching for a matching path.</p>
<h3 id="0x39-mos_getdirforpath"><code>0x39</code>: mos_getdirforpath</h3>
<p>Get the directory for a given path.</p>
<p>This function works with strings only - it resolves path prefixes for the given index, but does not check whether the path actually points to a valid file or directory.  The index is used which prefix to use when the path prefix variable contains multiple options.</p>
<p>The returned path will be the directory part of the path, and will not include the leafname.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the path to get the directory for</li>
<li><code>IX(U)</code>: Pointer to the buffer to store the directory in (optional - omit for count only)</li>
<li><code>DE(U)</code>: Length of the buffer</li>
<li><code>C</code>: Search index</li>
</ul>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
<li><code>DE(U)</code>: Length of the directory path</li>
</ul>
<h3 id="0x3a-mos_getleafname"><code>0x3A</code>: mos_getleafname</h3>
<p>Get the leafname for a given path.</p>
<p>This is a utility function that will scan a file path string and return a pointer within that string to the leafname.  The leafname is the last part of a file path, and may refer to a file or a directory.  This call does not check whether the path actually points to a valid file or directory, and it does not resolve any path prefixes.  It should be noted that a leafname may be empty if the path is empty or ends with a <code>/</code> or <code>:</code> character.</p>
<p>If the path does not contain a valid leafname then the function will return a pointer to the end of the string.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the path to get the leafname from</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the leafname</li>
</ul>
<h3 id="0x3b-mos_isdirectory"><code>0x3B</code>: mos_isdirectory</h3>
<p>Checks if a given path points to a directory</p>
<p>NB this call only works with fully resolved paths, and as such does not perform path prefix resolution.  You may therefore need to use <a href="#0x39-mos_getdirforpath"><code>mos_getdirforpath</code></a> or <a href="#0x38-mos_resolvepath"><code>mos_resolvepath</code></a> first.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the path to check</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code (<code>0</code> = Success, <code>5</code> = No path)</li>
</ul>
<h3 id="0x3c-mos_getabsolutepath"><code>0x3C</code>: mos_getabsolutepath</h3>
<p>Get the absolute version of a (relative) path</p>
<p>NB currently as of MOS 3.0, unlike similar API calls above, this API does not support being called with a null pointer to count the length of the resolved path, and does not return the length.  If called with a null pointer from ADL mode, the API will return a status code of <code>19</code> (Invalid parameter).  Calling with a null pointer from Z80 mode code is not currently supported/checked and may cause unexpected results or crashes.  This will likely change in a future MOS release.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the path to get the absolute version of</li>
<li><code>IX(U)</code>: Pointer to the buffer to store the absolute path in</li>
<li><code>DE(U)</code>: Length of the buffer</li>
</ul>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<p>If the buffer is too short for the resolved path then a status code of <code>22</code> (Out of memory) will be returned.  Path resolution problems may result in status codes of <code>5</code> (No path) or <code>4</code> (No file).</p>
<hr />
<h3 id="0x40-0x50-vdp-protocol-and-miscellaneous-functions"><code>0x40-0x50</code>: VDP protocol, and miscellaneous functions</h3>
<p>Functions in this range are used for VDP protocol, and other miscellaneous functions.</p>
<p>All of the API calls in this range require MOS 3.0 or above.</p>
<h3 id="0x40-mos_clearvdpflags"><code>0x40</code>: mos_clearvdpflags</h3>
<p>Clears VDP Protocol status flags from the <code>sysvar_vpd_pflags</code> <a href="#sysvars">sysvar</a>.</p>
<p>Bits in this status value will be set when various different VDP Protocol message packet types are received by MOS from the VDP.  Such packets may be sent for user-initiated actions, such as pressing a key on the keyboard, or moving the mouse, or for system-initiated actions, such as a VDU command being sent to the VDP.  Please note that in general use these bits are not automatically cleared, so if you wish to detect a response from the VDP to a VDU command your program sends it is important to clear out the corresponding protocol flags before sending the command.  You can then use the <a href="#0x41-mos_waitforvdpflags"><code>mos_waitforvdpflags</code></a> API call to wait for the VDP to respond, and check the status of the flags in <code>sysvar_vpd_pflags</code> to see if the command was successful.</p>
<p>Further information on the VDP protocol and the flag bits can be found in the <a href="../../vdp/System-Commands/#vdp-serial-protocol">VDP Protocol documentation</a>.</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: Bitmask of flags to clear</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: New VDP flags</li>
</ul>
<h3 id="0x41-mos_waitforvdpflags"><code>0x41</code>: mos_waitforvdpflags</h3>
<p>Waits for corresponding VDP protocol flags to be set in the <code>sysvar_vpd_pflags</code> <a href="#sysvars">sysvar</a>.</p>
<p>Typically your program should first clear whichever protocol flag you are interested in detecting, using the <a href="#0x40-mos_clearvdpflags"><code>mos_clearvdpflags</code></a> API call.  Once you have done that, you should send a VDU command to the VDP for which you are expecting a response, and then use this API call to wait for that response to be received.</p>
<p>MOS contains inbuilt support for handling VDP protocol messages.  Typically on receipt of a message a flag will be set in the <code>sysvar_vpd_pflags</code> variable, and also other corresponding <a href="#sysvars">sysvars</a> will be updated from the contents of the message.</p>
<p>This API call will wait for approximately 1 second for the VDP to respond, which should be more than enough time for any VDU command to be processed.  If the VDP does not respond within this time, the API call will return with a status code of <code>15</code> (Timeout).  If the VDP does respond, the API call will return with a status code of <code>0</code> (Success).</p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: Bitmask of flags to wait for</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code (<code>0</code> = Success, <code>15</code> = Timeout)</li>
</ul>
<h3 id="0x50-mos_getfunction"><code>0x50</code>: mos_getfunction</h3>
<p>This API call will return a pointer to a function that follows the Zilog eZ80 C calling convention.  As these are 24-bit pointers, and passing arguments needs to be done using the 24-bit stack pointer (<code>SPL</code>), this API call is not usable by programs running in Z80 mode.</p>
<p>Information on the C calling convention can be found <a href="https://github.com/pcawte/AgDev?tab=readme-ov-file#c-calling-conventions-for-interfacing-with-asm-applications">here</a></p>
<p>Parameters:</p>
<ul>
<li><code>C</code>: Flags (must be <code>0</code> in MOS 3.0)</li>
<li><code>B</code>: Function number</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code (<code>0</code> = Success, <code>19</code> = Invalid parameter, <code>20</code> = Invalid command)</li>
<li><code>HLU</code>: Pointer to function (or <code>0</code> if the request was invalid invalid)</li>
</ul>
<p>If this API is called from Z80 mode code, then it will return a status code of <code>20</code> (Invalid command) as this API is only supported in ADL mode.</p>
<p>This API includes a flags byte which must be set to zero in MOS 3.0.  This is reserved for future use to allow for additional functionality to be added in future versions of MOS.  If flags are set to anything other than <code>0</code> then the API will return a status code of <code>19</code> (Invalid parameter).</p>
<p>Similarly, if the function number passed to this API is higher than the highest available function, then the API will return a status code of <code>20</code> (Invalid command).</p>
<p>Full details of the functions available through this API, and more information about how to use them, can be found in the documentation about <a href="../C-Functions/">C Functions</a></p>
<hr />
<h2 id="0x70-0x73-low-level-sd-card-access"><code>0x70-0x73</code>: Low-level SD card access</h2>
<p>These APIs provide low-level access to the SD card.  They are not intended for general use, but are provided for some special use-cases, such as for an operating system that uses a different filing system than FatFS, or for tools that wish to access the SD card in ways that are not supported by the FatFS library.</p>
<p>As the use of these APIs can potentialy cause data corruption in order to use them you need to use an "unlock code".  It is possible to avoid using the unlock mechanism by using the underlying functions directly via the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API call.</p>
<p>All of the APIs in this range require MOS 3.0 or above.</p>
<h3 id="0x70-sd_getunlockcode"><code>0x70</code>: sd_getunlockcode</h3>
<p>This API call is used to obtain the unlock code needed to use the low-level SD card APIs.  The unlock code is a randomly generated 24-bit value, created the first time this API is called.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a 24-bit value to store the unlock code</li>
</ul>
<p>Returns:</p>
<p>Nothing</p>
<h3 id="0x71-sd_init"><code>0x71</code>: sd_init</h3>
<p>Initialises the SD card support system.  MOS automatically calls this when it mounts an SD card.  If you are writing support for an operating system you may need to call this to restart the SD card system if the SD card is removed and reinserted.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to the unlock code (24-bit value) as fetched by the <a href="#0x70-sd_getunlockcode"><code>sd_getunlockcode</code></a> API call</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code<ul>
<li><code>0</code> = Success/Ready</li>
<li><code>1</code> = Error</li>
<li><code>2</code> = Locked (incorrect unlock code provided, or no lock code yet set)</li>
</ul>
</li>
</ul>
<h3 id="0x72-sd_readblocks"><code>0x72</code>: sd_readblocks</h3>
<p>Read raw blocks from the SD card.</p>
<p>Parameters:
- <code>HL(U)</code>: Pointer to a 32-bit sector number, followed by the 24-bit unlock code
- <code>DE(U)</code>: Pointer to a buffer to store the read data
- <code>BC</code>: Number of blocks to read (16-bit value)</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code<ul>
<li><code>0</code> = Success/Ready</li>
<li><code>1</code> = Error</li>
<li><code>2</code> = Locked (incorrect unlock code provided, or no lock code yet set)</li>
</ul>
</li>
</ul>
<h3 id="0x73-sd_writeblocks"><code>0x73</code>: sd_writeblocks</h3>
<p>Writes raw blocks to the SD card.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a 32-bit sector number, followed by the 24-bit unlock code</li>
<li><code>DE(U)</code>: Pointer to a buffer containing the data to write</li>
<li><code>BC</code>: Number of blocks to write (16-bit value)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code<ul>
<li><code>0</code> = Success/Ready</li>
<li><code>1</code> = Error</li>
<li><code>2</code> = Locked (incorrect unlock code provided, or no lock code yet set)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="fatfs-commands"><code>0x80-0xA6</code>: FatFS APIs</h2>
<p>MOS makes use of the <a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFS library</a> to access the SD card.  Some of FatFS's functionality is exposed as APIs in MOS.  These APIs are essentially provide a way to call the underlying FatFS functions that MOS uses to perform file operations.  The API calls are prefixed with <code>ffs_</code> to indicate that they are FatFS functions, and the <code>mos_</code> prefix is used for the native MOS API calls.</p>
<p>Our naming convention for FatFS APIs in MOS is to remove the <code>f_</code> prefix from the FatFS function name, and replace it with <code>ffs_</code>, plus an optionally <code>f</code> or <code>d</code> prefix.  For example, the API that exposes the <code>f_open</code> FatFS function is named <code>ffs_fopen</code>.</p>
<p>The variety of FatFS APIs supported in the MOS 1.x and MOS 2.x releases was limited to a restricted subset of functionality.  The first version of MOS that supported FatFS API calls was 1.03.  Versions of MOS 2.x added support for some additional APIs.  MOS 3.0 includes support for all of the possible FatFS APIs that are practical to support with our current configuration of FatFS, which greatly expands the available set of APIs.  For completeness, all potential FatFS APIs are documented below, including those that are not supported by our current configuration.  The APIs that are not supported will return a status code of <code>23</code> (Not implemented) in the A register.</p>
<p>When reading the documentation below, you should assume that the API calls are only available in MOS 3.0 or above, unless otherwise stated.</p>
<p>Please note that the FatFS API calls documented below expect file paths to be fully resolved, i.e. they should not include <a href="../System-Variables/#path-variables">path prefixes</a> or <a href="../System-Variables/">system variables</a>.  This means programs running on MOS 3 should use the <a href="#0x38-mos_resolvepath"><code>mos_resolvepath</code> API call</a> to resolve any paths before using them with a FatFS API call.  If you do not resolve the path then the FatFS API call may fail or produce unexpected results.  For many API calls you can instead open the file using the MOS API call <a href="#0x0a-mos_fopen"><code>mos_fopen</code></a> and then use <a href="#0x19-mos_getfil"><code>mos_getfil</code></a> to get a pointer to a <code>FIL</code> structure that many FatFS API calls require.</p>
<p>For more information on FatFS data structures (the <code>FIL</code>, <code>DIR</code> and <code>FILINFO</code> objects), functions, and info on which bits to set in fields such as "File open mode" please see the <a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFS documentation</a>.  The FatFS configuration can affect the contents of these data structures - our configuration has the <code>FF_USE_LFN</code> and <code>FF_USE_FIND</code> options set, and does <em>not</em> set <code>FF_READ_ONLY</code> or <code>FF_USE_FASTSEEK</code>.</p>
<h3 id="0x80-ffs_fopen"><code>0x80</code>: ffs_fopen</h3>
<p>Open a file (Available from MOS 1.03)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to an empty <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a C (zero-terminated) filename string</li>
<li><code>C</code>: File open mode</li>
</ul>
<p>The file open mode on this API is a bit-field that is identical to the <a href="#file-open-modes">mode used</a> in the <a href="#0x0a-mos_fopen"><code>mos_fopen</code></a> API call.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>C</code></p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>            LD  HL, fil             ; FIL buffer
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>            LD  DE, filename            ; Filename (0 terminated)
<a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>            LD  C, fa_read          ; Mode
<a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a>            MOSCALL ffs_fopen           ; Open the file
<a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a>            LD  DE, buffer          ; Where to store the read file
<a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a>            LD  BC, 256             ; Number of bytes to read
<a id="__codelineno-7-7" name="__codelineno-7-7" href="#__codelineno-7-7"></a>            MOSCALL ffs_fread           ; Read the data in
<a id="__codelineno-7-8" name="__codelineno-7-8" href="#__codelineno-7-8"></a>            PUSH    BC              ; Preserve number of bytes read
<a id="__codelineno-7-9" name="__codelineno-7-9" href="#__codelineno-7-9"></a>            MOSCALL ffs_fclose          ; Close the file
<a id="__codelineno-7-10" name="__codelineno-7-10" href="#__codelineno-7-10"></a>            POP BC              ; BC: Number of bytes read
<a id="__codelineno-7-11" name="__codelineno-7-11" href="#__codelineno-7-11"></a>            RET
<a id="__codelineno-7-12" name="__codelineno-7-12" href="#__codelineno-7-12"></a>
<a id="__codelineno-7-13" name="__codelineno-7-13" href="#__codelineno-7-13"></a>filename:       DB  &quot;example.txt&quot;, 0        ; The file to read
<a id="__codelineno-7-14" name="__codelineno-7-14" href="#__codelineno-7-14"></a>
<a id="__codelineno-7-15" name="__codelineno-7-15" href="#__codelineno-7-15"></a>fil:            DS  FIL_SIZE            ; FIL buffer (defined in mos_api.inc)
<a id="__codelineno-7-16" name="__codelineno-7-16" href="#__codelineno-7-16"></a>buffer:         DS  256             ; Buffer for storing read data
</code></pre></div>
<h3 id="0x81-ffs_fclose"><code>0x81</code>: ffs_fclose</h3>
<p>Close a file (Available from MOS 1.03)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<p>See <a href="#0x80-ffs_fopen"><code>ffs_fopen</code></a> for an example.</p>
<p>NB: you should not use this call to close a file that had been opened using <a href="#0x0a-mos_fopen"><code>mos_fopen</code></a>, as doing so will mean that MOS will be reserving an file handle for a file that has been closed.</p>
<h3 id="0x82-ffs_fread"><code>0x82</code>: ffs_fread</h3>
<p>Read from a file (Available from MOS 1.03)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a buffer to store the data in</li>
<li><code>BC(U)</code>: Number of bytes to read (typically the size of the buffer)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
<li><code>BC(U)</code>: Number of bytes read</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<p>See ffs_fopen for an example</p>
<h3 id="0x83-ffs_fwrite"><code>0x83</code>: ffs_fwrite</h3>
<p>Write to a file (Available from MOS 1.03)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a buffer to read the data from</li>
<li><code>BC(U)</code>: Number of bytes to write (typically the size of the buffer)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
<li><code>BC(U)</code>: Number of bytes written</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>            LD  HL, fil             ; FIL buffer
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a>            LD  DE, filename            ; Filename (0 terminated)
<a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a>            LD  C, fa_write | fa_create_always  ; Mode
<a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a>            MOSCALL ffs_fopen           ; Open the file
<a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a>            LD  DE, buffer          ; Location of data to write
<a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a>            LD  BC, 256             ; Number of bytes to write
<a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a>            MOSCALL ffs_write           ; Write the data
<a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a>            MOSCALL ffs_fclose          ; Close the file
<a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a>            RET
<a id="__codelineno-8-10" name="__codelineno-8-10" href="#__codelineno-8-10"></a>
<a id="__codelineno-8-11" name="__codelineno-8-11" href="#__codelineno-8-11"></a>filename:   DB  &quot;example.txt&quot;, 0        ; The file to read
<a id="__codelineno-8-12" name="__codelineno-8-12" href="#__codelineno-8-12"></a>
<a id="__codelineno-8-13" name="__codelineno-8-13" href="#__codelineno-8-13"></a>fil:        DS  FIL_SIZE            ; FIL buffer (defined in mos_api.inc)
<a id="__codelineno-8-14" name="__codelineno-8-14" href="#__codelineno-8-14"></a>buffer:     DS  256             ; Buffer containing data to write out
</code></pre></div>
<h3 id="0x84-ffs_flseek"><code>0x84</code>: ffs_flseek</h3>
<p>Move the read/write pointer in a file (Available from MOS 1.03)</p>
<p>NB this API is deprecated and kept for compatibility reasons.  You are advised to use the <a href="#0xa6-ffs_flseek_p"><code>ffs_flseek_p</code></a> API instead.  As this API requires a full 24-bit value to be provided in the <code>DE(U)</code> register it is not directly compatible with programs written to run in Z80 mode.</p>
<p>This API call can also be used to expand the file size, by moving the pointer to a location beyond the current end of the file.  It should be noted that the extra allocated disk space will not be cleared, so the data in the new space will be undefined.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Least significant 3 bytes of the offset from the start of the file</li>
<li><code>C</code>: Most significant byte of the offset (set to 0 for files &lt; 16MB)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p>
<h3 id="0x85-ffs_ftruncate"><code>0x85</code>: ffs_ftruncate</h3>
<p>Truncate a file to the current file pointer offset (Available from MOS 2.3.0)</p>
<p>To truncate to a specified size you will need to use <a href="#0xa6-ffs_flseek_p"><code>ffs_flseek_p</code></a> to move the file pointer to the desired location before calling <code>ffs_ftruncate</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x86-ffs_fsync"><code>0x86</code>: ffs_fsync</h3>
<p>Flushes cached information of a writing file</p>
<p>When writing to a file, file data may be cached in memory until the file is closed.  This function will flush the cache to the SD card, ensuring that all data has been written.  This can be useful to minimise the risks of data loss in the event of a power failure, SD card removal, or other unexpected shutdown.</p>
<p>Please note that MOS 3.0 does not currently cache writes to the SD card.  This API call is provided in case we do add caching in the future.  You may still wish to use this call to ensure that data is guaranteed to be written to the SD card in the event that a future version of MOS adds caching support.  Calling this API on systems that do not support caching will have no effect and be harmless.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<h3 id="0x87-ffs_fforward"><code>0x87</code>: ffs_fforward</h3>
<p>This API is not implemented, as the FatFS <code>f_forward</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>The documented purpose of the <code>f_forward</code> function is to read file data and forward it to a "data streaming device" (a callback function).  It is unlikely that this feature would be enabled in the future as we do not have a clear use-case for it, and similar functionality can be achieved by other means.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0x88-ffs_fexpand"><code>0x88</code>: ffs_fexpand</h3>
<p>This API is not implemented, as the FatFS <code>f_expand</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>The purpose of the <code>f_expand</code> function is to expand a file allocating a contiguous data area to the file.  Files can be expanded using the <a href="#0x84-ffs_flseek"><code>ffs_flseek</code></a> API, although this will not guarantee that the data area is contiguous.  It is unlikely that this API will be implemented in the future, as on an SD card there is little advantage to be had in allocating a contiguous data area for a file.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0x89-ffs_fgets"><code>0x89</code>: ffs_fgets</h3>
<p>Reads a string from a file</p>
<p>Reads characters into a buffer until a newline <code>\n</code> character is reached, the end of file encountered, or the buffer is filled.  The string read will be zero terminated.</p>
<p>It should be noted that this API does not return a status code in the <code>A</code> register.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a buffer to store the string in</li>
<li><code>BC(U)</code>: Buffer size</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>DE(U)</code>: Pointer to the target buffer, or NULL if an error occurred</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<h3 id="0x8a-ffs_fputc"><code>0x8A</code>: ffs_fputc</h3>
<p>Writes a single character to a file</p>
<p>It should be noted that this API does not return a status code in the <code>A</code> register.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>C</code>: Character to write</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>BC(U)</code>: Number of bytes written</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x8b-ffs_fputs"><code>0x8B</code>: ffs_fputs</h3>
<p>Writes a zero-terminated string to a file.  The termination character will not be written to the file.</p>
<p>It should be noted that this API does not return a status code in the <code>A</code> register.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a zero-terminated string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>BC(U)</code>: Number of bytes written</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<h3 id="0x8c-ffs_fprintf"><code>0x8C</code>: ffs_fprintf</h3>
<p>Whilst our configuration of FatFS does support the <code>f_printf</code> function, we do not currently support it in the MOS API.  This is because the function accepts a variable number of arguments, and it is not clear how this could be implemented in a way that is consistent with the rest of the APIs that MOS supports.</p>
<p>The <code>f_printf</code> function is made available via the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API call.  It can therefore be used from any (ADL mode) code that complies with the Zilog eZ80 C calling convention.  This API is not available in Z80 mode code.</p>
<h3 id="0x8d-ffs_ftell"><code>0x8D</code>: ffs_ftell</h3>
<p>Get the current read/write offset pointer of a file</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a 4-byte buffer to store the returned 32-bit offset in</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code> (<code>0</code> = Success, or <code>19</code> = Invalid parameter)</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<h3 id="0x8e-ffs_feof"><code>0x8E</code>: ffs_feof</h3>
<p>Detect end of file</p>
<p>Please note that whilst this API has been present since MOS 1.03 its implementation had an error which meant that it would return the value of the <code>L</code> register passed in as a parameter, rather than the correct value.  This was fixed in MOS 3.0.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: 1 if at the end of the file, otherwise 0</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x8f-ffs_fsize"><code>0x8F</code>: ffs_fsize</h3>
<p>Get the size of a file</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a 4-byte buffer to store the returned 32-bit file size in</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code> (<code>0</code> = Success, or <code>19</code> = Invalid parameter)</li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x90-ffs_ferror"><code>0x90</code>: ffs_ferror</h3>
<p>Tests for an error on a file</p>
<p>Returns a non-zero value if a hard error has returned, otherwise will return a status of <code>0</code> (OK).</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x91-ffs_dopen"><code>0x91</code>: ffs_dopen</h3>
<p>Open a directory (Available from MOS 2.2.0)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a blank <code>DIR</code> structure</li>
<li><code>DE(U)</code>: Pointer to a C (zero-terminated) directory path string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<h3 id="0x92-ffs_dclose"><code>0x92</code>: ffs_dclose</h3>
<p>Close a directory (Available from MOS 2.2.0)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>DIR</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x93-ffs_dread"><code>0x93</code>: ffs_dread</h3>
<p>Read next directory entry into a <code>FILINFO</code> data structure (Available from MOS 2.2.0)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>DIR</code> structure</li>
<li><code>DE(U)</code>: Pointer to a <code>FILINFO</code> structure</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<h3 id="0x94-ffs_dfindfirst"><code>0x94</code>: ffs_dfindfirst</h3>
<p>Searches a directory for a matching item</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a blank <code>DIR</code> struct</li>
<li><code>DE(U)</code>: Pointer to a blank <code>FILINFO</code> struct</li>
<li><code>BC(U)</code>: Pointer to directory path string</li>
<li><code>IX(U)</code>: Pointer to matching pattern string</li>
</ul>
<p>The directory path provided in <code>BC(U)</code> must be a fully resolved path, and the matching pattern in <code>IX(U)</code> should be a zero-terminated string.  The matching pattern can include wildcards, such as <code>*</code> and <code>?</code>, and will be used to match against the directory entries.  Subsequent entries can be found using <a href="#0x95-ffs_dfindnext"><code>ffs_dfindnext</code></a> passing in the same <code>DIR</code> structures as passed to this call, and the pattern string must also be preserved.</p>
<p>If a matching file is found, the <code>FILINFO</code> structure will be populated with information about the file.</p>
<p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code>, <code>IX(U)</code></p>
<h3 id="0x95-ffs_dfindnext"><code>0x95</code>: ffs_dfindnext</h3>
<p>Find next matching item in a directory</p>
<p>This API call is used to find the next matching item in a directory after a successful call to <a href="#0x94-ffs_dfindfirst"><code>ffs_dfindfirst</code></a>.  It will return the next matching file or directory in the same way as <code>ffs_dfindfirst</code>, but will not require the path and pattern strings to be passed in again.  Please note that whilst it is not a parameter for this API, the pattern string passed to <code>ffs_dfindfirst</code> must be preserved, as it will be used to match against the directory entries.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>DIR</code> structure, as set up by <a href="#0x94-ffs_dfindfirst"><code>ffs_dfindfirst</code></a></li>
<li><code>DE(U)</code>: Pointer to a <code>FILINFO</code> structure</li>
</ul>
<p>NB for completeness/convenience as the <a href="#0x94-ffs_dfindfirst"><code>ffs_dfindfirst</code></a> API is available as a C function via the <a href="#0x50-mos_getfunction"><code>mos_getfunction</code></a> API, this API is also available as a C function.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<h3 id="0x96-ffs_stat"><code>0x96</code>: ffs_stat</h3>
<p>Get file information (Available from MOS 1.03)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FILINFO</code> structure</li>
<li><code>DE(U)</code>: Pointer to a C (zero-terminated) filename string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>            LD  HL, filinfo             ; FILINFO buffer
<a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>            LD  DE, filename            ; Filename (0 terminated)
<a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>            MOSCALL ffs_stat
<a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a>            RET
<a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a>
<a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a>filename:   DB  &quot;example.txt&quot;, 0        ; The file to read
<a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a>
<a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a>filinfo:    DS  FILINFO_SIZE            ; FILINFO buffer (defined in mos_api.inc)
</code></pre></div>
<h3 id="0x97-ffs_unlink"><code>0x97</code>: ffs_unlink</h3>
<p>Removes ("unlinks") a file or sub-directory from the volume (Requires MOS 3.0 or above)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated file path string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code></p>
<h3 id="0x98-ffs_rename"><code>0x98</code>: ffs_rename</h3>
<p>Rename and/or move a file or sub-directory</p>
<p>This is a raw rename function that does not perform any path resolution, and does not support wildcards.  For more sophisticated behaviour you should use the <a href="#0x06-mos_ren"><code>mos_ren</code> API</a> instead.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated source file path string</li>
<li><code>DE(U)</code>: Pointer to a zero-terminated destination file path string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>
<h3 id="0x99-ffs_chmod"><code>0x99</code>: ffs_chmod</h3>
<p>This API is not implemented, as the FatFS <code>f_chmod</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>The purpose of the <code>f_chmod</code> function is to change the attributes set against a file or directory.  A future version of MOS may include support for this API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0x9a-ffs_utime"><code>0x9A</code>: ffs_utime</h3>
<p>This API is not implemented, as the FatFS <code>f_utime</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>The purpose of the <code>f_utime</code> function is to change the timestamp of a file or directory.  A future version of MOS may include support for this API.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0x9b-ffs_mkdir"><code>0x9B</code>: ffs_mkdir</h3>
<p>Creates a new directory</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated directory name string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<h3 id="0x9c-ffs_chdir"><code>0x9C</code>: ffs_chdir</h3>
<p>Change the current working directory</p>
<p>It is strongly recommended to use the <a href="#0x03-mos_cd"><code>mos_cd</code> API</a> API call instead of this one, as it will automatically resolve the path for you.  Using this API may result in MOS not understand the current working directory until a call to <code>mos_cd</code> is made or a version of the <a href="../Star-Commands/#cd"><code>CD</code> command</a> is run.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated directory name string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<h3 id="0x9d-ffs_chdrive"><code>0x9D</code>: ffs_chdrive</h3>
<p>This API is not implemented, as no Agon platform computer currently supports multiple drives.</p>
<h3 id="0x9e-ffs_getcwd"><code>0x9E</code>: ffs_getcwd</h3>
<p>Get the current working directory (Available from MOS 2.2.0)</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a buffer to store the directory path in</li>
<li><code>BC(U)</code>: Maximum length of the buffer</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<h3 id="0x9f-ffs_mount"><code>0x9F</code>: ffs_mount</h3>
<p>Mounts a volume/SD card</p>
<p>Whilst this API has documented parameters, as the current hardware configurations of Agon machines do not support multiple volumes or drives all of the parameters will be ignored.  They are documented here for completeness, and to allow for future expansion of the API in case a future Agon model is released that does support multiple SD cards.  For future compatibility you are advised to set all parameters to zero.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a blank FATFS <code>FATFS</code> structure (set to zero)</li>
<li><code>DE(U)</code>: Pointer to a zero-terminated volume path string (set to zero)</li>
<li><code>C</code>: Options byte (set to zero)</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<h3 id="0xa0-ffs_mkfs"><code>0xA0</code>: ffs_mkfs</h3>
<p>This API is not implemented, as the FatFS <code>f_mkfs</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0xa1-ffs_fdisk"><code>0xA1</code>: ffs_fdisk</h3>
<p>This API is not implemented, as the FatFS <code>f_fdisk</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>Returns</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0xa2-ffs_getfree"><code>0xA2</code>: ffs_getfree</h3>
<p>Get free space information on a volume</p>
<p>Please note that this call does not directly return the number of free bytes on the volume, but instead returns the number of free clusters and the size of each cluster.  The number of free bytes can be calculated by multiplying these two values together.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a path string (ideally caller should set this to zero)</li>
<li><code>DE(U)</code>: Pointer to a block of memory to store number of free clusters, 32-bit value</li>
<li><code>BC(U)</code>: Pointer to a block of memory to store cluster size, 32-bit value</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>Whilst this API will let you pass in a pointer to a path in the <code>HL(U)</code> register, you are recommended to set this to <code>0</code>, as the way that MOS uses FatFS means that the path is not needed, and the call will likely fail if any path other than an empty string is provided.  This API call also differs slightly from the underlying <code>f_getfree</code> function which does not directly return the cluster size, but instead returns a pointer to the <code>FATFS</code> structure for the volume, which will contain the cluster size.  As the <code>FATFS</code> structure is sensitive to the FatFS configuration and may change in future versions of MOS, we have chosen to return the cluster size directly instead.</p>
<h3 id="0xa3-ffs_getlabel"><code>0xA3</code>: ffs_getlabel</h3>
<p>Gets the label of a volume</p>
<ul>
<li><code>HL(U)</code>: Pointer to a path string (ideally caller should set this to zero)</li>
<li><code>DE(U)</code>: Pointer to a buffer to store the label in (for safety and future proofing this should be 23 bytes long)</li>
<li><code>BC(U)</code>: Pointer to a block of memory to store the 32-bit volume serial number</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<p>As with the <a href="#0xa2-ffs_getfree"><code>ffs_getfree</code> API</a> you should set the <code>HL(U)</code> parameter to <code>0</code>, as the way that MOS uses FatFS means that the path is not needed, and the call will likely fail if any path other than an empty string is provided.</p>
<p>It should be noted that this API call does not include a parameter for the size of the buffer to store the label in.  If your buffer is not large enough any memory after the label may be overwritten.  As of MOS 3.0 the maximum size of a volume label is 12 bytes (11 characters plus a zero terminator), however for future proofing you are advised to ensure your buffer is 23 bytes long.  The reason for this is that in the future we may enable support for discs using the exFAT filing system, which supports longer volume labels.</p>
<h3 id="0xa4-ffs_setlabel"><code>0xA4</code>: ffs_setlabel</h3>
<p>Sets the label of a volume</p>
<p>Please note that the label string must be a valid FAT volume label, which basically means that it must be 11 characters or less.  Setting a label to an empty string will remove the label.</p>
<p>Owing to how filing systems work some labels may be rejected, and characters may be converted to upper-case.  The <code>f_setlabel</code> function that this API calls will attempt to look for a "drive prefix" in the label to specify a drive number, but owing to how we use FatFS in MOS this will not work.  As such you should not include a drive prefix in the label.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a zero-terminated volume label string</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>FRESULT</code></li>
</ul>
<h3 id="0xa5-ffs_setcp"><code>0xA5</code>: ffs_setcp</h3>
<p>This API is not implemented, as the FatFS <code>f_setcp</code> function is not supported by the current configuration of the FatFS library used in MOS.</p>
<p>The purpose of <code>f_setcp</code> is to set the active code page for file paths, and this is not available as our FatFS configuration is restricted to a single code page.  Adding this feature would greatly expand the size of FatFS, and consequently also MOS, which would almost certainly exceed the available flash space on the eZ80.  As such it is highly unlikely that this API will be implemented in the future.</p>
<p>Returns:</p>
<ul>
<li><code>A</code>: <code>23</code> (Not implemented)</li>
</ul>
<h3 id="0xa6-ffs_flseek_p"><code>0xA6</code>: ffs_flseek_p</h3>
<p>Move the read/write offset pointer in a file</p>
<p>This API can be used to expand the size of a file, although you should note that the file data in the expanded part will be undefined.</p>
<p>Whilst the <a href="#0x84-ffs_flseek"><code>ffs_flseek</code></a> API can essentially perform the same function as this API, this is the preferred API to use for moving the current read/write pointer offset within a file.  As it accepts a pointer to the 32-bit offset value, it is compatible with both Z80-mode and ADL-mode code.</p>
<p>Parameters:</p>
<ul>
<li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li>
<li><code>DE(U)</code>: Pointer to a 32-bit value for the desired new offset from the start of the file</li>
</ul>
<p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>
<p>Returns:</p>
<ul>
<li><code>A</code>: Status code</li>
</ul>
<hr />
<h2 id="status-codes">Status Codes</h2>
<p>Many MOS API calls will return a status code in the <code>A</code> register.  In general these follow a consistent set of result values, with a few exceptions which are documented against the individual API calls.  Programs and commands will also return a status code when they complete.  If you are using MOS 3, the status code value can be captured in a system variable if the command or program is run using the <a href="../Star-Commands/#try"><code>try</code> command</a>.</p>
<p>API calls that are documented above as returning an <code>FRESULT</code> value are returning a status code from the FatFS library.  These directly equate to status codes 0-19 in the table below.</p>
<p>Status codes can be translated into a human-readable string using the <a href="#0x0f-mos_geterror"><code>mos_getError</code></a> API call.</p>
<p>The possible status codes are as follows:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Error message</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>OK</td>
<td>Call succeeded (NB this will not be displayed when running a program or star command)</td>
</tr>
<tr>
<td>1</td>
<td>Error accessing SD card</td>
<td>An error has occurred when trying to access the SD card</td>
</tr>
<tr>
<td>2</td>
<td>Internal error</td>
<td>An internal error has occurred.  Generally, if possible, a more specific error will be used</td>
</tr>
<tr>
<td>3</td>
<td>SD card failure</td>
<td>The SD card has failed</td>
</tr>
<tr>
<td>4</td>
<td>Could not find file</td>
<td>The file could not be found</td>
</tr>
<tr>
<td>5</td>
<td>Could not find path</td>
<td>The path could not be found</td>
</tr>
<tr>
<td>6</td>
<td>Invalid path name</td>
<td>The path name is invalid</td>
</tr>
<tr>
<td>7</td>
<td>Access denied or directory full</td>
<td>A file could not be saved to a directory either because of an access error or too many files in the directory</td>
</tr>
<tr>
<td>8</td>
<td>Access denied</td>
<td>A file or directory cannot be accessed because it is not readable</td>
</tr>
<tr>
<td>9</td>
<td>Invalid file/directory object</td>
<td>This is an internal filing system error</td>
</tr>
<tr>
<td>10</td>
<td>SD card is write protected</td>
<td>The SD card cannot be written to as it is write protected</td>
</tr>
<tr>
<td>11</td>
<td>Logical drive number is invalid</td>
<td>This is an internal filing system error, which should not occur</td>
</tr>
<tr>
<td>12</td>
<td>Volume has no work area</td>
<td>This is an internal filing system error</td>
</tr>
<tr>
<td>13</td>
<td>No valid FAT volume</td>
<td>The SD card does not contain a FAT format volume your Agon can understand</td>
</tr>
<tr>
<td>14</td>
<td>Error occurred during mkfs</td>
<td>This is an internal filing system error</td>
</tr>
<tr>
<td>15</td>
<td>Volume timeout</td>
<td>A problem has occured attempting to access your SD card</td>
</tr>
<tr>
<td>16</td>
<td>Volume locked</td>
<td>The FAT volume cannot be written to</td>
</tr>
<tr>
<td>17</td>
<td>LFN working buffer could not be allocated</td>
<td>This is an internal filing system error</td>
</tr>
<tr>
<td>18</td>
<td>Too many open files</td>
<td>Occurs when too many separate files have been opened</td>
</tr>
<tr>
<td>19</td>
<td>Invalid parameter</td>
<td>A parameter for the command or API is incorrect</td>
</tr>
<tr>
<td>20</td>
<td>Invalid command</td>
<td>The command was not recognised or found on disc</td>
</tr>
<tr>
<td>21</td>
<td>Invalid executable</td>
<td>An executable program does not have a valid header</td>
</tr>
<tr>
<td>22</td>
<td>Out of memory</td>
<td>Either MOS has run out of internal memory, or a buffer provided to an API was not large enough</td>
</tr>
<tr>
<td>23</td>
<td>Not implemented</td>
<td>The API call is not implemented in this version of MOS</td>
</tr>
<tr>
<td>24</td>
<td>Load overlaps system area</td>
<td>File load prevented to stop overlapping system memory</td>
</tr>
<tr>
<td>25</td>
<td>Bad string</td>
<td>A bad or incomplete string has been encountered</td>
</tr>
<tr>
<td>26</td>
<td>Too deep</td>
<td>Too many nested commands have been detected<br>This is usually caused by a faulty <a href="../System-Variables/#command-aliases">alias</a> definition including <a href="../System-Variables/#file-type-variables">file load/run types</a></td>
</tr>
</tbody>
</table>
<p>Please note that Quark MOS 1.04 will only return status codes 0-21.  The MOS 2.x release series added status codes 22-25, and MOS 3.0 added status code 26.  </p>
<h2 id="sysvars">System State Information (SysVars)</h2>
<p>The MOS API command <a href="#0x08-mos_sysvars">mos_sysvars</a> returns a pointer to the base of the MOS SysVars (system state variables/information) area in IXU as a 24-bit pointer.  These are different from <a href="../System-Variables/">System Variables</a> which can be used in commands and scripts, so these these internal MOS system state variables are often simply referred to as sysvars.</p>
<p>The following sysvars are available in <a href="#rst">mos_api.inc</a>:</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>; SysVars (System State Information) indexes for api_sysvars
<a id="__codelineno-10-2" name="__codelineno-10-2" href="#__codelineno-10-2"></a>; Index into _sysvars in globals.asm
<a id="__codelineno-10-3" name="__codelineno-10-3" href="#__codelineno-10-3"></a>;
<a id="__codelineno-10-4" name="__codelineno-10-4" href="#__codelineno-10-4"></a>sysvar_time:            EQU 00h ; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
<a id="__codelineno-10-5" name="__codelineno-10-5" href="#__codelineno-10-5"></a>sysvar_vpd_pflags:      EQU 04h ; 1: Flags to indicate completion of VDP commands
<a id="__codelineno-10-6" name="__codelineno-10-6" href="#__codelineno-10-6"></a>sysvar_keyascii:        EQU 05h ; 1: ASCII keycode, or 0 if no key is pressed
<a id="__codelineno-10-7" name="__codelineno-10-7" href="#__codelineno-10-7"></a>sysvar_keymods:         EQU 06h ; 1: Keycode modifiers
<a id="__codelineno-10-8" name="__codelineno-10-8" href="#__codelineno-10-8"></a>sysvar_cursorX:         EQU 07h ; 1: Cursor X position
<a id="__codelineno-10-9" name="__codelineno-10-9" href="#__codelineno-10-9"></a>sysvar_cursorY:         EQU 08h ; 1: Cursor Y position
<a id="__codelineno-10-10" name="__codelineno-10-10" href="#__codelineno-10-10"></a>sysvar_scrchar:         EQU 09h ; 1: Character read from screen
<a id="__codelineno-10-11" name="__codelineno-10-11" href="#__codelineno-10-11"></a>sysvar_scrpixel:        EQU 0Ah ; 3: Pixel data read from screen (R,B,G)
<a id="__codelineno-10-12" name="__codelineno-10-12" href="#__codelineno-10-12"></a>sysvar_audioChannel:    EQU 0Dh ; 1: Audio channel
<a id="__codelineno-10-13" name="__codelineno-10-13" href="#__codelineno-10-13"></a>sysvar_audioSuccess:    EQU 0Eh ; 1: Audio channel note queued (0 = no, 1 = yes)
<a id="__codelineno-10-14" name="__codelineno-10-14" href="#__codelineno-10-14"></a>sysvar_scrWidth:        EQU 0Fh ; 2: Screen width in pixels
<a id="__codelineno-10-15" name="__codelineno-10-15" href="#__codelineno-10-15"></a>sysvar_scrHeight:       EQU 11h ; 2: Screen height in pixels
<a id="__codelineno-10-16" name="__codelineno-10-16" href="#__codelineno-10-16"></a>sysvar_scrCols:         EQU 13h ; 1: Screen columns in characters
<a id="__codelineno-10-17" name="__codelineno-10-17" href="#__codelineno-10-17"></a>sysvar_scrRows:         EQU 14h ; 1: Screen rows in characters
<a id="__codelineno-10-18" name="__codelineno-10-18" href="#__codelineno-10-18"></a>sysvar_scrColours:      EQU 15h ; 1: Number of colours displayed
<a id="__codelineno-10-19" name="__codelineno-10-19" href="#__codelineno-10-19"></a>sysvar_scrpixelIndex:   EQU 16h ; 1: Index of pixel data read from screen
<a id="__codelineno-10-20" name="__codelineno-10-20" href="#__codelineno-10-20"></a>sysvar_vkeycode:        EQU 17h ; 1: Virtual key code from FabGL
<a id="__codelineno-10-21" name="__codelineno-10-21" href="#__codelineno-10-21"></a>sysvar_vkeydown         EQU 18h ; 1: Virtual key state from FabGL (0=up, 1=down)
<a id="__codelineno-10-22" name="__codelineno-10-22" href="#__codelineno-10-22"></a>sysvar_vkeycount:       EQU 19h ; 1: Incremented every time a key packet is received
<a id="__codelineno-10-23" name="__codelineno-10-23" href="#__codelineno-10-23"></a>sysvar_rtc:             EQU 1Ah ; 8: Real time clock data
<a id="__codelineno-10-24" name="__codelineno-10-24" href="#__codelineno-10-24"></a>sysvar_keydelay:        EQU 22h ; 2: Keyboard repeat delay
<a id="__codelineno-10-25" name="__codelineno-10-25" href="#__codelineno-10-25"></a>sysvar_keyrate:         EQU 24h ; 2: Keyboard repeat rate
<a id="__codelineno-10-26" name="__codelineno-10-26" href="#__codelineno-10-26"></a>sysvar_keyled:          EQU 26h ; 1: Keyboard LED status
<a id="__codelineno-10-27" name="__codelineno-10-27" href="#__codelineno-10-27"></a>sysvar_scrMode:         EQU 27h ; 1: Screen mode (from MOS 1.04)
<a id="__codelineno-10-28" name="__codelineno-10-28" href="#__codelineno-10-28"></a>sysvar_rtc_enable:      EQU 28h ; 1: RTC enable status (from MOS 2.0.0)
<a id="__codelineno-10-29" name="__codelineno-10-29" href="#__codelineno-10-29"></a>sysvar_mouseX:          EQU 29h ; 2: Mouse X position
<a id="__codelineno-10-30" name="__codelineno-10-30" href="#__codelineno-10-30"></a>sysvar_mouseY:          EQU 2Bh ; 2: Mouse Y position
<a id="__codelineno-10-31" name="__codelineno-10-31" href="#__codelineno-10-31"></a>sysvar_mouseButtons:    EQU 2Dh ; 1: Mouse left+right+middle buttons (bits 0-2, 0=up, 1=down)
<a id="__codelineno-10-32" name="__codelineno-10-32" href="#__codelineno-10-32"></a>sysvar_mouseWheel:      EQU 2Eh ; 1: Mouse wheel delta
<a id="__codelineno-10-33" name="__codelineno-10-33" href="#__codelineno-10-33"></a>sysvar_mouseXDelta:     EQU 2Fh ; 2: Mouse X delta
<a id="__codelineno-10-34" name="__codelineno-10-34" href="#__codelineno-10-34"></a>sysvar_mouseYDelta:     EQU 31h ; 2: Mouse Y delta
</code></pre></div>
<p>Example: Reading a virtual keycode in ADL mode (24-bit):
<div class="highlight"><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>        MOSCALL mos_getkey
<a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a>        LD  A, (IX + sysvar_vkeycode)   ; Load A with the virtual keycode from FabGL
</code></pre></div></p>
<p>Example: Reading a virtual keycode in Z80 mode (16-bit):
<div class="highlight"><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>        MOSCALL mos_getkey
<a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a>        LD.LIL  A, (IX + sysvar_vkeycode)   ; Load A with the virtual keycode from FabGL
</code></pre></div></p>
<h3 id="sysvar_rtc">Real Time Clock</h3>
<p>For efficiency, the real-time clock data in the sysvars is stored in a packed format, using subsets of bits within the 8 bytes of the <code>sysvar_rtc</code> data.  An API is provided from MOS 3 onwards to allow for this to be unpacked <a href="#0x23-mos_unpackrtc">mos_unpackrtc</a> into a buffer in a friendlier, more easy to use format.  MOS uses the following C function to unpack the RTC data into a <code>vdp_time_t</code> object:
<div class="highlight"><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">rtc_unpack</span><span class="p">(</span><span class="n">UINT8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sysvar_rtc</span><span class="p">,</span><span class="w"> </span><span class="n">vdp_time_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a><span class="w">    </span><span class="n">UINT32</span><span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">UINT32</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">sysvar_rtc</span><span class="p">;</span>
<a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a>
<a id="__codelineno-13-4" name="__codelineno-13-4" href="#__codelineno-13-4"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w">      </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0000000F</span><span class="p">);</span><span class="w">       </span><span class="c1">// uint32_t month : 4;      00000000 00000000 00000000 0000xxxx : 00 00 00 0F &gt;&gt; 0</span>
<a id="__codelineno-13-5" name="__codelineno-13-5" href="#__codelineno-13-5"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w">        </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x000001F0</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">  </span><span class="c1">// uint32_t day : 5;        00000000 00000000 0000000x xxxx0000 : 00 00 01 F0 &gt;&gt; 4</span>
<a id="__codelineno-13-6" name="__codelineno-13-6" href="#__codelineno-13-6"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">dayOfWeek</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00000E00</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">  </span><span class="c1">// uint32_t dayOfWeek : 3;  00000000 00000000 0000xxx0 00000000 : 00 00 0E 00 &gt;&gt; 9</span>
<a id="__codelineno-13-7" name="__codelineno-13-7" href="#__codelineno-13-7"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">dayOfYear</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x001FF000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="c1">// uint32_t dayOfYear : 9;  00000000 000xxxxx xxxx0000 00000000 : 00 1F F0 00 &gt;&gt; 12</span>
<a id="__codelineno-13-8" name="__codelineno-13-8" href="#__codelineno-13-8"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">hour</span><span class="w"> </span><span class="o">=</span><span class="w">       </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x03E00000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span><span class="w"> </span><span class="c1">// uint32_t hour : 5;       000000xx xxx00000 00000000 00000000 : 03 E0 00 00 &gt;&gt; 21</span>
<a id="__codelineno-13-9" name="__codelineno-13-9" href="#__codelineno-13-9"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">minute</span><span class="w"> </span><span class="o">=</span><span class="w">     </span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFC000000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">26</span><span class="p">;</span><span class="w"> </span><span class="c1">// uint32_t minute : 6;     xxxxxx00 00000000 00000000 00000000 : FC 00 00 00 &gt;&gt; 26</span>
<a id="__codelineno-13-10" name="__codelineno-13-10" href="#__codelineno-13-10"></a>
<a id="__codelineno-13-11" name="__codelineno-13-11" href="#__codelineno-13-11"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sysvar_rtc</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<a id="__codelineno-13-12" name="__codelineno-13-12" href="#__codelineno-13-12"></a><span class="w">    </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">sysvar_rtc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1980</span><span class="p">;</span>
<a id="__codelineno-13-13" name="__codelineno-13-13" href="#__codelineno-13-13"></a><span class="p">}</span>
</code></pre></div></p>
<p>This real-time clock data is also available to programs, scripts, and the command line via <a href="../System-Variables/#time-and-date">system variables</a>.</p>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.sections", "navigation.expand", "navigation.instant", "navigation.top", "search.suggest", "search.highlight", "content.tabs.link", "content.code.annotate", "content.code.copy", "content.footnote.tooltips", "content.action.edit"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>