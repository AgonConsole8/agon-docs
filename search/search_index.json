{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the community Agon Platform documentation","text":"<p>This is the community-driven documentation for the Agon Platform, covering the Agon Light, Olimex Agon Light 2, and the Agon Console8 hobbyist computers.  It is intended to be a comprehensive guide to the Agon Platform, including Agon MOS and VDP firmware, and the hardware and software that it supports.  It is intended to provide a guide to all of the features of the Agon platform with guidance on how to program for it, with information on the various features provided by different versions of the firmware.</p> <p>This site is intended to supercede the official documentation, and to provide a more comprehensive and up-to-date guide to the Agon Platform.  It is intended to be a living document, and to be updated as new features are added to the platform.</p> <p>The original documentation for Quark firmware can be found here. This community documentation was started because GitHub's wiki system does not allow easy contributions by users, and the original documentation contains some errors and omissions.  We don't use the wiki here, but just markdown files which are also automatically generated into a website.</p>"},{"location":"#want-to-contribute","title":"Want to contribute?","text":"<p>Great, please go to the github repository and create a Pull Request with your changes.</p>"},{"location":"#what-is-the-agon-light-and-what-is-the-agon-console8","title":"What is the Agon Light, and what is the Agon Console8","text":"<p>The Agon Light is a modern, fully open-source, 8-bit microcomputer and microcontroller in one small, low-cost board, designed by Bernado Kastrup aka The Byte Attic. As a computer, it is a standalone device that requires no host PC: it puts out its own video (VGA), audio (2 identical mono channels), accepts a PS/2 keyboard and has its own mass-storage in the form of a \u00b5SD card.  The Olimex Agon Light 2 and the Agon Light Origins edition are variations on the original Agon Light design.</p> <p>The Agon Console8 is a version of the Agon Light that also includes two Atari-compatible joystick ports, and a PS/2 mouse port, and a stylish case.  It was also designed by Bernado Kastrup aka The Byte Attic, and is manufactured by Heber Ltd.</p> <p>The Agon Light, Olimex Agon Light 2, and the Agon Console8 are all fully compatible with each other.  Software written for one will run on the other, and the same firmware can be used on both.  In this documentation, generally, the term \"Agon Light\" is used to refer to all variations.</p> <p>The main CPU is an eZ80F92, a modern Zilog Z80 microcontroller that is fully backwards compatible with the Z80. As well as running in a traditional 8-bit mode with a 64K address space, it can run in 24-bit mode with a 16MB address space, and is also capable of running in a hybrid mode with a mixture of 24-bit and 8-bit code.</p> <p>The eZ80F92 integrates a number of standard peripherals, including a UART, and hardware timers.</p> <p>There is a second CPU dedicated to handling video, sound, and keyboard, an ESP32-Pico-D4. This co-processor is linked to the eZ80F92 via a UART (a high speed serial communications link), and acts as a graphics terminal.</p>"},{"location":"#what-is-the-agon-platform-firmware","title":"What is the Agon Platform Firmware","text":"<p>The Agon Platform firmware is the software that runs on the Agon Light, Olimex Agon Light 2, and the Agon Console8. It is responsible for managing the hardware, providing a programming environment, and running applications.  It consists of three main components:</p> <ul> <li>MOS: Machine Operating System</li> <li>VDP: Visual Display Processor</li> <li>BBC BASIC for Agon: A specially adapted port of R.T.Russell's excellent BASIC interpreter</li> </ul>"},{"location":"#what-is-agon-quark","title":"What is Agon Quark?","text":"<p>Agon Quark is the name of the original firmware for the Agon Light, and is now deprecated.  The Agon Platform firmware versions are the latest available for your Agon platform computer.</p>"},{"location":"#how-can-i-find-out-more","title":"How can I find out more?","text":"<p>The following documents provide some more information</p> <ul> <li>Agon Platform theory of operation</li> <li>External documentation</li> <li>Using GPIO</li> <li>The Agon Projects github</li> <li>Third party projects</li> <li>FAQ</li> </ul>"},{"location":"#where-can-i-buy-one","title":"Where can I buy one?","text":"<ul> <li>Mouser</li> <li>The Pi Hut</li> <li>Olimex Ltd</li> <li>DigiKey</li> <li>PCBWay</li> <li>Agon Light Australia</li> <li>Agon Light Store (UK)</li> <li>Agon Console8 from Heber (UK)</li> </ul>"},{"location":"BBC-BASIC-for-Agon/","title":"What is BBC BASIC for Agon?","text":"<p>The original version of BBC BASIC was written by Sophie Wilson at Acorn in 1981 for the BBC Micro range of computers, and was designed to support the UK Computer Literacy Project. R.T.Russell was involved in the specification of BBC Basic, and wrote his own Z80 version that was subsequently ported to a number of Z80 based machines. I highly recommend reading his account of this on his website for more details.</p> <p>As an aside, R.T.Russell still supports BBC Basic, and has ported it for a number of modern platforms, including Android, Windows, and SDL, which are available from his website here.</p> <p>BBC BASIC for Agon is a port of his BBC BASIC for Z80, which is now open source, with a number of modifications to make it run on Agon.</p> <p>Please note that the information in this file is currently out of date.  The original version of BASIC described here is based on Dean Belfield's Agon port of R.T.Russell's original Z80 BBC BASIC.  This version is broadly the same as Acorn's BBC BASIC version 4 for the BBC Master series of computers, but includes an inbuilt Z80 Assembler instead of 6502.  Since that time, Dean Belfield made a new version based on that work which makes use of the Agon's eZ80 processor, allowing access to all 512KB of RAM, compared to the 64KB of the original Z80 version, and extending the Assembler to support the new eZ80 opcodes.  Richard Russell also revisited his original Z80 version of BASIC and extended it to support most features of Acorn's BBC BASIC V, and Dean Belfield has since ported this to the Agon as well.  The BASIC V for Agon currently only supports Z80 mode.</p>"},{"location":"BBC-BASIC-for-Agon/#implementation-on-the-agon-light","title":"Implementation on the Agon Light","text":"<p>BBC BASIC for Z80 runs in Z80 mode, that is within a 64K segment. The interpreter takes around 16K of RAM, leaving around 48K available for user programs and data.</p> <p>If you are not familiar with the BASIC programming language, or need a refresher on BBC BASIC, please refer to the official BBC BASIC for Agon documentation here.</p> <p>(Please note that this documentation is also slightly outdated and contains some inaccuracies.  For example it has incorrect information about PLOT commands.  At some point we may merge the Agon BBC BASIC documentation in with the community documentation site.)</p> <p>To run, load into memory and run as follows from the MOS command prompt:</p> <pre><code>LOAD bbcbasic.bin\nRUN\n</code></pre> <p>It is possible to automatically <code>CHAIN</code> (load and run) a BBC BASIC program by passing the filename as a parameter: <pre><code>LOAD bbcbasic.bin\nRUN . /path/to/file.bas\n</code></pre></p> <p>Note that passing a . as the first parameter of RUN is informing MOS to use the default value there (&amp;40000)</p> <p>BBC BASIC needs a full 64K segment, so cannot be run from the MOS folder as a star command.</p> <p>If you are running MOS 2.2.0 you can load and run BBC BASIC from the MOS command prompt using:</p> <pre><code>bbcbasic\n</code></pre> <p>This assumes that your copy of BASIC is called <code>bbcbasic.bin</code> and is either in the root of the SD card, or in the <code>bin</code> folder.</p> <p>Automatically \"chaining\" a BBC BASIC program can be done by passing the filename as a parameter:</p> <pre><code>bbcbasic /path/to/file.bas\n</code></pre>"},{"location":"BBC-BASIC-for-Agon/#summary-of-agon-light-specific-changes","title":"Summary of Agon Light Specific Changes","text":""},{"location":"BBC-BASIC-for-Agon/#star-commands","title":"Star Commands","text":"<p>The following * commands are supported</p>"},{"location":"BBC-BASIC-for-Agon/#bye","title":"BYE","text":"<p>Syntax: <code>*BYE</code></p> <p>Exit BASIC and return to MOS.</p>"},{"location":"BBC-BASIC-for-Agon/#edit","title":"EDIT","text":"<p>Syntax: <code>*EDIT linenum</code></p> <p>Pull a line into the editor for editing.</p>"},{"location":"BBC-BASIC-for-Agon/#fx","title":"FX","text":"<p>Syntax: <code>*FX osbyte, params</code></p> <p>Execute an OSBYTE command.</p> <p>The only OSBYTE commands supported at the moment are:</p> <ul> <li>19: Wait for vertical blank retrace</li> </ul> <p>And from MOS 1.03 or above</p> <ul> <li>11: Set keyboard repeat delay in ms (250, 500, 750 or 1000)</li> <li>12: Set keyboard repeat rate ins ms (between 33 and 500ms)</li> <li>118: Set keyboard LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock) - does not currently change status, just the LED</li> </ul>"},{"location":"BBC-BASIC-for-Agon/#version","title":"VERSION","text":"<p>Syntax: <code>*VERSION</code></p> <p>Display the current version of BBC BASIC</p>"},{"location":"BBC-BASIC-for-Agon/#mos-commands","title":"MOS commands","text":"<p>In addition, any of the MOS commands can be called by prefixing them with a *</p> <p>See the MOS documentation for more details</p>"},{"location":"BBC-BASIC-for-Agon/#basic","title":"BASIC","text":"<p>The following statements are not currently implemented:</p> <ul> <li>ENVELOPE</li> <li>ADVAL</li> </ul> <p>The following statements differ from the BBC Basic standard:</p>"},{"location":"BBC-BASIC-for-Agon/#rem","title":"REM","text":"<p>REM does not tokenise any statements within comments. This is to bring it inline with string literals for internationalisation.</p>"},{"location":"BBC-BASIC-for-Agon/#load","title":"LOAD","text":""},{"location":"BBC-BASIC-for-Agon/#save","title":"SAVE","text":"<p>The following file extensions are supported:</p> <ul> <li><code>.BBC</code>: LOAD and SAVE in BBC BASIC for Z80 tokenised format</li> <li><code>.BAS</code>: LOAD and SAVE in plain text format (also <code>.TXT</code> and <code>.ASC</code>)</li> </ul> <p>If a file extension is omitted, \".BBC\" is assumed.</p>"},{"location":"BBC-BASIC-for-Agon/#mode","title":"MODE","text":"<p>The modes differ from those on the BBC series of microcomputers. The full list can be found here in the VDP documentation.</p>"},{"location":"BBC-BASIC-for-Agon/#colour","title":"COLOUR","text":"<p>Syntax: <code>COLOUR c</code></p> <p>Change the the current text output colour</p> <ul> <li>If c is between 0 and 63, the foreground text colour will be set</li> <li>If c is between 128 and 191, the background text colour will be set</li> </ul> <p>Syntax: <code>COLOUR l,p</code></p> <p>Set the logical colour l to the physical colour p</p> <p>Syntax: <code>COLOUR l,r,g,b</code></p>"},{"location":"BBC-BASIC-for-Agon/#gcol","title":"GCOL","text":"<p>Syntax: <code>GCOL mode,c</code></p> <p>Set the graphics colour <code>c</code>, and the \"mode\" of graphics paint operations.</p> <p>Colour values are interpreted as per the COLOUR command, i.e. values below 128 will set the foreground colour, and values above 128 set the background colour.</p> <p>Versions of the VDP earlier than 1.04 only supported mode 0, with all painting operations just setting on-screen pixels.</p> <p>VDP 1.04 introduced partial support for mode 4, which inverts the pixel.  Mode 4 would only apply to straight line drawing operations.  The mode would affect all applicable plot operations.</p> <p>As of Console8 VDP 2.6.0, all 8 of the basic modes are supported for all currently supported plot operations.  Separate plot modes are now tracked for foreground and background colours, and the mode is applied to the graphics operation.</p> <p>The full array of available modes is as follows:</p> Mode Effect 0 Set on-screen pixel to target colour value 1 OR value with the on-screen pixel 2 AND value with the on-screen pixel 3 EOR value with the on-screen pixel 4 Invert the on-screen pixel 5 No operation 6 AND the inverse of the specified colour with the on-screen pixel 7 OR the inverse of the specified colour with the on-screen pixel"},{"location":"BBC-BASIC-for-Agon/#point","title":"POINT","text":"<p>Syntax: <code>POINT(x,y)</code></p> <p>This returns the physical colour index of the colour at pixel position (x, y)</p>"},{"location":"BBC-BASIC-for-Agon/#plot","title":"PLOT","text":"<p>Syntax: <code>PLOT mode,x,y</code></p> <p>For information on the various PLOT modes, please see the VDP PLOT command documentation</p>"},{"location":"BBC-BASIC-for-Agon/#get","title":"GET$","text":"<p>Syntax: <code>GET$(x,y)</code></p> <p>Returns the ASCII character at position x,y</p>"},{"location":"BBC-BASIC-for-Agon/#get_1","title":"GET","text":"<p>Syntax: <code>GET(x,y)</code> (from BBC BASIC 1.05)</p> <p>As GET$, but returns the ASCII code of the character at position x, y</p> <p>Syntax: <code>GET(p)</code></p> <p>Read and return the value of Z80 port p</p>"},{"location":"BBC-BASIC-for-Agon/#sound","title":"SOUND","text":"<p>Syntax: <code>SOUND channel,volume,pitch,duration</code></p> <p>Play a sound through the Agon Light buzzer and audio output jack</p> <ul> <li><code>Channel</code>: 0 to 2</li> <li><code>Volume</code>: 0 (off) to -15 (full volume)</li> <li><code>Pitch</code>: 0 to 255</li> <li><code>Duration</code>: -1 to 254 (duration in 20ths of a second, -1 = play forever)</li> </ul>"},{"location":"BBC-BASIC-for-Agon/#time","title":"TIME$","text":"<p>Access the ESP32 RTC data</p> <p>Example:</p> <pre><code>  10 REM CLOCK\n  20 :\n  30 CLS\n  40 PRINT TAB(2,2); TIME$\n  50 GOTO 40\n</code></pre> <p>NB: This is a virtual string variable; at the moment only getting the time works. Setting is not yet implemented.</p>"},{"location":"BBC-BASIC-for-Agon/#vdu","title":"VDU","text":"<p>The VDU commands on the Agon Light will be familiar to those who have coded on Acorn machines. Please read the [[VDP]] documentation for details on what VDU commands are supported.</p>"},{"location":"BBC-BASIC-for-Agon/#inline-assembler","title":"Inline Assembler","text":"<p>BBC BASIC for Z80, like its 6502 counterpart, includes an inline assembler. For instructions on usage, please refer to the original documentation.</p> <p>In addition to the standard set of Z80 instructions, the following eZ80 instructions have been added</p> <ul> <li><code>MLT</code></li> </ul> <p>The assembler will only compile 8-bit Z80 code and there are currently no plans for extending the instruction set much further in this version.</p>"},{"location":"BBC-BASIC-for-Agon/#integration-with-mos","title":"Integration with MOS","text":"<p>For the most part, the MOS is transparent to BASIC; most of the operations via the MOS and VDP are accessed via normal BBC BASIC statements, with the following exceptions:</p>"},{"location":"BBC-BASIC-for-Agon/#accessing-the-mos-sysvars","title":"Accessing the MOS SysVars","text":"<p>MOS has a small area of memory for system state variables (sysvars) which lives in an area of RAM outside of the 64K segment in which BBC BASIC runs. To access these, you will need to do an OSBYTE call</p> <p>Example: Print the least significant byte of the internal clock counter <pre><code>10 L%=&amp;00 : REM The sysvar to fetch\n20 A%=&amp;A0 : REM The OSBYTE number\n30 PRINT USR(&amp;FFF4)\n</code></pre></p> <p>Documentation for the full list of sysvars can be found in the MOS API documentation.</p>"},{"location":"BBC-BASIC-for-Agon/#running-star-commands-with-variables","title":"Running star commands with variables","text":"<p>The star command parser does not use the same evaluator as BBC BASIC, so whilst commands can be run in BASIC, variable names are treated as literals.</p> <p>Example: This will not work <pre><code>10 INPUT \"Filename\";f$\n20 INPUT \"Load Address\";addr%\n30 *LOAD f$ addr%\n</code></pre></p> <p>To do this correctly, you must call the star command indirectly using the OSCLI command</p> <p>Example: This will work <pre><code>30 OSCLI(\"LOAD \" + f$ + \" \" + STR$(addr%))\n</code></pre></p>"},{"location":"External-Documentation/","title":"Agon","text":"<ul> <li>Byte Attic: The Agon Light</li> <li>Break Into Program: Agon</li> </ul>"},{"location":"External-Documentation/#bbc-basic","title":"BBC BASIC","text":"<ul> <li>BBC BASIC for Agon Manual</li> </ul>"},{"location":"External-Documentation/#libraries","title":"Libraries","text":"<ul> <li>FabGL</li> <li>FatFS</li> </ul>"},{"location":"External-Documentation/#zilog","title":"Zilog","text":"<ul> <li>eZ80F92 Documentation<ul> <li>eZ80 CPU</li> <li>Specification</li> <li>Calling C Functions from Assembly and Vice Versa</li> <li>ZDSII User Manual</li> </ul> </li> </ul>"},{"location":"FAQ/","title":"Agon Frequently Asked Questions","text":"<p>The following questions (and answers) on using the Agon platform are below:</p> <ul> <li>Are these community documents available offline or in a different format?</li> <li>Is the Agon open source?</li> <li>What else do I need to buy?</li> <li>Does Agon support CP/M?</li> <li>Is there a template available for the SD card, to get me started quickly?</li> <li>What kind of SD card should I use?</li> <li>What size SD card should I buy?</li> <li>How should I format the SD card initially?</li> <li>Will my Agon boot directly into BBC BASIC or will I have to download the language onto an SD card?</li> <li>How should I power the Agon?</li> <li>How can I update the Agon?</li> <li>Where can I find the latest Agon firmware(s) to download?</li> <li>Quark, Console8, or Agon Platform firmware??</li> <li>Which firmware do you currently recommend using on my Agon?</li> <li>Can I switch between the Quark firmware, Console8, and Agon Platform firmware?</li> <li>What is the function of Agon's jumpers and what is their recommended position?<ul> <li>The ESP jumper</li> <li>The UART jumper</li> <li>The Buzzer jumper</li> </ul> </li> <li>Do I need to buy the Zilog SMART cable to update my Agon?</li> <li>I still would like to buy a Zilog SMART cable. Which one should I get?</li> <li>Can I go back to an earlier firmware version / downgrade?</li> <li>I don't have a Console8, can I still use the Console8 firmware?</li> <li>How should I connect the Agon to my PC for programming the VDP?</li> <li>How can I find out the COM port on my PC, to connect to the Agon?</li> <li>Why is Agon model XXX delivered with out-of-date firmware?</li> <li>What keyboard do I need for my Agon?</li> <li>Can you recommend a PS/2 keyboard?</li> <li>How do I configure a different keyboard layout?</li> <li>How do I exit to the MOS command line, from within BBC Basic?</li> <li>Where can I find the user/hardware manual for my Agon edition?</li> <li>Is there a community list of Agon software?</li> <li>Is there an Emulator available?</li> <li>What is the difference between the Agon Light and the Olimex Agon Light 2?</li> <li>I'm having issues with some video modes</li> <li>I'd like to start programming BBC Basic - where might I start?</li> <li>Are there any simple BBC BASIC examples?</li> <li>Is BASIC the only programming language available?</li> <li>I'd like to start assembly programming for the Agon platform - where might I start?</li> <li>I'd like to start C/C++ programming for the Agon platform - where might I start?</li> <li>I'd like to start Forth programming for the Agon platform - where might I start?</li> <li>Is there some in-depth API documentation available for me to look at?</li> <li>Is there a documented memory map available to me as a programmer?</li> <li>I'd like to read all details about Agon's ez80 microcontroller</li> <li>Can you code feature {x}?</li> <li>Why is feature {x} not documented anywhere?</li> <li>I'd like to discuss my project or ideas with like-minded people</li> </ul>"},{"location":"FAQ/#are-these-community-documents-available-offline-or-in-a-different-format","title":"Are these community documents available offline or in a different format?","text":"<p>No, and there are no immediate plans on doing this to reduce the amount of time spent doing documentation.</p> <p>This documentation however is all open source, and written in Markdown format.  Pull requests suggesting changes to the documentation are always welcome.</p>"},{"location":"FAQ/#is-the-agon-open-source","title":"Is the Agon open source?","text":"<p>Yes.  All of the firmware for the Agon platform is open source, for both MOS and the VDP, and also including the various versions of BBC BASIC for the Agon (BASIC 4 for Z80, BASIC 4 for eZ80 and BASIC V for Z80).</p> <p>Bernado Kastrup, the original hardware designer of the Agon Light, released the full schematics for the Agon light and the Agon light ORIGINS edition as open source.  He also designed Heber Ltd.'s Agon Console8, available from the Heber and Retro Collective shop.</p> <p>The Olimex AgonLight2 is based on the original Agon Light design, which is also an open source design.</p>"},{"location":"FAQ/#what-else-do-i-need-to-buy","title":"What else do I need to buy?","text":"<p>Okay, so you've ordered your Agon Light, and are wondering what else you will need to purchase.</p> <p>As a minimum, you also need the following extra hardware:</p> <ul> <li>A PS/2 compatible keyboard</li> <li>A micro USB card</li> </ul> <p>Note</p> <ul> <li>The original Agon Light requires a PS/2 keyboard, or a USB keyboard that supports the PS/2 protocol with a USB to PS/2 adaptor.</li> <li>The Agon Light 2 and Agon Console8 require a USB keyboard that supports the PS/2 protocol, or a PS/2 keyboard with a PS/2 to USB adaptor.</li> </ul>"},{"location":"FAQ/#does-agon-support-cpm","title":"Does Agon support CP/M?","text":"<p>Officially it is not designed to run CP/M out of the box. There are however third-party developers who have ported CP/M to the platform, and the official build supports this.</p> <p>There is also available a CP/M compatibility layer, allowing some CP/M software to run directly from the MOS command line.</p>"},{"location":"FAQ/#is-there-a-template-available-for-the-sd-card-to-get-me-started-quickly","title":"Is there a template available for the SD card, to get me started quickly?","text":"<p>Check out the Popup MOS repository; click the green 'Code' icon and select 'Download ZIP' from the dropdown menu. Unzip the file and copy over everything from the 'popup-os-main' folder to an empty SD card. The card should have folders like demos/docs/games/mos/utils in the root of the card</p> <p>Another great distribution is Agon Mite which aims to have a monthly release cycle.</p> <p>These repositories are a volunteer effort, periodically collecting the latest versions of software out there. If you need a more recent version of any package, because sometimes development goes pretty fast; please download it individually to your SD card.</p>"},{"location":"FAQ/#what-kind-of-sd-card-should-i-use","title":"What kind of SD card should I use?","text":"<p>Any class-10 micro SD card of a decent quality will do fine</p>"},{"location":"FAQ/#what-size-sd-card-should-i-buy","title":"What size SD card should I buy?","text":"<p>You should aim for a maximum card size of 32GB. Larger cards are supported (using FAT32), but you may run into issues partitioning and formatting them.</p>"},{"location":"FAQ/#how-should-i-format-the-sd-card-initially","title":"How should I format the SD card initially?","text":"<p>Format the card using a FAT32 layout</p>"},{"location":"FAQ/#will-my-agon-boot-directly-into-bbc-basic-or-will-i-have-to-download-the-language-onto-an-sd-card","title":"Will my Agon boot directly into BBC BASIC or will I have to download the language onto an SD card?","text":"<p>Most distributions contain both the BBC BASIC binary (bbcbasic.bin), and an autoexec.txt file at top level of SD card. The latter contains commands for auto loading BBC Basic. If you'd like to disable auto loading BBC BASIC; remove it, or change the content to suit your own requirements.</p>"},{"location":"FAQ/#how-should-i-power-the-agon","title":"How should I power the Agon?","text":"<p>All Agon platforms can be powered using a USB cable to your PC, or a USB wall-charger. The load is relatively light, usually below 200mA with a connected keyboard. Which USB cable you need, depends on the variant of Agon you buy. For example, the Olimex AgonLight2 is powered from a USB-C interface, while the Agon Console8 can be powered using a USB-B interface. The latter can also be powered with 5v DC jack connector.</p>"},{"location":"FAQ/#how-can-i-update-the-agon","title":"How can I update the Agon?","text":"<p>It really depends on the current firmware versions on your Agon. The Agon contains firmware for both the OS (MOS) and graphics unit (VDP).</p> <p>Full guidance on updating your Agon can be found in this detailed guide.</p>"},{"location":"FAQ/#where-can-i-find-the-latest-agon-firmwares-to-download","title":"Where can I find the latest Agon firmware(s) to download?","text":"<p>The latest Agon platform firmware releases for MOS and the VDP can be found here:</p> <ul> <li>MOS firmware</li> <li>VDP firmware</li> </ul>"},{"location":"FAQ/#quark-console8-or-agon-platform-firmware","title":"Quark, Console8, or Agon Platform firmware??","text":"<p>The original \"official\" firmware for the Agon Light was primarily written by Dean Belfield, with help from several other contributors, and was given the name \"Quark\".</p> <p>At the time of writing, the latest Quark firmware releases are Quark MOS 1.04 and Quark VDP 1.04, which were released in November 2023.  Dean is a busy man with a full-time job, and a family to look after, so his available time to work on the Agon is limited.  Since those firmware releases, he has concentrated his Agon efforts since then in developing and maintaining versions of BBC BASIC for the Agon.</p> <p>The Agon Console8 firmware started as a fork of the Quark firmware, made by Steve Sims.  An AgonConsole8 organisation was set up on GitHub, and hard forks made of the Quark firmware.  There are many reasons why this fork was made which won't be explored here.  The two most important reasons however were to allow for a more rapid release schedule, and to have a wider organisation in place for looking after the firmware, to avoid the \"hit by a bus\" risk of a single owner.  Initially all changes made to the Console8 firmware were raised as pull requests to be merged back into the Quark firmware, and broadly speaking the Quark 1.04 and Console8 2.0.0 releases were nearly identical.</p> <p>Owing to the pace of development, it stopped being practical to contribute changes made to the Console8 firmware (as it was then known) back to the Quark firmware early in 2024.</p> <p>Despite it's name, the Console8 firmware has always been able to be used on all Agon platforms, including the Agon Light, Agon Light 2, and Agon Origins Edition.  Whilst this has always been the case, the \"Console8\" name has lead to some confusion...</p> <p>\"Agon Platform\" is the new name for the Console8 firmware, and also the new name for the organisation.  This rename happened in April 2025.</p>"},{"location":"FAQ/#which-firmware-do-you-currently-recommend-using-on-my-agon","title":"Which firmware do you currently recommend using on my Agon?","text":"<p>We recommend using the Agon Platform firmware, as most development currently takes place there while staying compatible with previously released software. It's important to mention that the latest, most interesting games, make use of features that are only available in the Agon Platform (VDP) firmware, so make sure to use that.</p>"},{"location":"FAQ/#can-i-switch-between-the-quark-firmware-console8-and-agon-platform-firmware","title":"Can I switch between the Quark firmware, Console8, and Agon Platform firmware?","text":"<p>Yes, either way.</p>"},{"location":"FAQ/#what-is-the-function-of-agons-jumpers-and-what-is-their-recommended-position","title":"What is the function of Agon's jumpers and what is their recommended position?","text":""},{"location":"FAQ/#the-esp-jumper","title":"The ESP jumper","text":"<p>All Agon variants have a jumper location on the PCB marked 'ESP-PROG' or 'ESP-PROG1'. For programming the VDP over the USB interface, this needs to be CLOSED, i.e. both pins should be connected using the removable jumper. It is present on the PCB, to provide the option to prohibit the ESP32 to go into programming mode on reset, likely due to the way the USB serial driver behaves on your PC. If this happens to you occasionally and it looks like the Agon doesn't boot on a reset, it may be just waiting for an external programming session that never happens, spewing messages over the USB serial; in that case remove the jumper or leave it open, but remember to close it again before programming it externally over USB. The position of this jumper is ignored when programming the VDP using the flash tool from the MOS prompt. I recommend to leave this jumper in the CLOSED position, unless you experience problems resetting your Agon.</p>"},{"location":"FAQ/#the-uart-jumper","title":"The UART jumper","text":"<p>All Agon variants have a jumper to either enable, or prohibit the UART between the eZ80 and ESP32. During normal operation of the Agon, both ICs should be able to 'talk' to each other; this jumper was provided in case communication between them would somehow cause issues during programming either IC. AFAIK there haven't been cases to date where this proved necessary, but the option is at least there. If your Agon doesn't do anything after you have received it from your vendor, you may check this jumper's position. Cases have been reported of boards not working due to an incorrect factory jumper setting.</p> <ul> <li>The AgonLight/AgonLight2/AgonLight Origins edition have this jumper labeled as 'UART-DIS' or 'UART-DIS1', which should be left OPEN to not disable communications and have a working Agon</li> <li>The Agon Console8 has this jumper labeled as 'UART-EN1', which should be CLOSED to enable communications and have a working Agon.</li> </ul>"},{"location":"FAQ/#the-buzzer-jumper","title":"The Buzzer jumper","text":"<p>All Agon variants have a jumper to enable/disable the onboard buzzer, labeled 'BUZ-EN', 'BUZ_EN1' or 'BUZZER'. Leaving the jumper open disables the buzzer, while closing it enables it, whichever is your preference.</p>"},{"location":"FAQ/#do-i-need-to-buy-the-zilog-smart-cable-to-update-my-agon","title":"Do I need to buy the Zilog SMART cable to update my Agon?","text":"<p>No, not unless you will be developing your own Agon MOS firmware AND need to be comfortably sure you can recover it under ALL circumstances. And even then you may very well get by using one of the community-provided options. People in the community owning SMART cables are seldomly using them nowadays.</p> <p>As an example of this, most of the development of the Agon Platform MOS firmware has been done without the use of the Zilog SMART cable.</p> <p>Again, for regular update purposes, the Zilog SMART cable is unnecessary and a waste of money. If it's bricking you're worried about; there is a simple solution requiring just a few dupont cables and a clear step-by-step plan to recover your Agon. In any case, you can at least buy a new Agon for the price of the Zilog SMART cable. Ease your worries.</p>"},{"location":"FAQ/#i-still-would-like-to-buy-a-zilog-smart-cable-which-one-should-i-get","title":"I still would like to buy a Zilog SMART cable. Which one should I get?","text":"<p>The Agon-compatible Zilog product numbers are:</p> <ul> <li>ZUSBSC00100ZACG (discontinued)</li> <li>ZUSBASC0200ZACG (current; requires v5.3.5 or later of Zilog\u2019s ZDS -II IDE)</li> </ul> <p>Attention</p> <p>The cable with product number ZUSBESC0200ZACG is NOT suitable for Agon!</p>"},{"location":"FAQ/#can-i-go-back-to-an-earlier-firmware-version-downgrade","title":"Can I go back to an earlier firmware version / downgrade?","text":"<p>Absolutely (and this has been tested), but because literally ANY version can be flashed, please be mindful going back to older versions. The Pleistocene may not have a wall-outlet to charge your time travel device.</p> <p>Do yourselves a big favor, and stay away from anything below Quark 1.03, or that Zilog ZDS cable I mentioned you shouldn't buy, might suddenly start get interesting again.</p>"},{"location":"FAQ/#i-dont-have-a-console8-can-i-still-use-the-console8-firmware","title":"I don't have a Console8, can I still use the Console8 firmware?","text":"<p>Yes, the Console8 firmware can be used on any existing Agon platform computer.  This includes the original Agon Light, the Olimex Agon Light 2, the Agon Origins Edition, as well as the Agon Console8.</p> <p>There are no features in the firmware that are exclusive to the Agon Console8.  It is possible to add a PS/2 mouse port and two joystick ports to Agon Light machines in a manner that is completely compatible with the Console8 firmware.</p> <p>To help reduce this confusion, the \"Console8\" name has been dropped for firmware releases in favour of \"Agon Platform\" in April 2025.  The Console8 firmware is now known as the Agon Platform firmware.</p>"},{"location":"FAQ/#how-should-i-connect-the-agon-to-my-pc-for-programming-the-vdp","title":"How should I connect the Agon to my PC for programming the VDP?","text":"<p>To program an older VDP (1.03 or earlier) to a newer version, you need to connect the Agon using a USB (data) cable. Some very cheap USB cables may only have wires for powering/charging a USB device, without any wired data lines. Fortunately these are becoming scarce nowadays, but if all else fails, you might be using the wrong cable (or have the incorrect jumper setting; see above)</p> <p>The Agon will present a virtual serial port (COM) on your PC, that communicates directly with the ESP32 graphics chip (VDP).</p>"},{"location":"FAQ/#how-can-i-find-out-the-com-port-on-my-pc-to-connect-to-the-agon","title":"How can I find out the COM port on my PC, to connect to the Agon?","text":"<p>It depends on the OS you have. In Linux, when you insert your USB cable and type 'dmesg | grep tty', it should show.</p> <p>In Windows, it should show up in device manager, or in powershell type '[System.IO.Ports.SerialPort]::getportnames()'.</p> <p>In Mac OS, you can type 'ls /dev/tty.*' in Terminal to list all com ports currently attached.</p>"},{"location":"FAQ/#why-is-agon-model-xxx-delivered-with-out-of-date-firmware","title":"Why is Agon model XXX delivered with out-of-date firmware?","text":"<p>A legitimate question that you need to ask the respective vendor of your Agon.</p>"},{"location":"FAQ/#what-keyboard-do-i-need-for-my-agon","title":"What keyboard do I need for my Agon?","text":"<p>You need a keyboard that supports the PS/2 protocol, regardless of the physical connection that it has. Some Agon variants have a PS/2 interface, so any keyboard with a PS/2 connector should be fine. However, a number of Agon variants use a USB connector for their keyboard interface; for these you either need a USB keyboard that still supports the PS/2 protocol in backward compatibility mode (and it is usually hard to find out if it does), or a regular PS/2 keyboard with a PASSIVE PS/2-to-USB connector. An example for the latter, which is known to work well is this one. This is a pass-through connector, that just rewires the PS/2 signals to the USB connector. Perfect for the Agon.</p> <p>A PS/2-to-USB connector cannot make use of active logic and/or microcontrollers inside the connector. If the connector is dirt-cheap, it's usually passive, but even active converters can be offered relatively cheap.</p> <p>If a PS/2-&gt;USB converter has both a PS/2 keyboard and PS/2 mouse cable, a thick USB connector and/or a 'bulge' in the middle of the cable AND it doesn't specifically mention the term PASSIVE, it's a dead giveaway to be an active (non-supported) converter. Don't buy these: they scan/convert the PS/2 signals to a USB HID protocol that the Agon doesn't support. Examples to avoid 1 and 2</p>"},{"location":"FAQ/#can-you-recommend-a-ps2-keyboard","title":"Can you recommend a PS/2 keyboard?","text":"<p>Sure, there's a crowd-sourced spreadsheet here with a list of known working keyboards.</p> <p>If you have one, and it's not on the list, then please feel free to add an entry.</p>"},{"location":"FAQ/#how-do-i-configure-a-different-keyboard-layout","title":"How do I configure a different keyboard layout?","text":"<p>You can use the following command from the MOS command line, from BBC BASIC (using the *), or loaded on boot/reset using a line in the autoexec.txt file on your SD card:</p> <pre><code>*SET KEYBOARD n\n</code></pre> <p>The keyboard layout for UK = 0, US = 1</p> <p>The keyboard layouts your Agon can support depends on the firmware versions you are using; at the time of writing 17 different layouts are supported.  More information about available layouts is documented here</p>"},{"location":"FAQ/#how-do-i-exit-to-the-mos-command-line-from-within-bbc-basic","title":"How do I exit to the MOS command line, from within BBC Basic?","text":"<p>Use the following command:</p> <pre><code>*BYE\n</code></pre>"},{"location":"FAQ/#where-can-i-find-the-userhardware-manual-for-my-agon-edition","title":"Where can I find the user/hardware manual for my Agon edition?","text":"<p>Check out these links for your particular Agon edition:</p> <ul> <li>Byte Attic AgonLight R1.0</li> <li>Byte Attic Agon Origins edition</li> <li>Olimex AgonLight2</li> <li>Agon Console8</li> </ul>"},{"location":"FAQ/#is-there-a-community-list-of-agon-software","title":"Is there a community list of Agon software?","text":"<p>We're listing a few here, though there will certainly be others:</p> <ul> <li>Sabotrax/agon-software</li> <li>The Byte Attic - Agon overview</li> </ul>"},{"location":"FAQ/#is-there-an-emulator-available","title":"Is there an Emulator available?","text":"<p>Indeed there is, the Fab Agon Emulator. It is available for Windows, Linux and Mac (or you can compile your own).</p>"},{"location":"FAQ/#what-is-the-difference-between-the-agon-light-and-the-olimex-agon-light-2","title":"What is the difference between the Agon Light and the Olimex Agon Light 2?","text":"<p>The main differences are:</p> <ul> <li>The keyboard connector is USB, yet still requires a keyboard that supports the PS/2 protocol</li> <li>LIPO battery charging circuit</li> <li>UEXT connector</li> <li>USB C power connector</li> <li>Plastic boxed 34-pin GPIO connector</li> </ul> <p>And there are some minor revisions to discrete components on the board. Other than that, it is functionally identical to the original Agon Light design.</p>"},{"location":"FAQ/#im-having-issues-with-some-video-modes","title":"I'm having issues with some video modes","text":"<p>Historically, this has been a problem when the VDP firmware was built using the Arduino IDE.  You are strongly advised to use PlatformIO to build the VDP firmware, and to update to the latest versions; in doing so you should no longer have any issues with screen modes.  PlatformIO takes care of all the dependencies and settings and thus is much easier to use than the Arduino IDE.  The Agon Console8 VDP firmware (now known as the Agon Platform VDP firmware) no longer supports being built using the Arduino IDE and instead is built using PlatformIO to avoid these kind of issues.</p> <p>If you wish to still use the Arduino IDE and are building the Quark variant of the VDP firmware, you will need to make sure you have PSRAM enabled in the Arduino IDE settings when you compile and transfer the VDP code.</p> <p>Finally there are a few screen modes that the Agon supports that a limited number of screens might not support.  If you are having issues with a particular screen mode, try using a different screen mode to see if that resolves the issue.  Remember that you can always press the reset button.</p>"},{"location":"FAQ/#id-like-to-start-programming-bbc-basic-where-might-i-start","title":"I'd like to start programming BBC Basic - where might I start?","text":"<p>Have a look at this excellent guide. We also provide some documentation at our community site.</p>"},{"location":"FAQ/#are-there-any-simple-bbc-basic-examples","title":"Are there any simple BBC BASIC examples?","text":"<p>Your AGON may have a 'tests' folder with some BBC BASIC examples; if it doesn't, they can be found here.</p>"},{"location":"FAQ/#is-basic-the-only-programming-language-available","title":"Is BASIC the only programming language available?","text":"<p>The AGON comes pre-shipped with BASIC as it is a good language to start coding with, but you are not limited to it. The following languages are supported:</p> <ul> <li>Forth</li> <li>Assembly Language (either via BBC Basic inline assembler or external assembler)</li> <li>C (Cross-compiled from a PC, via ZDS tools, Agondev, or AgDev)</li> <li>C++ (Cross-compiled from a PC or Mac, via Agondev or AgDev)</li> </ul>"},{"location":"FAQ/#id-like-to-start-assembly-programming-for-the-agon-platform-where-might-i-start","title":"I'd like to start assembly programming for the Agon platform - where might I start?","text":"<p>We would recommend watching and learning these excellent tutorials</p> <p>Download the latest version of the onboard assembler. Don't dally using the one that came with your uSD card package, things move quickly in this space - use the latest.</p>"},{"location":"FAQ/#id-like-to-start-cc-programming-for-the-agon-platform-where-might-i-start","title":"I'd like to start C/C++ programming for the Agon platform - where might I start?","text":"<p>Assuming you already know some C/C++, we recommend downloading and using agondev as it is the best cross-development toolchain available for the Agon platform.  This is a comparatively new toolchain and is still in active development.</p> <p>Another option is the AgDev, which is an extension of the CEDev toolchain originally written to allow programs to be written for the TI-85 Plus CE and TI-83 Premium CE calculators, which use the same eZ80 processor as the Agon.  There are a number of example programs available in the AgDev repository.</p> <p>Agondev has a decent degree of compatibility with AgDev, but tends to be slightly more compliant with modern C and C++ standards.</p>"},{"location":"FAQ/#id-like-to-start-forth-programming-for-the-agon-platform-where-might-i-start","title":"I'd like to start Forth programming for the Agon platform - where might I start?","text":"<p>There is an excellent Forth implementation available here</p>"},{"location":"FAQ/#is-there-some-in-depth-api-documentation-available-for-me-to-look-at","title":"Is there some in-depth API documentation available for me to look at?","text":"<p>The community is building out at set of markdown documents to detail several aspects. These are extremely useful to a programmer.</p>"},{"location":"FAQ/#is-there-a-documented-memory-map-available-to-me-as-a-programmer","title":"Is there a documented memory map available to me as a programmer?","text":"<p>A memory map can be found here</p>"},{"location":"FAQ/#id-like-to-read-all-details-about-agons-ez80-microcontroller","title":"I'd like to read all details about Agon's ez80 microcontroller","text":"<p>Buckle up!</p> <ul> <li>eZ80F92 datasheet  - details regarding the eZ80F92 microcontroller peripherals like I2C, SPI, Flash memory, debug interface, timers</li> <li>eZ80 CPU datasheet  - details regarding the ez80 CPU itself, cpu architecture, registers, memory mode, interrupts and instruction set</li> <li>Application note AN033301-0711  - details of the ZDS Application Binary Interface (ABI), how to call C functions from Assembly and vice versa. Also applicable to the AgDev environment which is compliant to the ABI.</li> </ul>"},{"location":"FAQ/#can-you-code-feature-x","title":"Can you code feature {x}?","text":"<p>All suggestions are welcome, though the developers will be concentrating on key features. If we think your idea has legs, we'll add it to the pile.</p>"},{"location":"FAQ/#why-is-feature-x-not-documented-anywhere","title":"Why is feature {x} not documented anywhere?","text":"<p>You might have found an opportunity to make a valuable contribution to the Agon community. Take a look at the community documentation and create a pull request.</p>"},{"location":"FAQ/#id-like-to-discuss-my-project-or-ideas-with-like-minded-people","title":"I'd like to discuss my project or ideas with like-minded people","text":"<p>Perhaps you have some cool ideas and you want to run them past people, or you want to watch some of the developers talk, or you've followed all the instructions here and broke something and now you'd like to ask around to see if someone else has had the same experience? There is a Discord server available for Agon &amp; Console 8 community discussions.</p>"},{"location":"GPIO/","title":"User GPIO pins","text":"<p>GPIO, or General Purpose Input and Output, is an interface on a computer that is not dedicated to a single task. On the Agon this is exposed as a series of pins for the user to interface to. This might be for input controls, such as a joystick or buttons, motion sensors, or outputs to control your Christmas tree lights, send data to other displays, microprocessors, or even connect to the internet.</p> <p>Whilst sharing many similar pins, there are some variations across the range of Agon machines.</p> <p>The first generation Agon Light has a double row of 32 pins, whereas the Agon Light 2 has a double row of 34 pins. The additional pair of pins have been added for a battery power supply connection.</p> <p>The Agon Console 8 adds a few extra rows for additional connectivity to other parts of the ESP processor.</p> <p>More information about using these features can be found in the MOS API documentation.</p>"},{"location":"GPIO/#gpio-pinouts-original-agon-light-by-bernardo-kastrup","title":"GPIO Pinouts - Original Agon Light by Bernardo Kastrup","text":"<p>Viewed from the back, component side up, with the connector to the right of the board.</p> <p></p>"},{"location":"GPIO/#gpio-pinouts-agon-light-origins-edition-by-bernardo-kastrup","title":"GPIO Pinouts - Agon Light Origins Edition by Bernardo Kastrup","text":"<p>Viewed from the back, component side up, with the connector to the right of the board. A slight change with an additional pair of pins to the right hand side. The pin numbering is the same as the Agon Light 2 by Olimex.</p> <p></p>"},{"location":"GPIO/#gpio-pinouts-agon-light-2-manufactured-by-olimex","title":"GPIO Pinouts - Agon Light 2 manufactured by Olimex","text":"<p>The general layout is the same as the Origins Edition, apart from pins 1 &amp; 2.</p> <p></p> <p>Olimex's proprietary UEXT connector is mounted next to the main IO bus.</p> <p>Note that although there are duplicate pins exposed on the UEXT connector as the main IO bus, they are connected to the same pins on the ez80 chip. They are there for convenience, but do not provide any additional hardware ports.</p> <p>It is sometimes useful to have the duplicate pins for different purposes. For example, connecting a Nintendo Nunchuck controller on the UEXT using Olimex's adapter board, and a joystick on the main IO bus.</p> <p></p>"},{"location":"GPIO/#gpio-pinouts-console-8-manufactured-by-heber","title":"GPIO Pinouts - Console 8 manufactured by Heber","text":"<p>Viewed from the top front, component side up.</p> <p>The Console 8's pin numbering is different and although they look similar at first, some of the pins do not align with those of the Agon Light, so do not plug an Agon Light peripheral into the io bus of a Console 8. Pins marked * go via a transputer.</p> <p></p>"},{"location":"MOS/","title":"What is the MOS","text":"<p>The MOS is a command line Machine Operating System, similar to CP/M or DOS, that provides a human interface to the Agon file system.</p> <p>It also provides the MOS API for programmers to use that provides some basic facilities for file I/O and other common operations for BBC BASIC and other third-party applications.</p> <p>This documentation explains the general features of MOS, as well as commands it offers and how to use them.  It covers the Quark 1.04 version of MOS, the later Console8 MOS releases, and the Agon Platform MOS up to and including MOS 3.0.  Versions of MOS prior to Quark 1.04 may be missing some features described below.</p> <p>Please note that if you are running Quark 1.04 or earlier, the capabilities of MOS are very limited, and quite a few features described in this documentation will not be available to you.  You are strongly advised to upgrade to a later version of MOS.  MOS 2.x and MOS 3.x releases are fully compatible with software written for Quark 1.04, and will run all Quark 1.04 software without modification.</p>"},{"location":"MOS/#system-requirements","title":"System Requirements","text":"<p>To get the most out of MOS, you will need the following:</p> <ul> <li>A micro-SD card formatted as FAT32</li> </ul> <p>Technically MOS will work without an SD card, but you won't be able to do much with it.</p>"},{"location":"MOS/#using-an-sd-card","title":"Using an SD card","text":"<p>MOS supports the use of an SD card to store files and programs.  The SD card must be formatted as FAT32.  This documentation previously advised that the card should be 32GB or less in size, however several users report successfully using 64GB cards.  MOS supports automatically running a script file on boot and a way of adding new commands.</p>"},{"location":"MOS/#moslets","title":"Moslets","text":"<p>\"Moslets\" are a special type of program that are intended to extend the functionality of MOS by adding in new commands.</p> <p>By convention, moslets are stored in a special folder named <code>mos</code> at the top level of the SD card.  When you attempt to use a command that is not built into MOS, the system will look in the <code>mos</code> folder for a file with the same name as the command with a <code>.bin</code> extension.  If it finds one, it will execute that file as if it were a built-in command.</p> <p>Moslets have a special requirement in that they must be built to run from memory address <code>0x0B0000</code> onwards.  The use of this address is intended to allow moslets to run without affecting the main user program space.  The idea being that this will let you use a moslets from within BASIC (or from within other programs) without having to worry about it overwriting your program.</p> <p>From MOS 3.0 onwards it is possible to specify a different directory, or multiple directories, for the location of moslets on your system.  This is done by setting the <code>Moslet$Path</code> system variable.  By default this variable is set to <code>/mos/</code> for compatibility with previous versions of MOS.</p>"},{"location":"MOS/#the-run-path","title":"The \"run path\"","text":"<p>MOS 2.2.0 effectively added the concept of a \"run path\" to MOS, which would be used by the CLI to either search for commands not built into MOS, or to run programs.  In MOS 2.2.0 to MOS 2.3.2 the order of directories searched would be fixed, with the <code>mos</code> folder being searched first for moslets, followed by the current directory, and then the <code>bin</code> folder.  In MOS 2.x the order could not be changed.  MOS 3.0 provides a way to change this.</p> <p>Programs located outside of the moslet folder are expected to be full standalone programs that will be run and executed at the default memory address of <code>0x040000</code>, and thus will overwrite existing programs.</p> <p>NB there is currently no way to control the memory address that a program is automatically loaded into, so if you have a program that needs to be loaded at a specific address, you will need to use the <code>Load</code> command to load it manually and then use the <code>Run</code> command to start the program.</p> <p>It should be noted that MOS will always run the first program it finds with the same name as the command you have entered.  This means for example that if you have a moslet with the same name as a program in the <code>bin</code> folder, the moslet will be run instead of the program.</p> <p>From MOS 3.0 onwards the order of directories searched is controlled by the <code>Run$Path</code> system variable.  By default this is a macro variable set to <code>&lt;Moslet$Path&gt;, ./, /bin/</code> to be compatible with previous versions of MOS.  This variable can be changed to search in any order you like, and can include multiple directories.  By changing this variable you can, for example, make it so that the <code>bin</code> folder is searched before the <code>mos</code> folder, or add additional directories to search in.</p>"},{"location":"MOS/#boot-script","title":"Automatically running a script on boot","text":"<p>MOS has the ability to automatically run a script file on boot (power on, or a system reset).  Quite what this script does is up to you, but it could be used to set up your Agon in a particular way, or to run a program automatically.</p> <p>The exact file that will be run, and the manner in which the file is run varies depending on which version of MOS you are using.</p> <p>As of MOS 3, the system will first look for a boot file named <code>!boot.obey</code>, and use that as it's preferred boot script, running it using the <code>obey</code> command.  If that file is not present, it will look for a file named <code>autoexec.obey</code> and run that.  If neither of these are present it will fall back to working in a similar manner to Quark MOS 1.04 and MOS 2.x.  If you are running MOS 3, and have a suitably up-to-date version of the VDP firmware installed, you can prevent the boot script from being run by holding down the left \"Shift\" key on your keyboard during power up or reset.</p> <p>Quark 1.04, and Console8 MOS 2.x releases will all, at boot-up time, look for a file named <code>autoexec.txt</code> in the root folder of the SD card.  The manner in which this file is executed differs slightly between Quark 1.04 and the later Console8 releases.  Quark will blindly execute the commands and silently carry on it encounters an error, and any such errors will not be reported.  The Console8 MOS 2.x releases execute the <code>autoexec.txt</code> file using the <code>Exec</code> command and will stop execution if there is an error in the file, reporting the error as well as which line the error occurred on.</p> <p>If no matching script file is found, the system will simply boot to the command prompt.</p> <p>An example script, compatible with Quark 1.04 and all later versions of MOS, follows.  This script will to set keyboard to US, load BBC BASIC from the root folder, change to the test folder, then run BASIC.</p> <pre><code>SET KEYBOARD 1\nLOAD bbcbasic.bin\nCD test\nRUN\n</code></pre> <p>If you are running MOS 2.2.0 or later, and <code>bbcbasic.bin</code> is in your run path (most likely in a <code>/bin</code> directory), this script could be simplified to:</p> <pre><code>SET KEYBOARD 1\ncd test\nbbcbasic\n</code></pre> <p>MOS 3.0 allows for a great deal of customisation of your MOS environment, including the ability to set up custom command aliases, set \"run types\" to allow all sorts of files to be directly run from the command line, a custom command prompt, adjust the \"run path\" that will be searched for commands and executables, and many other features.  Many of these features are controlled through the use of system variables.  It is common to have a <code>!boot.obey</code> that will set up system variables to customise your MOS environment.</p> <p>MOS 3.0's preferred use of <code>!boot.obey</code> means that if you have more than one Agon computer running different versions of MOS then you can use the same SD card in all of them.  This would allow your MOS 3 system to use commands in its <code>!boot.obey</code> file that are not available in Quark MOS 1.04 or MOS 2, and those systems will still run the separate <code>autoexec.txt</code> file.  Your <code>!boot.obey</code> file could include commands specific to MOS 3, and finish with the command <code>exec autoexec.txt</code> to run the boot file used by earlier versions of MOS.</p>"},{"location":"MOS/#soft-boot","title":"Soft Boot","text":"<p>Pressing <code>CTRL+ALT+DEL</code> will reboot MOS on the eZ80. (<code>CTRL+SHIFT+ESC</code> for MOS 1.02 or earlier)</p> <p>NB:  This assumes that MOS is still talking to the VDP, as it is the VDP that is responsible for detecting keypresses.  Sometimes a soft reboot key combination will therefore not work, and you may need to instead press the reset button on your Agon.</p> <p>If you are using a MOS version earlier than 2.2.0, then a soft reset will not try to run the boot script.  To make sure the boot script runs you would need to do a \"hard boot\" by powering cycling your Agon (turn it off, then on again), or pressing the reset button.</p>"},{"location":"MOS/#the-mos-command-line-interface","title":"The MOS Command Line Interface","text":"<p>MOS provides a command line interface (CLI) that allows you to interact with the Agon file system and perform some basic control over your Agon computer.</p> <p>The MOS CLI is loosely inspired by the Acorn MOS present in the BBC Micro and later Acorn computer systems like the Archimedes.  The features and facilities supported by the MOS command line have evolved over time, with MOS 3.0 supporting many more commands than earlier versions of MOS.</p> <p>MOS works alongside the Agon's VDP, using the facilities of the VDP to display text on the screen and accept input from the keyboard.  The VDP provides some useful facilities, such as a \"paged mode\" that will stop the screen from scrolling until you press the <code>SHIFT</code> key to continue, or <code>ESCAPE</code> to exit.  Paged mode can be toggled on and off by pressing <code>CTRL+N</code> and <code>CTRL+O</code> respectively.</p> <p>In MOS 3 (when used with VDP 2.14.0 or later) the MOS CLI can also automatically use paged mode with commands that produce a lot of output.</p>"},{"location":"MOS/#the-mos-line-editor","title":"The MOS line editor","text":"<p>MOS provides a simple line editor that allows you to edit the current command line before submitting it to the system.  This same line editor is available for third-party applications like BBC BASIC to use.</p> <p>The line editor allows you to move the cursor around the current line of text, insert and delete characters, and submit the line to the system.  Whilst much of the functionality on Agon is inspired by the BBC Micro, the line editor differs - there is no \"copy\" cursor system on the Agon.  This line editor is similar to those that you will find on modern operating systems like MacOS, Linux or Windows.</p> <p>The MOS CLI line editor will also provide some basic command history, keeping track of the last 16 commands the user has entered.  Pressing the <code>UP</code> arrow key when at the beginning of a line will replace the current line with the last entered command.  Similarly pressing the <code>DOWN</code> arrow key at the end of a line will cycle through the command history in the opposite direction.  The <code>HOME</code> and <code>END</code> keys will move the cursor to the start and end of the current line respectively.</p> <p>The Console8 MOS 2.2.0 release also adds support for pressing the <code>PAGE UP</code> and <code>PAGE DOWN</code> keys to quickly step through the command history.</p> <p>Also added to the 2.2.0 release is \"tab completion\".  If you start typing a command and then press the <code>TAB</code> key, MOS will attempt to complete the command for you.  This includes both built-in commands, moslets found in the <code>mos</code> folder, programs found in the current directory, and programs found in the <code>bin</code> folder, or file names within the current directory.  In MOS 3.0 onwards, the tab completion uses the <code>Run$Path</code> variable to determine where to look for commands.</p> <p>There is also support for programmable function keys in the 2.2.0 release.  For more information on that see the <code>Hotkey</code> command.</p>"},{"location":"MOS/#the-mos-command-prompt","title":"The MOS command prompt","text":"<p>On versions of MOS prior to the 2.2.0 release, the MOS command prompt is a simple <code>*</code> character.  This is the point at which you can enter commands to the system.</p> <p>From the Console8 MOS 2.2.0 release onwards the prompt has been extended to include the current directory.  This is to help you keep track of where you are in the file system.  The prompt will look something like this:</p> <pre><code>/programs *\n</code></pre> <p>MOS 3.0 allows you to customise the prompt using the <code>CLI$Prompt</code> system variable.  By default this is set to a macro to display a prompt identical to that introduced in MOS 2.2.0.  If this variable is unset, then the prompt will revert to the simple <code>*</code> character.</p>"},{"location":"MOS/#mos-commands","title":"MOS Commands","text":"<p>MOS offsets a number of inbuilt commands that allow you to interact with the Agon file system and control your computer.</p> <p>The various commands available in MOS are described in the MOS Command Reference.  The exact array of built-in commands available has changed over time with new commands being added, and new features added to existing commands.</p> <p>As of MOS 3.0 the command interpreter has become fairly sophisticated.  It will support user-defined commands aliases, and the use of system variables.  As well as the ability to run moslets and program files directly (as described above) it can now also directly run any file that has a \"run type\" set up for it by simply typing the name of the file.</p>"},{"location":"MOS/#mos-system-variables","title":"MOS System Variables","text":"<p>From MOS 3.0 onwards, MOS supports the concept of system variables.  These can be used for user programs, as well as providing ways to gain information about the system and control the behaviour of MOS.</p>"},{"location":"MOS/#script-files","title":"Script files","text":"<p>All Agon Platform and Console8 MOS releases support the concept of a script file.  This is a file that contains a series of MOS commands that can be executed in sequence.  This is useful for automating tasks, or for setting up your Agon in a particular way.  When a script file is run, if an error is encountered the system will stop executing the script and report the error, as well as which line the error occurred on.</p> <p>The first type of script file is an \"Exec\" file, which is a simple text file containing a series of MOS commands, one per line.  You can run an Exec file using the <code>Exec</code> command.</p> <p>MOS 3.0 has added a second type of script file, which  is an \"Obey\" file, which are run using the <code>Obey</code> command.  This is very similar to an Exec file, but when running an Obey file the system will set a system variable to indicate the directory inside which the Obey file is located, and it will also support argument substitution.</p> <p>Quark MOS 1.04 only supports a single script file, <code>autoexec.txt</code> that will be run at boot, and offers no command to run a script file.</p>"},{"location":"MOS/#programs-and-modules","title":"Programs and Modules","text":"<p>Executable program files on MOS need to be in a specific format.  This is described in the Executable file format documentation.</p> <p>A future version of MOS is also likely to support the concept of \"modules\".  This will be a way to extend the functionality of MOS to add in new features, whether they are commands, APIs or something else.  The exact details of the module system are still in development.</p>"},{"location":"MOS/#memory-map","title":"Memory map","text":"<p>Addresses are 24-bit, unless otherwise specified</p> <ul> <li><code>&amp;000000 - &amp;01FFFF</code>: MOS (Flash ROM)</li> <li><code>&amp;040000 - &amp;0AFFFF</code>: User RAM *</li> <li><code>&amp;0B0000 - &amp;0B7FFF</code>: Moslet/Module memory space</li> <li><code>&amp;0B8000 - &amp;0BBFFF</code>: Reserved for MOS</li> <li><code>&amp;0BC000 - 0BFFFFF</code>: Global (MOS) heap and stack</li> <li>...</li> <li><code>&amp;B7E000 - &amp;B7FFFF</code>: The eZ80's 8kb of internal (fast) RAM</li> </ul> <p>* Technically, user programs can actually use the whole RAM space from <code>&amp;040000</code> to <code>&amp;0BBFFF</code>, but programs that use memory above <code>&amp;0AFFFF</code> may have limitations.  A program that uses the moslet/module memory space for instance will not be able to use moslet-based commands, and when modules are introduced will have limitations on access to functionality provided by modules.  Programs should need to indicate in their header whether they are \"module safe\" or \"module compatible\".  Guidance on how to make your program \"module safe\" will be provided in the MOS Modules documentation.</p>"},{"location":"MOS/#the-stack","title":"The Stack","text":"<p>Up to and including the MOS 3.0 release, MOS sets up a stack pointer for its own use.  As MOS is written to run in the eZ80's \"ADL\" mode, this means the <code>SPL</code> register, the version of <code>SP</code> visible to ADL-mode code, is what is set up.  Programs that are run in ADL-mode will see this stack pointer when they start up.  Care should therefore be taken to ensure that the stack pointer is not corrupted by the program, as this will affect the operation of MOS and any other programs that are run after it.</p> <p>The architecture of the eZ80 means that programs running in Z80 mode see a different version of the stack pointer <code>SP</code> register, known as <code>SPS</code>.  This value is not set up by MOS, and is left to the user program to set up.  The value of <code>SP</code> in Z80 mode should be treated by programs as undefined on startup.</p> <p>Future versions of MOS may change the behaviour of the stack pointer for ADL-mode code in order to provide better protection for the MOS stack.  For compatibility with existing software, a stack pointer will still be set up for programs that use ADL-mode, but this may be allocated within the MOS heap space.</p>"},{"location":"Projects/","title":"Projects","text":"<p>In the Agon Projects Git, there are a handful of useful templates and projects.</p>"},{"location":"Projects/#the-templates","title":"The Templates","text":"<p>There are three template projects that can be used as a basis for your projects:</p> <ul> <li>A 16-bit mode Hello World app in assembler that demonstrates calling the MOS from a 64K segment in Z80 mode</li> <li>A 24-bit mode Hello World app in assembler</li> <li>A 24-bit mode Hello World app in C</li> </ul> <p>All three apps act as MOS extensions; the resultant binary can be copied into the <code>mos</code> folder on the SD card, can be executed as a star command, and will display any passed parameters.</p>"},{"location":"Projects/#the-applications","title":"The Applications","text":"<ul> <li>A memory dump application written as a 16-bit mode assembly language app.</li> <li>An eZ80 disassembler written as a C application.</li> </ul> <p>Both can be run as star commands from MOS.</p>"},{"location":"Theory-of-operation/","title":"Understanding the Agon Light computer platform","text":"<p>The Agon Light, and its variants, is a retro-style computer platform that is designed to be inexpensive and easy to manufacture, using commonly available parts.</p> <p>The platform is designed to be easy to understand, and easy to program.  It is designed to be a platform that is suitable for learning about computers, and learning about programming.</p> <p>Please note this is a preliminary guide to the Agon Light platform, and is subject to change.  The Agon Light platform is still under development, and this guide is still being written.</p>"},{"location":"Theory-of-operation/#the-agon-light-hardware","title":"The Agon Light hardware","text":""},{"location":"Theory-of-operation/#the-main-processor","title":"The main processor","text":"<p>The primary processor on which you run programs is an eZ80.  This is a microcontroller based on the Zilog Z80 processor, which was used in many computers and arcade machines in the 1970s and 1980s.  The eZ80 is a modern version of the Z80, with a few enhancements.  It has attached to it 512KB of RAM, which is considerably more than the 64KB that was common in the 1980s.  Also attached to the eZ80 chip is an SD card interface, allowing an SD card to be used for storage.</p> <p>The eZ80 was chosen as the main processor of the Agon Light because of its historic ubiquity, and because it is still manufactured today.  It is a relatively simple processor, and is easy to understand and program.</p> <p>The eZ80 runs an operating system called MOS.  This is a relatively simple operating system designed to provide basic facilities to programs.  Alternative operating systems such as CP/M can be used on the Agon Light, but MOS is the default operating system.</p>"},{"location":"Theory-of-operation/#the-video-display-processor-or-vdp","title":"The video display processor, or VDP","text":"<p>Whilst the eZ80 is manufactured today, none of the video chips that were used in computers of the 1970s and 1980s are still manufactured, so for video output a different solution is needed.  To solve this problem the Agon Light uses a separate video processor, which we call the VDP, the Video Display Processor.  This chip is responsible for sound and video output, and also keyboard and mouse input.  Technically, this is an ESP32-Pico-D4 chip, which has attached to it an 8MB RAM chip which is used for storing bitmaps, sound samples, fonts, and other data.</p> <p>The exact technical details of the VDP however for most programmers is not important - in the Agon platform, from a software perspective, the VDP is designed to be used via a simple API, with the details of how it works abstracted away.  Indeed, when using an emulator of the Agon Light, the VDP chip is not emulated at all; the emulator instead runs a compiled version of the VDP firmware using the host computer's video and audio hardware.</p> <p>Effectively, the design of the Agon Light is that of two computers in one.  The eZ80 is the computer that is used to run programs, and the VDP is a smart terminal computer that draws the screen, plays sound, and handles the keyboard and mouse<sup>1</sup> interfaces.  The eZ80 and the VDP communicate with each other using a high speed serial interface.</p> <p>Some other retro-inspired computers take a different approach to solving the video output problem.  Often this involves making use of an FPGA chip, which is a chip that can be programmed to behave like any other chip.  This is a very flexible solution, but it is also very expensive.  The Agon Light takes a different approach, using a separate video processor chip, which is much cheaper than an FPGA.</p> <p>The use of what is effectively a separate computer for the VDP in the Agon platform creates a significant architectural difference to many classic home computers of the 8-bit, 16-bit and early 32-bit era.  Those classic computers would usually use a shared area of memory that the main processor and the video processor would both have access to.  This shared memory would be used to store the screen memory, and the main processor would write to this memory to update the screen.  This is not the case with the Agon platform.  The eZ80 and the VDP have no shared memory, and the VDP has no access to the eZ80's RAM.  This means that the VDP cannot read the screen memory directly, and the eZ80 cannot write directly to the screen memory.  Instead, the VDP has to be sent commands to draw things to the screen, and the eZ80 has to be sent commands to read things from the screen.  This is a significant difference to many classic computers, and is something that programmers need to be aware of when writing programs for the Agon platform.</p>"},{"location":"Theory-of-operation/#the-agon-software-platform","title":"The Agon software platform","text":"<p>From a software perspective, a significant inspiration for the Agon Light was the BBC Micro, a popular computer in the UK from the 1980s designed and built by Acorn Computers Ltd..  (Acorn went on to design the ARM processor, which is now the most commonly used processor design in the world.)  The BBC Micro was part of the BBC's Computer Literacy Project, which was a project to introduce computers to the UK population with an emphasis on education.  The BBC Micro was designed to be easy to use, and to be used in schools by children.</p> <p>There are several significant differences between the Agon Light and the BBC Micro, but the two most important ones are the main processor, and the video system.  A BBC Micro was based on the 6502 CPU, which was a competitor to the Z80.  The 6502 was a simpler processor than the Z80, and was cheaper to manufacture, and given the relative simplicity often significantly faster than the Z80.  The 6502 was used in many popular computers and games consoles of the 1970s and 1980s, including the Apple II, the Commodore 64, and the Atari 2600.  The Z80 was used in many other popular computers of the 1970s and 1980s, including the Sinclair ZX80, the Sinclair ZX81, the Sinclair Spectrum, the Amstrad CPC, and the MSX.  The BBC Micro however was designed from the ground up to be a computer capable of having multiple processors, and the first second processor option available for the computer was the Z80.  A version of BBC BASIC was produced for Acorn's Z80 second processor, and this is the version of BBC BASIC that the Agon Light is directly based on.</p>"},{"location":"Theory-of-operation/#bbc-basic","title":"BBC BASIC","text":"<p>An important part of the BBC Micro was BBC BASIC, a well respected version of the BASIC programming language.  Compared to other versions of BASIC, BBC BASIC was very powerful since it included many advanced features, such as procedures, functions, and recursion.  It also included many commands for graphics and sound, which made it easy to write games and other programs that used graphics and sound.</p> <p>The original version of BBC BASIC for the BBC Micro's 6502 processor was written by Sophie Wilson of Acorn.  The version of BBC BASIC for the Z80 was written by Richard T. Russell, and was based on the original version by Sophie Wilson.  Specifically it is effectively equivalent to BBC BASIC 4 that was used on the BBC Master series of computers.  The version of BBC BASIC for the Agon Light is directly based on R.T.Russell's version, and is largely compatible with the BBC Micro version.</p> <p>BBC BASIC has an inbuilt assembler, which allows for machine code to be embedded within BASIC programs.  This is a very powerful feature, and allows for programs to be written that make use of the full power of the processor.  Machine code can run very many times faster than interpreted BASIC.  It should be noted that the Z80 version of BASIC as used on the Agon platform has an assembler for the Z80 built in, whereas the original 6502 version of BASIC for the BBC Micro included an assembler for the 6502 processor.  Programs written for the BBC Micro that include assembler code will therefore not run on the Agon Light without rewriting those assembler routines.</p>"},{"location":"Theory-of-operation/#bbc-basic-adl-version","title":"BBC BASIC ADL version","text":"<p>There is now a newer version of BBC BASIC for the Agon platform known as the \"ADL version\".  The original Z80 version of BBC BASIC was restricted to work within 64KB of RAM.  This limitation was due to the fact that the Z80 processor only has 16 address lines (also referred to as a 16-bit address bus), so technically it can only address 64KB of RAM.</p> <p>The newer eZ80 CPU used in the Agon Light has a 24-bit address bus, which means that it can potentially address up to 16MB of RAM.  Agon Light machines come with 512KB of RAM attached to the eZ80 CPU.</p> <p>To allow programs to make use of this extra RAM, and some other new facilities, the eZ80 has extensions known as \"ADL mode\".  This mode extends most processor registers to 24 bits, and allows for the use of the extra RAM.  The ADL version of BBC BASIC is designed to make use of this extra RAM, and to allow for programs to be written that make use of more than 64KB of RAM.</p> <p>The ADL version of BBC BASIC also includes modifications to the assembler to allow for the use of newer ADL machine code instructions.  This means that programs written for the ADL version of BBC BASIC may not run on the original Z80 version of BBC BASIC.</p>"},{"location":"Theory-of-operation/#vdu-commands-screen-modes-and-the-vdp","title":"VDU commands, screen modes, and the VDP","text":"<p>The other significant difference between the Agon Light and the BBC Micro is the video system.  As video output is handled by a separate processor, and there is no shared memory between the two processors within an Agon Light, the design of the Agon system does not allow for the video system to work in the same kind of manner as a BBC Micro.  From a software perspective, however, the Agon Light is designed to be as similar as possible to the BBC Micro, and the video system is designed to be as similar as possible to the BBC Micro video system.  This means that many programs written for the BBC Micro can be ported to the Agon Light with minimal changes.</p> <p>Using BASIC on a BBC Micro, the primary way to draw things to the screen was via simple keywords such as <code>PRINT</code>, <code>MOVE</code>, <code>DRAW</code>, <code>PLOT</code>, <code>COLOUR</code> (etc.) and most importantly <code>VDU</code>.  It is the <code>VDU</code> keyword that sent commands to the video system.  Effectively all of the other keywords that drew onto the screen (or changed drawing settings) are just shorthand for <code>VDU</code> commands.</p> <p>The same is true on the Agon Light.  The Agon's VDP processor has been written to understand the same <code>VDU</code> commands as the BBC Micro, and so the same keywords that draw things to the screen on a BBC Micro will also draw things to the screen on an Agon Light.  This means that many programs written in BBC BASIC for the BBC Micro can be ported to the Agon Light with minimal changes.</p> <p>The Agon Light also includes a number of additional <code>VDU</code> commands that are not present on the BBC Micro, which allow for more advanced graphics and sound effects.  These commands are documented in the VDP section of this documentation.</p>"},{"location":"Theory-of-operation/#screen-modes","title":"Screen modes","text":"<p>Another important difference to be aware of is that the available screen modes on the Agon Light are different to those on the BBC Micro.  The single exception to this is mode 7, the teletext mode, which is supported on both platforms.  A BBC Micro was highly limited in terms of its video output, supporting only 8 different screen modes, using only 4 different pixel resolutions, and a maximum of 8 colours.  Agon machines offer a much wider variety of screen modes, with many more resolutions to choose from, and up to 64 colours on screen at once.</p> <p>Whilst the screen modes available on the Agon differ, the Agon graphics system by default uses the same 1280x1024 coordinate space as the BBC Micro<sup>2</sup>, where the origin is at the bottom left of the screen.  As this is the same coordinate space as the BBC Micro, programs that use this coordinate space on the BBC Micro will work on the Agon Light without modification.  As the screen ratios are different on the Agon you may see some inaccuracies when comparing output directly to a BBC Micro, but the differences are generally minor.</p> <p>The purpose of having a uniform coordinate space is to make it easier to allow you to change a program initially written to run in one screen mode (at one particular resolution) to run in a different screen mode at a different resolution without having to change the coordinates used in the program.</p> <p>This style of coordinate space may be alien to you, and also has some limitations if you wish for pixel perfect accuracy when positioning things on-screen<sup>3</sup>.  A command is available to switch the coordinate system to use the native pixel resolution of the screen mode with the origin at the top left of the screen.</p> <p>Whilst the BBC Micro could only display 8 colours on screen at once, it did have a \"16 colour\" screen mode where half of the colours were flashing.  The Agon does not provide any screen modes with direct support for flashing colours, but it is possible to simulate these modes on later versions of the Agon VDP firmware.</p>"},{"location":"Theory-of-operation/#limitations","title":"Limitations","text":"<p>The nature of the MOS/VDP split on the Agon platform carries with it some limitations that you should be aware of.</p> <p>The VDP is, essentially, a stream processor.  It accepts a stream of data from the eZ80, and interprets that as a series of commands and data.  In regular use, there is no command to indicate the beginning of a command stream, and no command to indicate the end of a command stream.  The VDU commands that the VDP interprets are of a variable length, ranging from a single byte to potentially over 64kb.  A single <code>VDU</code> statement in BASIC could be a complete command from the perspective of the VDP, or it could be the first part of a command that is continued in the next <code>VDU</code> statement.  For commands that are intended to send across a large amount of data, such as a bitmap or a sound sample, the data is typically sent using a series of <code>VDU</code> statements, each of which is a part of the same command.</p> <p>Care must therefore be taken to ensure that the VDP is sent complete commands, and that commands are not interleaved.  For instance, it may be tempting when transferring over a sound sample to use <code>PRINT</code> or <code>DRAW</code> statements to show progress.  This will not work, because the VDP will interpret the <code>PRINT</code> or <code>DRAW</code> statements (which will have been translated into a raw VDU byte command stream) as part of the sound sample data.</p> <p>To solve this issue, the VDP provides a Buffered Commands API.  This allows for data to be sent to the VDP in discrete chunks, sent to one of over 65000 buffers.  Once all of the data has been sent, a command can be sent to the VDP to make use of the data in the buffer, whether that is to use the buffer as a sound sample, a bitmap, or a sequence of VDU commands.  So to print a progress bar whilst sending a sound sample, you would send the sound sample data to a buffer a chunk at a time using the Buffered Commands API \"add block\" command, and after each chunk use drawing commands to update the progress bar.  Once all of the sound sample data has been sent, you would then send a command to the VDP to identify that data as a sound sample, and/or use other commands to play that sample.</p> <ol> <li> <p>As of the time of writing, the only model of Agon that comes with an inbuilt PS/2 mouse port is the Agon Console8. All other models of Agon can add one using a simple circuit attached to some GPIO pins.\u00a0\u21a9</p> </li> <li> <p>Technically the BBC Micro's coordinate system was not actually 1280x1024; that was just the coordinate space of all the graphical screen modes that most models of the BBC Micro supported.  The actual OS coordinates on a BBC Micro are based on the pixel resolution of the screen with a conversion factor applied for the X and Y dimensions.  A BBC Micro built for the UK market was made to work with PAL TVs, and all of its screen modes had a vertical pixel resolution of 256 lines, with a conversion factor for the Y dimension of 4.  A BBC Micro built for the US market (which were very rare) had the same conversion factor of 4, but a vertical pixel resolution of 200 lines as they were built to work with NTSC TVs.  Later Acorn computers such as the Archimedes used the same system of conversion factors, but as they offered a wider variety of pixel resolutions some screen modes would use different coordinate spaces.\u00a0\u21a9</p> </li> <li> <p>Using a strict 1280x1024 OS coordinate space has meant that in all screen modes on the Agon the vertical conversion factor for the Y dimensions is never a round number, and will always includes a fraction.\u00a0\u21a9</p> </li> </ol>"},{"location":"Third-Party-Projects/","title":"Third Party Projects","text":"<p>Please note that this list is far from exhaustive. If you have a project that you would like to add to this list, please submit a pull request.</p>"},{"location":"Third-Party-Projects/#popup-mos","title":"Popup MOS","text":"<p>https://github.com/tomm/popup-mos</p> <p>A batteries-included SDCard template for Agon Light / Agon Light 2 / Console8</p>"},{"location":"Third-Party-Projects/#flash-updater","title":"Flash Updater","text":"<p>https://github.com/envenomator/agon-flash</p> <p>A utility to flash a MOS image to the eZ80F92 Flash without a ZDS USB cable, and to update the VDP firmware.</p>"},{"location":"Third-Party-Projects/#hex-loader","title":"Hex Loader","text":"<p>https://github.com/envenomator/agon-hexload</p> <p>Playing microSD jockey during assemble/compile/transfer/test/debug cycles is no fun at all. This utility shortens this cycle significantly by removing the need to physically bring over new binaries to the Agon.</p> <p>With the hexload command you are able to transmit Intel I32 hex files to one of the Agon serial ports and run your code immediately from memory.</p>"},{"location":"Third-Party-Projects/#ez80-assembler","title":"eZ80 Assembler","text":"<p>https://github.com/envenomator/agon-ez80asm</p> <p>A fully-featured eZ80 assembler that runs on the Agon.</p>"},{"location":"Third-Party-Projects/#forth-interpreter","title":"Forth Interpreter","text":"<p>https://github.com/lennart-benschop/agon-forth</p>"},{"location":"Third-Party-Projects/#agon-utilities","title":"Agon Utilities","text":"<p>https://github.com/lennart-benschop/agon-utilities</p> <p>A selection of handy utilities including copy, compare, more, memfill, font, and a full-screen editor with nano-style key bindings.</p>"},{"location":"Third-Party-Projects/#sokoban","title":"Sokoban","text":"<p>https://github.com/envenomator/agon-sokoban</p> <p>Sokoban game for AGON</p>"},{"location":"Updating-Firmware/","title":"Updating the Agon Firmware","text":"<p>When new versions of the Agon firmware are released, you will need to update your Agon machine to take advantage of the new features and bug fixes.  All models of Agon machines to date can run the latest versions of the Agon platform firmware.  This includes the original Agon Light, the Olimex Agon Light 2, the Agon Console8, and the Agon Light Origins Edition.</p> <p>The Agon firmware is made up of two components:</p> <ul> <li>The Agon MOS (the operating system, which runs on the eZ80 CPU)</li> <li>The VDP (the graphics chip, which runs on the ESP32)</li> </ul> <p>These two components are updated separately.  The exact steps to update your Agon will depend on the versions of the firmware your Agon is currently running.</p> <p>Attention</p> <p>Before you continue, please note that if your Agon is running a version of MOS before 1.03, or a version of the VDP before 1.04RC3, then the upgrade process is a little different.  It is important that you follow the guidance that can be found below.  Failing to do so may result in your Agon becoming unusable.  Recovery tools are available to restore your Agon to a working state, but it is best to avoid needing them in the first place.</p> <p>The primary tool to update the firmware on your Agon is the Agon firmware update utility, otherwise known as \"agon-flash\".  This tool runs on your Agon, and can be used to update both MOS and the VDP so long as they are already running compatible versions.  The latest version of the this tool can be downloaded here.</p> <p>Updating the VDP firmware can also be done using the online Agon VDP installer.  Many users find this to be the easiest way to update the VDP firmware.</p>"},{"location":"Updating-Firmware/#how-to-use-the-agon-firmware-update-utility","title":"How to use the Agon firmware update utility","text":"<p>The Agon firmware update utility is run on your Agon, and needs to be installed onto the SD card you use with your Agon.  That SD card must be formatted as FAT32.</p> <ol> <li>Make sure to create a mos directory on the microSD card, if it's not already present.</li> <li>Place the flash.bin in the mos directory</li> <li>Place the firmware files in the root directory of the microSD card:<ul> <li>MOS firmware - default filename 'MOS.bin' (download latest version)</li> <li>VDP firmware - default filename 'firmware.bin' (download latest version)</li> </ul> </li> </ol> <p>Once you have installed the Agon firmware update utility, and ensured that you have the latest firmware files on your SD card, it can be used to update the firmware on your Agon.</p> <p>As noted above, to update MOS using this tool, your Agon must be running at least MOS 1.03.  If you are running an older version of MOS, you will need to use the older method of updating MOS.  See below for more details.</p> <p>To upgrade MOS, you can use the following command from the MOS command line:</p> <pre><code>*flash mos MOS.bin\n</code></pre> <p>Updating the VDP using this tool requires a version of the VDP firmware that supports the update process.  This is VDP 1.04RC3 or later.  If you are running an older version of the VDP, you will need to use the older method of updating the VDP.  See below for more details.</p> <p>To upgrade the VDP, you can use the following command from the MOS command line:</p> <pre><code>*flash vdp firmware.bin\n</code></pre> <p>The update process will take a few seconds, and you will be asked to confirm that you wish to flash a new version of your firmare.  Once you press \"Y\" to confirm the update process will begin, and the Agon will reboot automatically once it is complete.</p> <p>On rare occasions the Agon may not reboot automatically - you may see the countdown, but then be left on the update screen.  If this happens, just press the \"reset\" button on the Agon to reboot it, or switch your Agon off and back on.</p> <p>When asking for confirmation, the tool will display a CRC checksum for the file you are about to install; we no longer publish the checksums for firmware files, as in general we found that most people did not find this useful.  (Older versions of the flash tool would require you to manually enter the CRC number as part of the flash command which users found frustrating as it was easy to make mistakes when typing in the checksum.)  Should you wish to verify the checksum of the firmware you are about to install you can generate a CRC32 checksum for the firmware file on your desktop computer using a tool such as <code>crc32</code>.</p>"},{"location":"Updating-Firmware/#issues-with-updating-from-some-agon-vdp-firmware-releases-using-the-agon-firmware-update-utility","title":"Issues with updating from some Agon VDP firmware releases using the Agon firmware update utility","text":"<p>There have been three releases of the Agon VDP firmware that unfortunately contained a bug that prevented the Agon firmware update utility from working correctly.  These releases are:</p> <ul> <li>VDP 2.8.0</li> <li>VDP 2.12.0</li> <li>VDP 2.13.0</li> </ul>"},{"location":"Updating-Firmware/#vdp-installer","title":"How to use the online Agon VDP installer","text":"<p>The online Agon VDP installer is a web-based tool that allows you to update the VDP firmware on your Agon without needing to download and install the Agon firmware update utility.</p> <p>The online Agon VDP installer will work with any Agon machine, running any firmware version.  Please note though that you should not use this tool unless you are running at least MOS 1.03 - if you are running an older version of MOS then it is very important to update that first.</p> <p>There are two pre-requisits to using this tool.</p> <ol> <li>You must be using a web browser that includes \"Web Serial\" support, which includes Google Chome/Chromium, Microsoft Edge, and Opera</li> <li>Your Agon must be connected to your PC (or Mac) using a USB data cable. The type of USB cable may differ according to the Agon platform you're using:<ul> <li>the original Agon Light has a USB-A type connector *</li> <li>the Olimex Agon Light 2 has a USB-C type connector</li> <li>the Agon Console8 has a USB-B type connector</li> <li>the Agon Origins edition has a USB-B type connector</li> </ul> </li> </ol> <p>* The original Agon Light's use of a USB-A connector can cause some problems, as a USB-A to USB-A cable is not a standard cable.  If your PC has a USB-C connector you may be able to use a USB-A to USB-C cable.</p> <p>Many people power their Agon via the Agon's USB connector.  If you do so by plugging your Agon in to one of your PC's USB ports, so long as your cable is a data cable and not a power-only cable, you should already be able to use the Agon VDP installer.  If you are using a power-only cable, you will need to use a different cable.</p> <p>Using the online installer is very simple.  Just visit the installer, select the latest version of the VDP firmware, and click on the update button.  Once the update is complete, the Agon will reboot automatically.</p>"},{"location":"Updating-Firmware/#update-old","title":"Upgrading from older firmware versions","text":"<p>If your Agon is running older versions of the firmware then you will need to follow a different process to update your Agon.  This is because versions of MOS before 1.03 and the VDP before 1.04RC3 do not support the current Agon firmware update utility.</p> <p>In general, the simplest way to update your Agon is to follow these two steps:</p> <ol> <li>Update MOS to the latest version using the Agon legacy firmware update utility</li> <li>Update your VDP firmware to the latest version using the online Agon VDP installer</li> </ol> <p>It is very important that you update MOS first, as there was a change in how MOS and the VDP communicated in early firmware versions.  If you try to update the VDP first then you will not be able to run the Agon legacy firmware update utility, and you will not be able to update MOS.</p> <p>After updating MOS you may find that your Agon appears to not be working properly.  It may fail to start up completely, it might only show the VDP version line, or it may appear to boot but not respond to keyboard input.  This is normal, and is expected behaviour.  Once you have updated the VDP firmware, your Agon will work properly again.</p>"},{"location":"Updating-Firmware/#other-options-for-updating-your-vdp-firmware","title":"Other options for updating your VDP firmware","text":"<p>If for some reason you are unable to use the online Agon VDP installer, and you are unable to use the Agon firmware update utility, then there are two remaining options for updating your VDP firmware.  Please note that neither of these options are recommended, and you should only use them as a last resort.</p> <p>Both of these options require that your Agon is connected to your PC using a USB data cable.</p>"},{"location":"Updating-Firmware/#using-platformio","title":"Using PlatformIO","text":"<p>The Agon VDP firmware can be built from its source code using the PlatformIO IDE extension to Microsoft Visual Studio Code.  This approach is how the firmware is developed, and built for release.</p> <p>You will need to download the source code, either by cloning the repository using <code>git</code>, or by downloading the source code as a ZIP file and extracting it.  When you open up the source code in Visual Studio Code then from the PlatformIO extension under \"Project Tasks &gt; esp32dev &gt; General\" you can select \"Upload\" to build and upload the firmware to your Agon.</p> <p>If you are not comfortable with using developer tools this is probably not the best option for you.</p>"},{"location":"Updating-Firmware/#using-other-tools","title":"Using other tools","text":"<p>Guidance on using other tools can be found here.</p> <p>In general these tools are not recommended for use by end users, as they are not very user friendly.</p>"},{"location":"Updating-Firmware/#recovery","title":"Recovery","text":"<p>Usually updating your Agon firmware will go smoothly, and you will not have any problems.</p> <p>The process of updating the VDP firmware is designed to be as simple and robust as possible, and is designed to be able to recover from all problems.  The VDP actually keeps two copies of its firmware installed, and so in the rare event that something does go wrong when updating the VDP firmware the VDP simply won't switch to the new firmware.  This means that you can safely update your Agon without worrying.  In the incredibly rare event that this does not work then the online Agon VDP installer can be used to install the latest VDP firmware.</p> <p>It is not possible to make the upgrade process for MOS quite as robust, as it cannot keep two copies of the firmware installed.  There is however an Agon recovery utility available.</p> <p>Full guidance on using the recovery utility is found here.</p> <p>The guidance will let you know that if you have an Agon Light, Agon Light 2, or Agon Light Origins Edition, then as well as connecting your Agon to your PC via a USB data cable you will also need two dupont female-to-female cables to make some connections between the ports on your Agon.  The whole process including which connections to make are clearly described.</p> <p>If you have an Agon Console8 then recovery is a little more complex.  You will need an external ESP32 to perform the recovery.  Most ESP32 devkits will do fine for this purpose (there are lots of options, are widely available, and can be bought for less than $5 on AliExpress), or if you have another Agon Light system available that can also be used as a programmer for the Agon Console8.  The recovery process is a little more complex, but is still well documented.</p>"},{"location":"Updating-Firmware/#getting-help","title":"Getting help","text":"<p>If you have any problems with updating your Agon firmware, or if you have any questions, please feel free to ask for help in the Agon &amp; Console8 Community Discord server.</p>"},{"location":"VDP/","title":"What is the VDP","text":"<p>The VDP is the Agon's Visual Display Processor. It is responsible for:</p> <ul> <li>Video output via the VGA connector</li> <li>Audio output via the built-in buzzer and audio jack</li> <li>Keyboard input via a PS/2 connector</li> <li>Mouse input via a PS/2 connector (on the Agon Console8, or with an adapter on the Agon Light)</li> </ul> <p>It runs on the ESP32-Pico-D4 co-processor and uses a fork of the FabGL library (known as vdp-gl) to support those functions.</p> <p>At a higher level, its input is a byte stream from the eZ80F92 main CPU over an internal high-speed UART connection @ 1,152,000 baud (384,000 baud for versions of MOS/VDP prior to 1.03). This stream contains a mixture of text and control characters. These control characters are mapped to the BBC BASIC VDU control characters, a choice made as BBC BASIC for Agon is the pre-installed programming language of Agon.  As a result, we refer to the commands that the VDP understands as VDU commands.</p> <p>The ESP32 also outputs data back to the eZ80F92, for example keyboard data and screen information via a custom serial protocol.</p>"},{"location":"VDP/#executing-a-vdu-sequence","title":"Executing a VDU sequence","text":""},{"location":"VDP/#from-bbc-basic","title":"From BBC BASIC","text":"<p>The <code>VDU</code> statement in BBC BASIC essentially just means \"send this data to the VDP\".  It will accept any number of integer arguments between 0 and 255, separated by commas.  If a value is immediately followed by a semicolon <code>;</code> instead of a comma then the value is a little-endian word from 0 to 65535.</p> <p>Example:</p> <p><code>VDU 25, 69, 640; 512;</code>: Plot a dot in the center of the screen</p> <p><code>VDU 65</code>: Print the letter \"A\", without a newline</p> <p>A single <code>VDU</code> statement in BASIC can potentially contain multiple commands for the VDP to interpret, or a VDU command could instead be split across multiple <code>VDU</code> statements.  Other BASIC keywords that generate screen output are effectively just wrappers for VDU command sequences.</p> <p>For example, the following code snippets are all directly equivalent, and result in an identical command stream being sent to the VDP:</p> <p><pre><code>PLOT 69, 640, 512\nPRINT \"A\";\n</code></pre> <pre><code>VDU 25, 69, 640; 512; 65\n</code></pre> <pre><code>VDU 25\nVDU 69\nVDU 640; 512;\nVDU ASC(\"A\")\n</code></pre> <pre><code>VDU 25, 69, 128, 2, 0, 2, 65\n</code></pre></p>"},{"location":"VDP/#from-mos-command-line-version-103-or-greater","title":"From MOS command line (Version 1.03 or greater)","text":"<p>MOS also supports a VDU command which can be used to send VDU commands to the VDP.  This is useful for testing the VDP without having to write a BASIC program.  Its command is simpler than the BASIC equivalent, accepting only 8-bit integer values between 0 and 255, separated by spaces.</p> <p>Example:</p> <p><code>VDU 17 15</code>: Set the text foreground colour to 15</p> <p>As of MOS 2.2.0, the <code>VDU</code> command is now more sophisticated and can support sending 16-bit values as well as 8-bit values.  More information can be found in the MOS documentation.</p>"},{"location":"VDP/#from-assembly-code-on-mos","title":"From Assembly code on MOS","text":"<p>MOS offers two ways to send VDU commands from assembly code.  The first is to use the <code>RST 10h</code> call, which will send the byte in the A register to the VDP.  The second is to use a <code>RST 18h</code> call which is used to send multiple bytes to the VDP at once.  (Neither of these calls require the string <code>VDU</code> to be included in the data sent to the VDP, and both require raw binary values to be sent, rather than an ASCII string.)</p> <p>More information about these can be found in the MOS API documentation.</p>"},{"location":"VDP/#vdu-character-sequences","title":"VDU Character Sequences","text":"<p>The aim is that the Agon's VDP should be as compatible as practical with the BBC Micro's VDU command, as well as the VDU commands supported by later versions of Acorn and R.T.Russell's BBC BASICs.  Where necessary, some extensions have been added to help facilitate the Agon's unique features and architecture.</p> <p>For a more detailed description of VDU commands supported by the Agon's VDP, see VDU Commands.</p> <p>The following is a high-level list of the VDU sequences that are supported:</p> <ul> <li><code>VDU 0</code>: Null (no operation)</li> <li><code>VDU 1</code>: Send next character to \"printer\" (if \"printer\" is enabled) \u00a7\u00a7</li> <li><code>VDU 2</code>: Enable \"printer\" \u00a7\u00a7</li> <li><code>VDU 3</code>: Disable \"printer\" \u00a7\u00a7</li> <li><code>VDU 4</code>: Write text at text cursor</li> <li><code>VDU 5</code>: Write text at graphics cursor</li> <li><code>VDU 6</code>: Enable screen (opposite of <code>VDU 21</code>) \u00a7\u00a7</li> <li><code>VDU 7</code>: Make a short beep (BEL)</li> <li><code>VDU 8</code>: Move cursor back one character</li> <li><code>VDU 9</code>: Move cursor forward one character</li> <li><code>VDU 10</code>: Move cursor down one line</li> <li><code>VDU 11</code>: Move cursor up one line</li> <li><code>VDU 12</code>: Clear text area (<code>CLS</code>)</li> <li><code>VDU 13</code>: Carriage return</li> <li><code>VDU 14</code>: Page mode On *</li> <li><code>VDU 15</code>: Page mode Off *</li> <li><code>VDU 16</code>: Clear graphics area (<code>CLG</code>)</li> <li><code>VDU 17, colour</code>: Define text colour (<code>COLOUR</code>)</li> <li><code>VDU 18, mode, colour</code>: Define graphics colour (<code>GCOL mode, colour</code>)</li> <li><code>VDU 19, l, p, r, g, b</code>: Define logical colour (<code>COLOUR l, p</code> / <code>COLOUR l, r, g, b</code>)</li> <li><code>VDU 20</code>: Reset palette and text/graphics colours and drawing modes \u00a7\u00a7</li> <li><code>VDU 21</code>: Disable screen (turns of VDU command processing, except for <code>VDU 1</code> and <code>VDU 6</code>) \u00a7\u00a7</li> <li><code>VDU 22, n</code>: Select screen mode (<code>MODE n</code>)</li> <li><code>VDU 23, n</code>: Re-program display character / System Commands</li> <li><code>VDU 24, left; bottom; right; top;</code>: Set graphics viewport **</li> <li><code>VDU 25, mode, x; y;</code>: PLOT command</li> <li><code>VDU 26</code>: Reset graphics and text viewports **</li> <li><code>VDU 27, char</code>: Output character to screen \u00a7</li> <li><code>VDU 28, left, bottom, right, top</code>: Set text viewport **</li> <li><code>VDU 29, x; y;</code>: Set graphics origin</li> <li><code>VDU 30</code>: Home cursor</li> <li><code>VDU 31, x, y</code>: Move text cursor to x, y text position (<code>TAB(x, y)</code>)</li> <li><code>VDU 127</code>: Backspace</li> </ul> <p>All other characters, i.e. those in the range of 32 to 126 and 128 to 255, are sent to the screen as ASCII, unaltered.</p> <p>Any VDU command that is the VDP does not recognise (such as <code>VDU 2</code> when running on Quark 1.04) will be ignored.</p> <p>* Requires VDP 1.03 or above  ** Requires VDP 1.04 or above  \u00a7 Requires Console8 VDP 2.3.0 or above  \u00a7\u00a7 Requires Console8 VDP 2.5.0 or above</p>"},{"location":"VDP/#vdu-23-commands","title":"VDU 23 commands","text":"<p><code>VDU 23</code> essentially has a split purpose.  The first is to redefine the system font display characters, and the second is to send commands to the VDP to control and access more sophisticated behaviour.</p> <p>For more information on these commands and a full list, please consult the <code>VDU 23</code> section of the VDU Commands document.  This includes the Bitmap and Sprite API.</p> <p>Amongst this you will also find system commands, which start with <code>VDU 23, 0</code>, most of which are unique to the Agon platform.  Within the system commands set you will find the Audio API, Buffered Commands API, Font API, and Context Management API.</p>"},{"location":"mos/API/","title":"What is the MOS API","text":"<p>The MOS API can be used by external applications to access MOS functionality.</p> <p>Please note that this documentation uses assembler in the examples in a format that is compatible with the Zilog ZDS II assembler.  The assembler syntax used in BBC BASIC is similar, but not identical.  Additionally you will need to use the new ADL version of BBC BASIC to use the new eZ80 ADL mode and extended instruction set.</p> <p>This documentation is not intended as a tutorial on eZ80 assembler, but as a reference for those who are already familiar with the eZ80 or Z80 instruction set and wish to use MOS APIs in their programs.</p>"},{"location":"mos/API/#rst","title":"Usage from Z80 assembler","text":"<p>There are four RST instructions for accessing MOS functionality from Z80.</p> <ul> <li><code>RST 00h</code>: Reset the eZ80</li> <li><code>RST 08h</code>: Execute a MOS command</li> <li><code>RST 10h</code>: Output a single character to the VDP</li> <li><code>RST 18h</code>: Output a stream of characters to the VDP (MOS 1.03 or above)</li> <li><code>RST 38h</code>: Outputs a crash report (MOS 2.3.0 or above)</li> </ul> <p>In addition, if you are using the Zilog ZDS II assembler you may wish to include the file <code>mos_api.inc</code> in your project.  The latest Agon Platform (previously known as Console8) version can be found in the folder src of project agon-mos.  The original Quark versions of this file can be found in the folder src of project agon-mos.</p> <p>NB:</p> <ul> <li>Using the <code>RST.LIS</code> opcode in an eZ80 assembler will ensure the MOS <code>RST</code> instructions are called regardless of the eZ80s current addressing mode<ul> <li>The Agon MOS RST handlers are written with the assumption that they have been called using <code>RST.LIS</code></li> <li>Programs written to run in Z80 mode, using only plain Z80 opcodes, would therefore need to set up their own RST handlers to call through to to MOS using <code>RST.LIS</code></li> </ul> </li> <li>This documentation generally uses the term <code>RST</code> in place of <code>RST.LIS</code> for simplicity</li> <li>In the <code>mos_api.inc</code> file you will find:<ul> <li>EQUs for all the MOS commands, data structures and system state variables (sysvars)</li> <li>An incomplete list of VDP control variables.  For a full list, see the VDP documentation</li> <li>A complete list FatFS APIs, however it should be noted that many these are not implemented in MOS prior to MOS 3.0</li> </ul> </li> </ul> <p>Further information on the <code>RST</code> handlers provided by MOS are as follows:</p>"},{"location":"mos/API/#rst-08h-execute-a-mos-command","title":"<code>RST 08h</code>: Execute a MOS command","text":"<p>Parameters:</p> <ul> <li><code>A</code>: MOS command number to execute</li> </ul> <p>NB:</p> <ul> <li>There is a macro in <code>mos_api.inc</code> with EQUs for all the MOS commands</li> <li>Other MOS-command dependant parameters may be required</li> </ul> <p>Macro:</p> <pre><code>;\n; Macro for calling the API\n; Parameters:\n; - `F`unction: One of the function numbers listed above\n;\nMOSCALL:    MACRO   function\n            LD  A, function\n            RST.LIS 08h\n            ENDMACRO\n</code></pre> <p>Example:</p> <pre><code>; OSRDCH: Read a character in from the ESP32 keyboard handler\n;\nOSRDCH: MOSCALL mos_getkey\n        OR  A\n        JR  Z, OSRDCH       ; Loop until key is pressed\n        RET\n</code></pre>"},{"location":"mos/API/#rst-10h-output-a-single-character-to-the-vdp","title":"<code>RST 10h</code>: Output a single character to the VDP","text":"<p>Parameters:</p> <ul> <li><code>A</code>: Character to output</li> </ul> <p>Example:</p> <pre><code>; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS\n; A: Character to write\n;\nOSWRCH: RST.LIS 10h         ; This calls a RST in the eZ80 address space\n        RET\n</code></pre>"},{"location":"mos/API/#rst-18h-output-a-stream-of-characters-to-the-vdp-mos-103-or-above","title":"<code>RST 18h</code>: Output a stream of characters to the VDP (MOS 1.03 or above)","text":"<p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of the data stream (16-bit for Z80 mode, 24-bit for ADL mode)</li> <li><code>BC</code>: Length of stream (or 0 if the stream is delimited)</li> <li><code>A</code>: Stream delimiter (if <code>BC</code>=0)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Last character displayed (length mode) OR Delimiter (delimiter mode)</li> <li><code>BC</code>: 0</li> <li><code>HL(U)</code>: Address of last character displayed + 1 (length mode) OR location of delimiter (delimiter mode)</li> <li><code>E</code>: Value of <code>A</code> upon entry</li> </ul> <p>Example:</p> <pre><code>; Write a stream of characters to the VDP\n; HLU: Address of buffer containing data - if in 16-bit segment, U will be replaced by MB\n;  BC: Number of characters to write out, or 0 if the data is delimited\n;   A: End of data delimiter, i.e. 0 for C strings\n;\n        LD  HL, text        ; Address of text\n        LD  BC, 0           ; Set to 0, so length ignored...\n        LD  A, 0            ; Use character in A as delimiter\n        RST.LIS 18h         ; This calls a RST in the eZ80 address space\n        RET\n;\ntext:   DB  \"Hello World\", 0\n</code></pre>"},{"location":"mos/API/#rst-38h-outputs-a-crash-report-mos-230-or-above","title":"<code>RST 38h</code>: Outputs a crash report (MOS 2.3.0 or above)","text":"<p>This command will output a crash report to the screen.  This report will show the current processor state, and the top of the stack.  This can be useful for debugging purposes.</p> <p>This command works in conjunction with the fact that as of MOS 2.3.0, on initial startup memory will be reset to contain <code>0xFF</code> bytes in every location, which equates to a <code>RST 38h</code> instruction.  This means that for many system crashes execution will end up at the <code>RST 38h</code> instruction, and a crash report will be displayed on the screen.</p>"},{"location":"mos/API/#the-mos-api","title":"The MOS API","text":"<p>MOS API calls can be executed from a classic 64K Z80 segment or whilst the eZ80 is running in 24-bit ADL mode. For classic mode, 16 bit registers are passed as pointers to the MOS commands; these are automatically promoted to 24 bit by adding the MB register to bits 16-23 of the register. When running in ADL mode, a 24-bit register will be passed, but MB must be set to <code>0</code>.</p> <p>Many, but not all, of the MOS API calls will return a status code in the <code>A</code> register.  This status code will indicate the success or failure of the operation.  If the operation was successful, the status code will be <code>0</code>.  If the operation failed, the status code will be non-zero, and will indicate the nature of the failure.  Some API calls, such as those for I2C communications or string comparisons, use different sets of status codes, which are documented in the API call's description.</p> <p>The APIs available from MOS have changed over time, and some of the APIs described are only available in later versions of MOS.  If you attempt to call an API that is not available in the version of MOS you are using the API will return the status value <code>23</code> in the <code>A</code> register to indicate it is not supported.  Please note that MOS 2.1.0 and earlier, including Quark MOS 1.04, do support detecting unknown/unsupported API calls and will produce unexpected results if you attempt to call an API that is not supported.  This is a known issue with these versions of MOS, and it is recommended to upgrade to a later version of MOS if you are using these versions.</p>"},{"location":"mos/API/#advice-on-file-handling","title":"Advice on file handling","text":"<p>As of MOS 3.0, all the MOS API calls that accept any kind of filepath string as a parameter, whether that is to a filename or a directory, will support the use of system variables and custom file paths within the string.  These will automatically be handled in native MOS file handling API calls.  This allows for more flexible and powerful file handling in your applications.</p> <p>Please note that the FatFS API calls (which named with an <code>ffs_</code> prefix) do not support this behaviour, and will only work with fully resolved file paths.  There is an API to resolve the path which can be used to convert a path with system variables into a path suitable for use with the fatfs APIs.</p> <p>In general, to read and/or write files files, it is recommended to use the MOS file APIs as these will automatically handle system variables and file paths.  MOS file APIs use a \"file handle\" to reference an open file, whereas the FatFS APIs expect a pointer to a <code>FIL</code> structure.  You can get a <code>FIL</code> structure for a MOS file handle by using the <code>mos_getfil</code> API.  This will allow you to use the FatFS APIs directly if you need to, but in most cases it is recommended to use the MOS file APIs.  It is planned that future versions of MOS (beyond 3.0) will support using the MOS file APIs to open data streams other than files, such as the serial UART, I2C devices, and the VDP connection.  This will allow you to use the same APIs to read/write data across different all data streams.</p>"},{"location":"mos/API/#a-note-on-system-variables","title":"A note on \"system variables\"","text":"<p>Please note that MOS 3.0 system variables are a distinct and different feature from system state information (sysvars).  Some older code and documentation may use the term \"system variables\" to refer to sysvars.</p>"},{"location":"mos/API/#apis-that-use-32-bit-values","title":"APIs that use 32-bit values","text":"<p>As of MOS 3.0 the standard for APIs that either require or return a 32-bit value is to pass a pointer to the value in a register.  Care should be taken to ensure that the pointer is pointing to a valid 4-byte block of memory.  There are two older APIs that date back to MOS 1.03, namely <code>mos_flseek</code> and <code>ffs_flseek</code> that used a different approach and return a 32-bit value spread across two registers, with the lower 24-bits in one register and the upper byte in a separate register.  As this is not friendly to Z80 code, MOS 3.0 has added new equivalent APIs that use the new 32-bit pointer approach.  The old APIs are still available for backwards compatibility, but it is recommended to use the new APIs where possible.</p>"},{"location":"mos/API/#core-mos-apis-and-modules","title":"Core MOS APIs, and Modules","text":"<p>A future version of MOS may support the use of modules to extend the functionality of the system.  This may include adding new APIs, commands, and functions.</p> <p>When this happens, the concept of \"Core MOS\" will be introduced.  Core MOS will be the set of APIs, commands, and functions that are guaranteed to be available to all programs.  </p> <p>The exact set of APIs and commands that Core MOS will be comprised of has yet to be determined, but for compatibility with existing programs they will definitely include all commands and APIs that were available in MOS 2.3 and earlier.  It is expected that many of the APIs added in MOS 3.0 will also be included in Core MOS, but this is not guaranteed.</p> <p>Functionality provided by modules would only be available to programs that are \"module safe\" or \"module compatible\".  Guidance on how to ensure that your program is \"module safe\" or \"module compatible\" will be provided in the MOS Modules documentation.</p>"},{"location":"mos/API/#mos-api-calls","title":"MOS API calls","text":"<p>The following MOS commands are supported:</p>"},{"location":"mos/API/#0x00-mos_getkey","title":"<code>0x00</code>: mos_getkey","text":"<p>Read a keypress from the VDP</p> <p>Parameters: None</p> <p>Returns:</p> <ul> <li><code>A</code>: The keycode of the character pressed</li> </ul> <p>NB: This is a blocking function. This routine will wait and only return once a key is pressed.</p>"},{"location":"mos/API/#0x01-mos_load","title":"<code>0x01</code>: mos_load","text":"<p>Load a file from SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of filename (zero terminated)</li> <li><code>DE(U)</code>: Address at which to load</li> <li><code>BC(U)</code>: Maximum allowed size (bytes)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>F</code>: Carry reset if no room for file, otherwise set</li> </ul>"},{"location":"mos/API/#0x02-mos_save","title":"<code>0x02</code>: mos_save","text":"<p>Save a file to SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of filename (zero terminated)</li> <li><code>DE(U)</code>: Address to save from</li> <li><code>BC(U)</code>: Number of bytes to save</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>F</code>: Carry set</li> </ul>"},{"location":"mos/API/#0x03-mos_cd","title":"<code>0x03</code>: mos_cd","text":"<p>Change current directory on the SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of directory path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x04-mos_dir","title":"<code>0x04</code>: mos_dir","text":"<p>List SD card folder contents to screen.</p> <p>This is a simple directory listing command that will list the contents of the current directory to the screen.  More advanced directory listing functionality for applications to use is available via the FatFS commands API.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of directory path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x05-mos_del","title":"<code>0x05</code>: mos_del","text":"<p>Delete a file or folder from the SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of filepath (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x06-mos_ren","title":"<code>0x06</code>: mos_ren","text":"<p>Rename a file on the SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of source filepath string (zero terminated)</li> <li><code>DE(U)</code>: Address of destination filepath string (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul> <p>As of MOS 3.0 the <code>mos_ren</code> API can support the use of wildcards in the source filepath leaf name.  This allows you to rename multiple files at once.  The destination filepath must point to a directory in this case.  Destination paths cannot include wildcards.</p>"},{"location":"mos/API/#0x07-mos_mkdir","title":"<code>0x07</code>: mos_mkdir","text":"<p>Make a folder on the SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of path (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x08-mos_sysvars","title":"<code>0x08</code>: mos_sysvars","text":"<p>Fetch a pointer to the system state variables</p> <p>NB as this returns a pointer in <code>IXU</code>, and is therefore difficult to use from C code, as of MOS 3.0 an alternative way to access the sysvars address is available via a C function obtainable from the <code>mos_getfunction</code> API.</p> <p>Parameters: None</p> <p>Returns:</p> <ul> <li><code>IXU</code>: Pointer to the MOS SysVars area (this is always 24 bit)</li> </ul>"},{"location":"mos/API/#0x09-mos_editline","title":"<code>0x09</code>: mos_editline","text":"<p>Invoke the line editor</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of the buffer</li> <li><code>BC(U)</code>: Buffer length</li> <li><code>E</code>: Flags to control editor behaviour</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Key that was used to exit the input loop (CR=13, ESC=27)</li> </ul> <p>Editor behaviour flags are as follows:</p> Bit Description 0 When set, buffer will be cleared before use 1 When set, tab-completion for MOS commands and files is enabled * 2 When set, hotkeys are disabled * 3 When set, input history will be disabled * 4-7 Reserved for future use (for future compatibility, ensure these are set to zero) <p>* Support for editor control flags was added in MOS 2.2.0.  Prior to this the only documented values for <code>E</code> were 0 and 1 to indicate whether the buffer should be cleared.</p>"},{"location":"mos/API/#0x0a-mos_fopen","title":"<code>0x0A</code>: mos_fopen","text":"<p>Get a file handle</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of filename (zero terminated)</li> <li><code>C</code>: File open mode</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: File handle, or 0 if couldn't open</li> </ul> <p>Please note that whilst this API has always been documented as requiring a zero-terminated string for the filename, this was not actually strictly true.  It actually interpreted any control character (0-31) as a termination character.  MOS 3.0.0 changed this behaviour to be a strict zero-terminated string, but it was found that several keywords in BBC BASIC (<code>OPENIN</code>, <code>OPENOUT</code> and <code>OPENUP</code>) were failing to work because they were sending a carriage-return (13) as their termination character.  MOS 3.0.1 has been changed to support control-character termination again, thus fixing compatibility with BBC BASIC.  You are, however, strongly advised to use zero-terminated strings in your code, as relying on control character termination can cause other issues.</p>"},{"location":"mos/API/#file-open-modes","title":"File open modes","text":"<p>The mode is a number that indicates rules as to how the file will be opened.  Several different modes are available, and these values can be combined using a bitwise OR operation.  The values supported are inherited from FatFS, and are as follows:</p> Mode FatFS constant Description 0x01 <code>FA_READ</code> Open file for reading 0x02 <code>FA_WRITE</code> Open file for writing.  Combine with <code>FA_READ</code> for read/write access 0x00 <code>FA_OPEN_EXISTING</code> Open file if it exists, fail if it doesn't 0x04 <code>FA_CREATE_NEW</code> Create a new file, fail if it already exists 0x08 <code>FA_CREATE_ALWAYS</code> Create a new file.  If the file already exists it will be truncated and overwritten 0x10 <code>FA_OPEN_ALWAYS</code> Open file if it exists, create it if it doesn't 0x30 <code>FA_OPEN_APPEND</code> Same as <code>FA_OPEN_ALWAYS</code>, except the read/write pointer will be set to the end of the file <p>You may note that the \"open existing\" mode has a value of zero.  Setting either, or both, of the \"create\" options will override this.</p> <p>NB: If you open the file using <code>mos_fopen</code>, you must close it using <code>mos_fclose</code>, not <code>ffs_api_fclose</code></p>"},{"location":"mos/API/#0x0b-mos_fclose","title":"<code>0x0B</code>: mos_fclose","text":"<p>Close a file handle</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle, or 0 to close all open files</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Number of files still open</li> </ul>"},{"location":"mos/API/#0x0c-mos_fgetc","title":"<code>0x0C</code>: mos_fgetc","text":"<p>Get a character from an open file</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Character read</li> <li><code>F</code>: C set if last character in file, otherwise NC (MOS 1.04 or greater)</li> </ul>"},{"location":"mos/API/#0x0d-mos_fputc","title":"<code>0x0D</code>: mos_fputc","text":"<p>Write a character to an open file</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> <li><code>B</code>: Character to write</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <p>None</p>"},{"location":"mos/API/#0x0e-mos_feof","title":"<code>0x0E</code>: mos_feof","text":"<p>Check for end of file</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: 1 if at end of file, otherwise 0</li> </ul>"},{"location":"mos/API/#0x0f-mos_geterror","title":"<code>0x0F</code>: mos_getError","text":"<p>Translates a status code into a human-readable message.</p> <p>Parameters:</p> <ul> <li><code>E</code>: The status code</li> <li><code>HL(U)</code>: Address of buffer to copy message into</li> <li><code>BC(U)</code>: Size of buffer</li> </ul> <p>Preserves: <code>DE(U)</code>, <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <p>None</p>"},{"location":"mos/API/#0x10-mos_oscli","title":"<code>0x10</code>: mos_oscli","text":"<p>Execute a MOS command</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer the the MOS command string</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul> <p>NB previously documentation for this command was incorrect, as it documented additional parameters in <code>DE(U)</code> and <code>BC(U)</code>.  These registers are not currently used.</p>"},{"location":"mos/API/#0x11-mos_copy","title":"<code>0x11</code>: mos_copy","text":"<p>Copy a file on the SD card</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of source filepath string (zero terminated)</li> <li><code>DE(U)</code>: Address of destination filepath string (zero terminated)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul> <p>NB: Requires MOS 1.03 or greater</p> <p>Please note that this API only supports copying files; it does not support copying directories.</p> <p>As of MOS 3.0, the <code>mos_copy</code> API supports the use of wildcards in the source filepath leaf name.  This allows you to copy multiple files at once.  The destination filepath must point to a directory in this case.  Destination paths cannot include wildcards.</p>"},{"location":"mos/API/#0x12-mos_getrtc","title":"<code>0x12</code>: mos_getrtc","text":"<p>Get a time string from the RTC (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a buffer to copy the string to (at least 32 bytes)</li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Length of time string</li> </ul>"},{"location":"mos/API/#0x13-mos_setrtc","title":"<code>0x13</code>: mos_setrtc","text":"<p>Set the RTC (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a 6-byte buffer with the time data in</li> </ul> <pre><code>+0: Year (offset from 1980, so 1989 is 9)\n+1: Month (1 to 12)\n+2: Day of Month (1 to 31)\n+3: Hour (0 to 23)\n+4: Minute (0 to 59)\n+5: Second (0 to 59)\n</code></pre> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <p>None</p>"},{"location":"mos/API/#0x14-mos_setintvector","title":"<code>0x14</code>: mos_setintvector","text":"<p>Set an interrupt vector (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>E</code>: Interrupt vector number to set</li> <li><code>HLU</code>: Address of new interrupt vector (24-bit pointer)</li> </ul> <p>Preserves: <code>HLU</code>, <code>DEU</code></p> <p>Returns:</p> <ul> <li><code>HL(U)</code>: Address of the previous interrupt vector (24-bit pointer)</li> </ul>"},{"location":"mos/API/#0x15-mos_uopen","title":"<code>0x15</code>: mos_uopen","text":"<p>Open UART1 (Requires MOS 1.03 or above)</p> <p>To handle the received interrupts, you will need to assign a handler to UART1's interrupt vector (0x1A).</p> <p>NB as this API uses a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, as of MOS 3.0 th underlying function this API uses is available via a C function accessible using the <code>mos_getfunction</code> API.</p> <p>Parameters:</p> <ul> <li><code>IX(U)</code>: Pointer to a UART struct</li> </ul> <pre><code>+0: Baud rate (24-bit, little endian)\n+3: Data bits (5, 6, 7 or 8)\n+4: Stop bits (1 or 2)\n+5: Parity bits (0: None, 1: Odd, 3: Even)\n+6: Flow control (0: None, 1: Hardware)\n+7: Enabled interrupts\n    - Bit 0: Set to enable received data interrupt\n    - Bit 1: Set to enable transmit data interrupt\n    - Bit 2: Set to enable line status change interrupt\n    - Bit 3: Set to enable modem status change interrupt\n    - Bit 4: Set to enable transmit complete interrupt\n</code></pre> <p>Preserves: <code>HL(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Error code (always 0)</li> </ul> <p>Please note that before MOS 3.0 the return value from this API was not always <code>0</code> owing to a bug in how the return value was handled.  This has been fixed in MOS 3.0 and later.</p>"},{"location":"mos/API/#0x16-mos_uclose","title":"<code>0x16</code>: mos_uclose","text":"<p>Close UART1 (Requires MOS 1.03 or above)</p>"},{"location":"mos/API/#0x17-mos_ugetc","title":"<code>0x17</code>: mos_ugetc","text":"<p>Read a character from UART1 (Requires MOS 1.03 or above)</p> <p>Returns:</p> <ul> <li><code>A</code>: The character read</li> <li><code>F</code>: C if successful, NC if the UART is closed</li> </ul> <p>NB: If UART1 is open, this is a blocking function which means this routine will wait and only return once a character is received.</p>"},{"location":"mos/API/#0x18-mos_uputc","title":"<code>0x18</code>: mos_uputc","text":"<p>Write a character to UART1 (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: The character to write</li> </ul> <p>Returns:</p> <ul> <li><code>F</code>: C if successful, NC if the UART is closed</li> </ul>"},{"location":"mos/API/#0x19-mos_getfil","title":"<code>0x19</code>: mos_getfil","text":"<p>Get a pointer to a <code>FIL</code> structure in MOS (Requires MOS 1.03 or above)</p> <p>This call is useful if you wish to use the FatFS API directly, but need to pass a <code>FIL</code> structure to a FatFS API call.</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> </ul> <p>Preserves: <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>HLU</code>: 24-bit pointer to a <code>FIL</code> structure (in MOS RAM)</li> </ul>"},{"location":"mos/API/#0x1a-mos_fread","title":"<code>0x1A</code>: mos_fread","text":"<p>Read a block of data from a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> <li><code>HLU</code>: Pointer to a buffer to read the data into</li> <li><code>DEU</code>: Number of bytes to read</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>DEU</code>: Number of bytes read</li> </ul>"},{"location":"mos/API/#0x1b-mos_fwrite","title":"<code>0x1B</code>: mos_fwrite","text":"<p>Write a block of data to a file (Requires MOS 1.03 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> <li><code>HLU</code>: Pointer to a buffer that contains the data to write</li> <li><code>DEU</code>: Number of bytes to write out</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>DEU</code>: Number of bytes written</li> </ul>"},{"location":"mos/API/#0x1c-mos_flseek","title":"<code>0x1C</code>: mos_flseek","text":"<p>Move the read/write pointer in a file (Requires MOS 1.03 or above)</p> <p>NB this API is deprecated and kept for compatibility reasons.  You are advised to use the <code>mos_flseek_p</code> API instead.  As this API requires a full 24-bit value to be provided in the <code>HLU</code> register it is not directly compatible with programs written to run in Z80 mode.</p> <p>This API can be used to expand the size of a file, although you should note that the file data in the expanded part will be undefined.</p> <p>Please note that on MOS releases prior to MOS 3.0, the status code returned in the <code>A</code> register will be incorrect.</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> <li><code>HLU</code>: Least significant 3 bytes of the offset from the start of the file</li> <li><code>E</code>: Most significant byte of the offset (set to 0 for files &lt; 16MB)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x1d-mos_setkbvector","title":"<code>0x1D</code>: mos_setkbvector","text":"<p>Allows user programs to access VDP keyboard packets without overriding the entire uart0 interrupt handler. The user program registered, will be called during the uart0 interrupt handler, being passed the address of the full VDP keyboard packet.</p> <p>Parameters:</p> <ul> <li><code>C</code>: Address length in HL (0 = 24bit, 1 = 16bit). If 1 then set the top byte of HLU (callback address) to MB (for ADL=0 callers)</li> <li><code>HL(U)</code>: Callback address of user program to register, or 0 to clear any previously registered vector</li> </ul> <p>Returns: Nothing upon registration. The user program can expect the full VDP packet address in DE(24-bit) upon entry.</p> <p>Be sure to clear the kbvector before your program exits (call mos_setkbvector again with HL=0).</p> <p>example code that registers a custom handler.</p>"},{"location":"mos/API/#0x1e-mos_getkbmap","title":"<code>0x1E</code>: mos_getkbmap","text":"<p>Fetch a pointer to the virtual keyboard map (Requires MOS 1.04 RC2 or above)</p> <p>NB as this returns a pointer in IXU, and is therefore difficult to use from C code, as of MOS 3.0 an alternative way to access the keyboard bitmap address is available via a C function obtainable from the <code>mos_getfunction</code> API.</p> <p>Parameters: None</p> <p>Returns:</p> <ul> <li><code>IXU</code>: Pointer to the keyboard bitmap (this is always 24 bit)</li> </ul>"},{"location":"mos/API/#0x1f-mos_i2c_open","title":"<code>0x1F</code>: mos_i2c_open","text":"<p>Open the I2C bus as Master (Requires MOS 1.04 RC3 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: Frequency ID (1: 57600, 2: 115200, 3: 230400)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: None</p>"},{"location":"mos/API/#0x20-mos_i2c_close","title":"<code>0x20</code>: mos_i2c_close","text":"<p>Close the I2C bus (Requires MOS 1.04 RC3 or above)</p> <p>Parameters: None</p> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns: None</p>"},{"location":"mos/API/#0x21-mos_i2c_write","title":"<code>0x21</code>: mos_i2c_write","text":"<p>Write a block of bytes to the I2C bus (Requires MOS 1.04 RC3 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: I2C Address</li> <li><code>B</code>: Number of bytes to write (maximum 32)</li> <li><code>HL(U)</code>: Pointer to a buffer to read the bytes from</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status<ul> <li><code>0</code>: OK</li> <li><code>1</code>: No response from I2C slave</li> <li><code>2</code>: Data NACK</li> <li><code>4</code>: Bus arbitration lost</li> <li><code>8</code>: Bus error</li> </ul> </li> </ul>"},{"location":"mos/API/#0x22-mos_i2c_read","title":"<code>0x22</code>: mos_i2c_read","text":"<p>Read a block of bytes from the I2C bus (Requires MOS 1.04 RC3 or above)</p> <p>Parameters:</p> <ul> <li><code>C</code>: I2C Address</li> <li><code>B</code>: Number of bytes to read (maximum 32)</li> <li><code>HL(U)</code>: Pointer to a buffer to write the bytes to</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>IX(U)</code>, <code>IY(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status<ul> <li><code>0</code>: OK</li> <li><code>1</code>: No response from I2C slave</li> <li><code>2</code>: Data NACK</li> <li><code>4</code>: Bus arbitration lost</li> <li><code>8</code>: Bus error</li> </ul> </li> </ul>"},{"location":"mos/API/#0x23-mos_unpackrtc","title":"<code>0x23</code>: mos_unpackrtc","text":"<p>Unpack the RTC (Real-Time Clock) data into a buffer (Requires MOS 3.0 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a buffer to copy the RTC data to</li> <li><code>C</code>: Flags</li> </ul> <p>The buffer should be at least 10 bytes long.</p> <p>Flags are a bit-field to enable various different options.  Currently the following bits are supported:</p> <ul> <li>bit 0 = refresh RTC sysvar before unpacking</li> <li>bit 1 = refresh RTC sysvar after unpacking</li> </ul> <p>The RTC data sysvar is updated by sending a command to the VDP to request the current time, and MOS will store the response in the RTC system state information area.  If you set bit 0, this API call will send the command to the VDP to request updated RTC data and wait for the response before unpacking the data.  When you set bit 1, the command will be sent after the data has been unpacked, and the API will return without waiting for the response.</p> <p>If you do not want to refresh the RTC data stored in MOS, set the flags to 0.  You should note that if you do this the data may be stale or, if no request has been sent to the VDP at all for RTC information, be invalid.</p> <p>NB you should not set either refresh flag if you are in the middle of sending a command to the VDP, as that will both cause the update command to not be understood by the VDP, and will cause your command to fail or produce unexpected results.</p> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <p>Data returned in the buffer at <code>HL(U)</code> will be in the following order, with 16-bit values stored in little-endian order:</p> <pre><code>    UINT16 year;\n    UINT8  month;\n    UINT8  day;\n    UINT8  dayOfWeek;\n    UINT16 dayOfYear;\n    UINT8  hour;\n    UINT8  minute;\n    UINT8  second;\n</code></pre>"},{"location":"mos/API/#0x24-mos_flseek_p","title":"<code>0x24</code>: mos_flseek_p","text":"<p>Move the read/write offset pointer in a file (Requires MOS 3.0 or above)</p> <p>This API can be used to expand the size of a file, although you should note that the file data in the expanded part will be undefined.</p> <p>Whilst the <code>mos_flseek</code> API can essentially perform the same function as this API, this is the preferred API to use for moving the current read/write pointer offset within a file.  As it accepts a pointer to the 32-bit offset value, it is compatible with both Z80-mode and ADL-mode code.</p> <p>Parameters:</p> <ul> <li><code>C</code>: File handle</li> <li><code>HL(U)</code>: Pointer to a 32-bit value for the desired new offset from the start of the file</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x28-0x2c-string-functions","title":"<code>0x28-0x2C</code>: String functions","text":"<p>API calls in this range are string manipulation functions.</p> <p>All of the API calls in this range require MOS 3.0 or above.</p>"},{"location":"mos/API/#0x28-mos_pmatch","title":"<code>0x28</code>: mos_pmatch","text":"<p>Pattern matching function, with support for various flags to control how the comparison is made.</p> <p>This exposes the pattern matching function that MOS 3.0 uses internally for matching commands and filenames.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Address of pattern (zero terminated)</li> <li><code>DE(U)</code>: Address at string to compare against pattern (zero terminated)</li> <li><code>C</code>: Flags</li> </ul> <p>The flags are a bit-field to enable various different pattern matching options</p> Bit Description 0 Case insensitive 1 Disable star (<code>*</code>) wildcard matching 2 Disable hash (<code>#</code>) wildcard matching 3 \"Dot as star\" mode (treats <code>.</code> at the end of pattern as a star, used in MOS for matching abbreviated commands) 4 \"Begins with\" mode (only matches if the string starts with the pattern) 5 \"Up to space\" mode (only matches up to the first space in the pattern) <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code> and <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status<ul> <li><code>0</code> if pattern matches</li> <li>Positive number if string does not match, and is logically sorted after the pattern</li> <li>Negative number if string does not match, and is logically sorted before the pattern</li> </ul> </li> </ul>"},{"location":"mos/API/#0x29-mos_getargument","title":"<code>0x29</code>: mos_getargument","text":"<p>Extract a (numbered) argument from a string</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to source string</li> <li><code>BC(U)</code>: Argument number</li> </ul> <p>Returns:</p> <ul> <li><code>HL(U)</code>: Address of the argument or zero if not found</li> <li><code>DE(U)</code>: Address of the argument end (next character after the argument)</li> </ul> <p>Preserves: <code>BC(U)</code></p>"},{"location":"mos/API/#0x2a-mos_extractstring","title":"<code>0x2A</code>: mos_extractstring","text":"<p>Extract a string, using a given divider.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated source string to extract from</li> <li><code>DE(U)</code>: Pointer to string for divider matching, or <code>0</code> for default (space)</li> <li><code>C</code>: Flags. Depending on flags, the result string will be zero terminated or not</li> </ul> <p>The flags are a bit-field to enable various different options</p> Bit Description 0 Zero terminate the result string 1 Omit skipping of divider characters at beginning of source string 2 Disable matching of double-quotes 3 Include double-quotes in results string <p>If string extraction is matching double-quotes and an end quote is not found, a status code of <code>25</code> (Bad string) will be returned.  If it is not possible to extract a result, a status code of <code>19</code> (Invalid parameter) will be returned.</p> <p>Returns:</p> <ul> <li><code>A</code>: status code (<code>0</code> = OK, <code>19</code> = Invalid parameter, <code>25</code> = Bad string)</li> <li><code>HL(U)</code>: Address of the result string</li> <li><code>DE(U)</code>: Address of next character after end of result string</li> </ul> <p>Preserves: <code>BC(U)</code></p>"},{"location":"mos/API/#0x2b-mos_extractnumber","title":"<code>0x2B</code>: mos_extractnumber","text":"<p>Extract a number, using given divider.  Various number formats are supported - for more information see notes on numbers interpreted by the MOS CLI</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated source string to extract from</li> <li><code>DE(U)</code>: Pointer to string for divider matching, or 0 for default (space)</li> <li><code>C</code>: Flags</li> </ul> <p>The flags are a bit-field to enable various different options</p> Bit Description 0 Decimal numbers only 1 Positive numbers only 2 Allow <code>h</code> suffix to indicate hexadecimal numbers <p>If the source string does not contain a valid number, in accordance with the flags, a status code of <code>19</code> (Invalid parameter) will be returned.</p> <p>Returns:</p> <ul> <li><code>A</code>: status code (<code>0</code> = OK, <code>19</code> = Invalid parameter)</li> <li><code>HL(U)</code>: Number extracted</li> <li><code>DE(U)</code>: Address of next character after end of number</li> </ul> <p>Preserves: <code>BC(U)</code></p>"},{"location":"mos/API/#0x2c-mos_escapestring","title":"<code>0x2C</code>: mos_escapestring","text":"<p>\"Escape\" a string for display, converting control characters to be pipe-prefixed</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to source string</li> <li><code>DE(U)</code>: Pointer to destination buffer (optional)</li> <li><code>BC(U)</code>: Length of destination buffer</li> </ul> <p>If no destination buffer is provided (i.e. <code>DE</code> is zero), the function will return the length of the escaped string.</p> <p>If the destination buffer is too short then a status code of <code>22</code> (Out of memory) will be returned, and as much of the source string that could be converted will be copied to the destination buffer.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>BC(U)</code>: Length of escaped string</li> </ul>"},{"location":"mos/API/#0x30-0x37-system-variables-and-string-translations","title":"<code>0x30-0x37</code>: System variables and string translations","text":"<p>API calls in this range are used for setting and reading system variables, and for performing string translations.</p> <p>All of the API calls in this range require MOS 3.0 or above.</p>"},{"location":"mos/API/#0x30-mos_setvarval","title":"<code>0x30</code>: mos_setvarval","text":"<p>Set, update, replace or remove a System Variable</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to variable name (zero-terminated string, can include wildcards)</li> <li><code>IX(U)</code>: Variable value (number, or pointer to zero-terminated string)</li> <li><code>IY(U)</code>: Pointer to variable name (0 for first call)</li> <li><code>C</code>: Variable type, or -1 (255) to delete the variable</li> </ul> <p>If the name used includes a wildcard, then the first matching variable will be set.  Subsequent calls can be made to set the next variable that matches the pattern, so long as you preserve <code>IY(U)</code> between calls.</p> <p>Variable types supported are:</p> Type Description 0 String (Will be run through GSTrans before storing) 1 Number (a 24-bit integer value) 2 Macro (A string that will be GSTrans'd each time it is used) 3 \"Expanded\" (Expression that will be evaluated before stored) 4 Literal string (GSTrans will not be called before storage) <p>NB at the time of writing the expression engine has yet to be written in MOS 3 so type 3 support is limited to either a number or a string to indicate a variable name to copy as a string type.</p> <p>If either a type of 3 or 4 is used then the variable type used for storage of the variable will be either a string or a number.</p> <p>Internally MOS also supports \"Code\" type variables, which are used for several things, such as exposing date/time information.  If such a variable variable supports being set then you can call the \"set\" functions of these variables by using the String type with a matching name.  You cannot remove a \"Code\" type variable using this function.</p> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>C</code>: Actual variable type</li> <li><code>IY(U)</code>: Pointer to actual variable name (for next call)</li> </ul> <p>Other registers will be preserved.</p>"},{"location":"mos/API/#0x31-mos_readvarval","title":"<code>0x31</code>: mos_readvarval","text":"<p>Read a variable value</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to variable name (can include wildcards)</li> <li><code>DE(U)</code>: Length of buffer to store the value</li> <li><code>IX(U)</code>: Pointer to buffer to store the value (null/0 to read length only)</li> <li><code>IY(U)</code>: Pointer to variable name (0 for first call)</li> <li><code>C</code>: Flags (3 = expand value into string - other values will be ignored)</li> </ul> <p>If the name includes a wildcard then the first matching variable will be read.  Subsequent calls can be made to read the next value that matches the pattern, so long as you preserve <code>IY(U)</code> between calls.</p> <p>Please note that whilst numeric variables are set using <code>mos_setvarval</code> by providing their value directly in a register, when reading a numeric variable the value will be returned in the buffer pointed to by <code>IX(U)</code>.  That buffer must be at least 3 bytes long, unless the \"flag\" value is set to <code>3</code>, in which case it must be large enough to contain a string representation of the number in decimal.</p> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>C</code>: Actual variable type</li> <li><code>DE(U)</code>: Length of variable value</li> <li><code>IY(U)</code>: Pointer to variable name (for next call)</li> </ul>"},{"location":"mos/API/#0x32-mos_gsinit","title":"<code>0x32</code>: mos_gsinit","text":"<p>Initialises a GSTrans operation.</p> <p>GSTrans is a process of taking a source string and translating it, replacing any variables referenced, and converting any control codes into raw control bytes.  The <code>echo</code> command in MOS is an example of a command that uses the GSTrans process, and the documentation for that command contains a more complete description of how the source string will be interpreted.</p> <p>The process of translating a string is a two-step process.  The first step is to call <code>mos_gsinit</code> to initialise the process, and the second step is to repeatedly call <code>mos_gsread</code> to actually perform the translation, fetching one character at a time until the whole string has been translated, and a zero character is read.</p> <p>Various options are available to control how the translation process operates, and these are set using the flags parameter.  By default, the translation process will continue until the end of the source string is reached.  It is possible to instead translate only up to the first space.  The process also supports detecting double-quotes to surround a string, in which case a request to terminate at a space will be ignored if the space is inside the double-quotes.  (It should be noted that the <code>echo</code> command sets this flag.)  Finally by default the process will translate characters preceeded by a <code>|</code> character as control codes, as explained in the documentation for the <code>echo</code> command.  If you wish to disable this behaviour then you can set the \"no pipe\" flag.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to source buffer to translate</li> <li><code>DE(U)</code>: Address of pointer used to store trans info</li> <li><code>C</code>: Flags</li> </ul> <p><code>DE(U)</code> must point to an address that will be used to store a (3-byte) pointer to an information block used by the GSTrans process.  It should be noted that failing to complete the GSTrans process can result in a memory leak.</p> <p>The flags are a bit-field with options to control how the translation process operates.  Their meanings are as follows:</p> Bit Description 0 Terminate at first space character in source buffer 1 No pipe (do not treat <code>|</code> as a control code) 2 Do not treat double-quotes <code>\"</code> as markers surrounding a string 3-6 Reserved for future use (for future compatibility, ensure these are set to zero) 7 No tracking (do not automatically track memory used by GSTrans) <p>It should be noted that failing to complete translation of a string will result in some memory inside MOS remaining set aside to store the GSTrans process information.  This memory will either be freed when the GSTrans process is completed, or a new call to <code>mos_gsinit</code> is made.  If the \"No tracking\" flag is set however then MOS will not track the memory being used, and it will not be freed on a subsequent call to <code>mos_gsinit</code> - you must complete the process of reading through the string to free the memory, or you will cause a memory leak inside MOS.</p> <p>In general you should not use the \"No tracking\" flag unless you have a need to perform two or more gstrans operations simultaneously.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#0x33-mos_gsread","title":"<code>0x33</code>: mos_gsread","text":"<p>Perform a GSTrans \"read\" operation.</p> <p>When the final character of the translated string has been read, this function will return a null character (<code>0</code>) to indicate the end of the string.</p> <p>Parameters:</p> <ul> <li><code>DE(U)</code>: Address of pointer used to store trans info (same pointer as used with gsInit)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Status code (<code>0</code> = Success, various other values may indicate an invalid GSTrans string)</li> <li><code>C</code>: Character read.  This will be <code>0</code> if the end of the string has been reached.</li> </ul>"},{"location":"mos/API/#0x34-mos_gstrans","title":"<code>0x34</code>: mos_gstrans","text":"<p>Perform a complete GSTrans operation from source into dest buffer</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to source buffer</li> <li><code>IX(U)</code>: Pointer to destination buffer (can be null to just count size)</li> <li><code>DE(U)</code>: Length of destination buffer</li> <li><code>C</code>: Flags</li> </ul> <p>If the destination buffer given for this command is less than the size required for the translated string, then the API call will succeed, but the translated string will be truncated to fit in the buffer.</p> <p>The flags here are identical those used with <code>mos_gsinit</code>, with the exception that the \"No tracking\" flag will be ignored.</p> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>BC(U)</code>: Calculated total length of translated string</li> </ul>"},{"location":"mos/API/#0x35-mos_substituteargs","title":"<code>0x35</code>: mos_substituteargs","text":"<p>Substitute arguments into a string from template</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to template string</li> <li><code>IX(U)</code>: Pointer to arguments string</li> <li><code>DE(U)</code>: Length of destination buffer</li> <li><code>IY(U)</code>: Pointer to destination buffer (can be null to just count size)</li> <li><code>C</code>: Flags</li> </ul> <p>The only flag currently supported is bit 0, which when set indicates that the \"rest\" arguments (i.e. those not explicitly used in the template) should be omitted from the destination string.  When this bit is clear they will be automatically appended.</p> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>BC(U)</code>: Calculated length of destination string</li> </ul>"},{"location":"mos/API/#0x36-mos_evaluateexpression","title":"<code>0x36</code>: mos_evaluateexpression","text":"<p>As of MOS 3.0 this function has not yet been implemented.  Support for this function is planned for a future release.</p>"},{"location":"mos/API/#0x38-0x3c-file-path-functions","title":"<code>0x38-0x3C</code>: File path functions","text":"<p>These APIs provide a set of functions for working with and manipulating file paths.</p> <p>All of the API calls in this range require MOS 3.0 or above.</p>"},{"location":"mos/API/#0x38-mos_resolvepath","title":"<code>0x38</code>: mos_resolvepath","text":"<p>Resolves a path, creating a new resolved path string that expands system variables, and also replaces prefixes and leafnames with actual values.  System variables will be expanded first, and then the prefix and leafname will be resolved.  The result is a fully resolved path that can be used with the FatFS API calls.</p> <p>If the leafname contains wildcards then the first matching file will be returned.  Please note that this will be the first match found in a directory, and owing to how directories are managed this may not be the first alphabetical match.  Subsequent calls can be made to find the next matching file, so long as you provide a pointer to an empty directory object to persist between calls, and preserve the <code>C</code> register between calls too.</p> <p>NB path resolution does not support resolving paths that contain wildcards in the directory part of the path.  If you need to do this then you should gradually build the path up by calling <code>mos_resolvepath</code> multiple times to resolve the path up to each wildcard, using flags to filter for results that are a directory matching the wildcard until the directory part of the path is fully resolved.  You can then call <code>mos_resolvepath</code> again with different flags to resolve the leafname part of the path.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to the path to resolve (zero terminated)</li> <li><code>IX(U)</code>: Pointer to destination buffer to store the resolved path (optional - set to zero for length count only)</li> <li><code>DE(U)</code>: Length of the destination buffer</li> <li><code>IY(U)</code>: Pointer to a directory object to persist between calls (optional, set to zero to omit)</li> <li><code>B</code>: Flags</li> <li><code>C</code>: Index of the resolved path (zero for first call)</li> </ul> <p>Path resolution will resolve prefixes in files paths, which are a string followed by a colon character, such as <code>Library:</code>.  The string must match up with a corresponding system variable, in this example the variable would be named <code>Library$Path</code>.  Prefixes are not case-sensitive, so <code>library:</code>, <code>Library:</code> and <code>LIBRARY:</code> would all match in this example.  Such path variables can contain multiple values separated by commas.  The \"index\" argument in the <code>C</code> register is used to work out which prefix to use when there are multiple matches, and must be set to zero on a first call.</p> <p>If you are resolving for a file that does not exist, the path will be resolved to the first matching directory, returning a \"no file\" (<code>4</code> status code).  If no matching directory can be found the path will not be resolved, and a \"no path\" (<code>5</code> status code) will be returned, and the returned path will be empty.  If the path is resolved successfully to an existing file the status code will be <code>0</code>.</p> <p>The <code>flags</code> argument is a bit-field used to indicate which files are valid to be returned.  These bits are used to filter the results based on the file attributes, which are inherited from the file system (FatFS).  If you wish to always return all results you should set the flags to <code>0</code>.  The bits are as follows:</p> Bit FatFS constant Description 0 <code>AM_RDO</code> Read only 1 <code>AM_HID</code> Hidden 2 <code>AM_SYS</code> System 3 n/a Reserved/Unused - set to zero 4 <code>AM_DIR</code> Directory 5 <code>AM_ARC</code> Archive 6 n/a Set to disable system variable expansion 7 n/a Include/exclude in results <p>System variable expansion passes the source path through the GSTrans process, replacing any system variables used in the path with their values.  If you have already performed this step then you can set bit 6 to disable the expansion.</p> <p>Bit 7 is used to indicate how to apply the attributes to filter results.  When it is set, any result must include all of the attributes set.  When it is clear, the result will not include any of the attributes set.  This can be used, for example, to filter out hidden or system files, or alternatively to only include results that are directories.</p> <p>NB any attributes that are not set in the <code>flags</code> argument will be ignored, so if you perform a search with a flags value of <code>0x06</code>, which will filter out hidden and system files, your results may include items that have their directory, read-only, and/or archive bits set.  Similarly a search with a flags value of <code>0x90</code> will only include directories, but those directories could have any of the other attributes set.</p> <p>If you wish to further filter results you should pass in a <code>DIR</code> object in <code>IY(U)</code> to persist between calls, and use the <code>ffs_stat</code> API call to get a <code>FILINFO</code> object where you can check the full attributes of the the returned result (stored in the <code>fattrib</code> field).  If the results do not match your requirements you can then call <code>mos_resolvepath</code> again to find the next matching file.</p> <p>If the leafname in your path contains wildcards then the first matching file will be returned.  If you wish to find the next matching file then you should provide a pointer to an empty directory object in <code>IY(U)</code> with your first call, and use the same object with subsequent calls (also using the same <code>C</code> register value).  If you do not include a pointer to a directory object then only the first matching file within a single directory will be returned.</p> <p>Besides finding filecard matches, the other main use for this API is to resolve a path so that it can be used with FatFS API calls.  This step is needed to ensure that the path is fully resolved, as the FatFS API calls do not support using path prefixes or system variables.  Attempting to use an unresolved path with a fatfs API call may either fail or produce unexpected results.</p> <p>It is not necessary to use this API call to resolve paths for use with the MOS-native API calls, as those will all automatically resolve paths for you.</p> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code (<code>0</code> = Success, <code>22</code> = Out of memory, <code>5</code> = No path, <code>4</code> = No file)</li> <li><code>C</code>: Index of the resolved path (for next call)</li> <li><code>DE(U)</code>: Length of the resolved path</li> </ul> <p>If this is called with a null pointer in <code>IX(U)</code> then the maximum possible length of of all possible resolved paths will be returned in <code>DE(U)</code>.  This is useful if you wish to allocate a buffer for the resolved path, but do not know how long it will be.</p> <p>A result of <code>5</code> indicates that no matching directory could be found in the filing system.  A result of <code>4</code> indicates that a matching directory was found, but no matching file for that directory.</p> <p>A result of <code>22</code> indicates that either the resolved path was too long for the buffer provided, or that there was an error allocating memory whilst searching for a matching path.</p>"},{"location":"mos/API/#0x39-mos_getdirforpath","title":"<code>0x39</code>: mos_getdirforpath","text":"<p>Get the directory for a given path.</p> <p>This function works with strings only - it resolves path prefixes for the given index, but does not check whether the path actually points to a valid file or directory.  The index is used which prefix to use when the path prefix variable contains multiple options.</p> <p>The returned path will be the directory part of the path, and will not include the leafname.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to the path to get the directory for</li> <li><code>IX(U)</code>: Pointer to the buffer to store the directory in (optional - omit for count only)</li> <li><code>DE(U)</code>: Length of the buffer</li> <li><code>C</code>: Search index</li> </ul> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> <li><code>DE(U)</code>: Length of the directory path</li> </ul>"},{"location":"mos/API/#0x3a-mos_getleafname","title":"<code>0x3A</code>: mos_getleafname","text":"<p>Get the leafname for a given path.</p> <p>This is a utility function that will scan a file path string and return a pointer within that string to the leafname.  The leafname is the last part of a file path, and may refer to a file or a directory.  This call does not check whether the path actually points to a valid file or directory, and it does not resolve any path prefixes.  It should be noted that a leafname may be empty if the path is empty or ends with a <code>/</code> or <code>:</code> character.</p> <p>If the path does not contain a valid leafname then the function will return a pointer to the end of the string.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to the path to get the leafname from</li> </ul> <p>Returns:</p> <ul> <li><code>HL(U)</code>: Pointer to the leafname</li> </ul>"},{"location":"mos/API/#0x3b-mos_isdirectory","title":"<code>0x3B</code>: mos_isdirectory","text":"<p>Checks if a given path points to a directory</p> <p>NB this call only works with fully resolved paths, and as such does not perform path prefix resolution.  You may therefore need to use <code>mos_getdirforpath</code> or <code>mos_resolvepath</code> first.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to the path to check</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Status code (<code>0</code> = Success, <code>5</code> = No path)</li> </ul>"},{"location":"mos/API/#0x3c-mos_getabsolutepath","title":"<code>0x3C</code>: mos_getabsolutepath","text":"<p>Get the absolute version of a (relative) path</p> <p>NB currently as of MOS 3.0, unlike similar API calls above, this API does not support being called with a null pointer to count the length of the resolved path, and does not return the length.  If called with a null pointer from ADL mode, the API will return a status code of <code>19</code> (Invalid parameter).  Calling with a null pointer from Z80 mode code is not currently supported/checked and may cause unexpected results or crashes.  This will likely change in a future MOS release.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to the path to get the absolute version of</li> <li><code>IX(U)</code>: Pointer to the buffer to store the absolute path in</li> <li><code>DE(U)</code>: Length of the buffer</li> </ul> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul> <p>If the buffer is too short for the resolved path then a status code of <code>22</code> (Out of memory) will be returned.  Path resolution problems may result in status codes of <code>5</code> (No path) or <code>4</code> (No file).</p>"},{"location":"mos/API/#0x40-0x50-vdp-protocol-and-miscellaneous-functions","title":"<code>0x40-0x50</code>: VDP protocol, and miscellaneous functions","text":"<p>Functions in this range are used for VDP protocol, and other miscellaneous functions.</p> <p>All of the API calls in this range require MOS 3.0 or above.</p>"},{"location":"mos/API/#0x40-mos_clearvdpflags","title":"<code>0x40</code>: mos_clearvdpflags","text":"<p>Clears VDP Protocol status flags from the <code>sysvar_vpd_pflags</code> sysvar.</p> <p>Bits in this status value will be set when various different VDP Protocol message packet types are received by MOS from the VDP.  Such packets may be sent for user-initiated actions, such as pressing a key on the keyboard, or moving the mouse, or for system-initiated actions, such as a VDU command being sent to the VDP.  Please note that in general use these bits are not automatically cleared, so if you wish to detect a response from the VDP to a VDU command your program sends it is important to clear out the corresponding protocol flags before sending the command.  You can then use the <code>mos_waitforvdpflags</code> API call to wait for the VDP to respond, and check the status of the flags in <code>sysvar_vpd_pflags</code> to see if the command was successful.</p> <p>Further information on the VDP protocol and the flag bits can be found in the VDP Protocol documentation.</p> <p>Parameters:</p> <ul> <li><code>C</code>: Bitmask of flags to clear</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: New VDP flags</li> </ul>"},{"location":"mos/API/#0x41-mos_waitforvdpflags","title":"<code>0x41</code>: mos_waitforvdpflags","text":"<p>Waits for corresponding VDP protocol flags to be set in the <code>sysvar_vpd_pflags</code> sysvar.</p> <p>Typically your program should first clear whichever protocol flag you are interested in detecting, using the <code>mos_clearvdpflags</code> API call.  Once you have done that, you should send a VDU command to the VDP for which you are expecting a response, and then use this API call to wait for that response to be received.</p> <p>MOS contains inbuilt support for handling VDP protocol messages.  Typically on receipt of a message a flag will be set in the <code>sysvar_vpd_pflags</code> variable, and also other corresponding sysvars will be updated from the contents of the message.</p> <p>This API call will wait for approximately 1 second for the VDP to respond, which should be more than enough time for any VDU command to be processed.  If the VDP does not respond within this time, the API call will return with a status code of <code>15</code> (Timeout).  If the VDP does respond, the API call will return with a status code of <code>0</code> (Success).</p> <p>Parameters:</p> <ul> <li><code>C</code>: Bitmask of flags to wait for</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Status code (<code>0</code> = Success, <code>15</code> = Timeout)</li> </ul>"},{"location":"mos/API/#0x50-mos_getfunction","title":"<code>0x50</code>: mos_getfunction","text":"<p>This API call will return a pointer to a function that follows the Zilog eZ80 C calling convention.  As these are 24-bit pointers, and passing arguments needs to be done using the 24-bit stack pointer (<code>SPL</code>), this API call is not usable by programs running in Z80 mode.</p> <p>Information on the C calling convention can be found here</p> <p>Parameters:</p> <ul> <li><code>C</code>: Flags (must be <code>0</code> in MOS 3.0)</li> <li><code>B</code>: Function number</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Status code (<code>0</code> = Success, <code>19</code> = Invalid parameter, <code>20</code> = Invalid command)</li> <li><code>HLU</code>: Pointer to function (or <code>0</code> if the request was invalid invalid)</li> </ul> <p>If this API is called from Z80 mode code, then it will return a status code of <code>20</code> (Invalid command) as this API is only supported in ADL mode.</p> <p>This API includes a flags byte which must be set to zero in MOS 3.0.  This is reserved for future use to allow for additional functionality to be added in future versions of MOS.  If flags are set to anything other than <code>0</code> then the API will return a status code of <code>19</code> (Invalid parameter).</p> <p>Similarly, if the function number passed to this API is higher than the highest available function, then the API will return a status code of <code>20</code> (Invalid command).</p> <p>Full details of the functions available through this API, and more information about how to use them, can be found in the documentation about C Functions</p>"},{"location":"mos/API/#0x70-0x73-low-level-sd-card-access","title":"<code>0x70-0x73</code>: Low-level SD card access","text":"<p>These APIs provide low-level access to the SD card.  They are not intended for general use, but are provided for some special use-cases, such as for an operating system that uses a different filing system than FatFS, or for tools that wish to access the SD card in ways that are not supported by the FatFS library.</p> <p>As the use of these APIs can potentialy cause data corruption in order to use them you need to use an \"unlock code\".  It is possible to avoid using the unlock mechanism by using the underlying functions directly via the <code>mos_getfunction</code> API call.</p> <p>All of the APIs in this range require MOS 3.0 or above.</p>"},{"location":"mos/API/#0x70-sd_getunlockcode","title":"<code>0x70</code>: sd_getunlockcode","text":"<p>This API call is used to obtain the unlock code needed to use the low-level SD card APIs.  The unlock code is a randomly generated 24-bit value, created the first time this API is called.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a 24-bit value to store the unlock code</li> </ul> <p>Returns:</p> <p>Nothing</p>"},{"location":"mos/API/#0x71-sd_init","title":"<code>0x71</code>: sd_init","text":"<p>Initialises the SD card support system.  MOS automatically calls this when it mounts an SD card.  If you are writing support for an operating system you may need to call this to restart the SD card system if the SD card is removed and reinserted.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to the unlock code (24-bit value) as fetched by the <code>sd_getunlockcode</code> API call</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Status code<ul> <li><code>0</code> = Success/Ready</li> <li><code>1</code> = Error</li> <li><code>2</code> = Locked (incorrect unlock code provided, or no lock code yet set)</li> </ul> </li> </ul>"},{"location":"mos/API/#0x72-sd_readblocks","title":"<code>0x72</code>: sd_readblocks","text":"<p>Read raw blocks from the SD card.</p> <p>Parameters: - <code>HL(U)</code>: Pointer to a 32-bit sector number, followed by the 24-bit unlock code - <code>DE(U)</code>: Pointer to a buffer to store the read data - <code>BC</code>: Number of blocks to read (16-bit value)</p> <p>Returns:</p> <ul> <li><code>A</code>: Status code<ul> <li><code>0</code> = Success/Ready</li> <li><code>1</code> = Error</li> <li><code>2</code> = Locked (incorrect unlock code provided, or no lock code yet set)</li> </ul> </li> </ul>"},{"location":"mos/API/#0x73-sd_writeblocks","title":"<code>0x73</code>: sd_writeblocks","text":"<p>Writes raw blocks to the SD card.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a 32-bit sector number, followed by the 24-bit unlock code</li> <li><code>DE(U)</code>: Pointer to a buffer containing the data to write</li> <li><code>BC</code>: Number of blocks to write (16-bit value)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: Status code<ul> <li><code>0</code> = Success/Ready</li> <li><code>1</code> = Error</li> <li><code>2</code> = Locked (incorrect unlock code provided, or no lock code yet set)</li> </ul> </li> </ul>"},{"location":"mos/API/#fatfs-commands","title":"<code>0x80-0xA6</code>: FatFS APIs","text":"<p>MOS makes use of the FatFS library to access the SD card.  Some of FatFS's functionality is exposed as APIs in MOS.  These APIs are essentially provide a way to call the underlying FatFS functions that MOS uses to perform file operations.  The API calls are prefixed with <code>ffs_</code> to indicate that they are FatFS functions, and the <code>mos_</code> prefix is used for the native MOS API calls.</p> <p>Our naming convention for FatFS APIs in MOS is to remove the <code>f_</code> prefix from the FatFS function name, and replace it with <code>ffs_</code>, plus an optionally <code>f</code> or <code>d</code> prefix.  For example, the API that exposes the <code>f_open</code> FatFS function is named <code>ffs_fopen</code>.</p> <p>The variety of FatFS APIs supported in the MOS 1.x and MOS 2.x releases was limited to a restricted subset of functionality.  The first version of MOS that supported FatFS API calls was 1.03.  Versions of MOS 2.x added support for some additional APIs.  MOS 3.0 includes support for all of the possible FatFS APIs that are practical to support with our current configuration of FatFS, which greatly expands the available set of APIs.  For completeness, all potential FatFS APIs are documented below, including those that are not supported by our current configuration.  The APIs that are not supported will return a status code of <code>23</code> (Not implemented) in the A register.</p> <p>When reading the documentation below, you should assume that the API calls are only available in MOS 3.0 or above, unless otherwise stated.</p> <p>Please note that the FatFS API calls documented below expect file paths to be fully resolved, i.e. they should not include path prefixes or system variables.  This means programs running on MOS 3 should use the <code>mos_resolvepath</code> API call to resolve any paths before using them with a FatFS API call.  If you do not resolve the path then the FatFS API call may fail or produce unexpected results.  For many API calls you can instead open the file using the MOS API call <code>mos_fopen</code> and then use <code>mos_getfil</code> to get a pointer to a <code>FIL</code> structure that many FatFS API calls require.</p> <p>For more information on FatFS data structures (the <code>FIL</code>, <code>DIR</code> and <code>FILINFO</code> objects), functions, and info on which bits to set in fields such as \"File open mode\" please see the FatFS documentation.  The FatFS configuration can affect the contents of these data structures - our configuration has the <code>FF_USE_LFN</code> and <code>FF_USE_FIND</code> options set, and does not set <code>FF_READ_ONLY</code> or <code>FF_USE_FASTSEEK</code>.</p>"},{"location":"mos/API/#0x80-ffs_fopen","title":"<code>0x80</code>: ffs_fopen","text":"<p>Open a file (Available from MOS 1.03)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to an empty <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a C (zero-terminated) filename string</li> <li><code>C</code>: File open mode</li> </ul> <p>The file open mode on this API is a bit-field that is identical to the mode used in the <code>mos_fopen</code> API call.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>C</code></p> <p>Example:</p> <pre><code>            LD  HL, fil             ; FIL buffer\n            LD  DE, filename            ; Filename (0 terminated)\n            LD  C, fa_read          ; Mode\n            MOSCALL ffs_fopen           ; Open the file\n            LD  DE, buffer          ; Where to store the read file\n            LD  BC, 256             ; Number of bytes to read\n            MOSCALL ffs_fread           ; Read the data in\n            PUSH    BC              ; Preserve number of bytes read\n            MOSCALL ffs_fclose          ; Close the file\n            POP BC              ; BC: Number of bytes read\n            RET\n\nfilename:       DB  \"example.txt\", 0        ; The file to read\n\nfil:            DS  FIL_SIZE            ; FIL buffer (defined in mos_api.inc)\nbuffer:         DS  256             ; Buffer for storing read data\n</code></pre>"},{"location":"mos/API/#0x81-ffs_fclose","title":"<code>0x81</code>: ffs_fclose","text":"<p>Close a file (Available from MOS 1.03)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code></p> <p>See <code>ffs_fopen</code> for an example.</p> <p>NB: you should not use this call to close a file that had been opened using <code>mos_fopen</code>, as doing so will mean that MOS will be reserving an file handle for a file that has been closed.</p>"},{"location":"mos/API/#0x82-ffs_fread","title":"<code>0x82</code>: ffs_fread","text":"<p>Read from a file (Available from MOS 1.03)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a buffer to store the data in</li> <li><code>BC(U)</code>: Number of bytes to read (typically the size of the buffer)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> <li><code>BC(U)</code>: Number of bytes read</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>See ffs_fopen for an example</p>"},{"location":"mos/API/#0x83-ffs_fwrite","title":"<code>0x83</code>: ffs_fwrite","text":"<p>Write to a file (Available from MOS 1.03)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a buffer to read the data from</li> <li><code>BC(U)</code>: Number of bytes to write (typically the size of the buffer)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> <li><code>BC(U)</code>: Number of bytes written</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Example:</p> <pre><code>            LD  HL, fil             ; FIL buffer\n            LD  DE, filename            ; Filename (0 terminated)\n            LD  C, fa_write | fa_create_always  ; Mode\n            MOSCALL ffs_fopen           ; Open the file\n            LD  DE, buffer          ; Location of data to write\n            LD  BC, 256             ; Number of bytes to write\n            MOSCALL ffs_write           ; Write the data\n            MOSCALL ffs_fclose          ; Close the file\n            RET\n\nfilename:   DB  \"example.txt\", 0        ; The file to read\n\nfil:        DS  FIL_SIZE            ; FIL buffer (defined in mos_api.inc)\nbuffer:     DS  256             ; Buffer containing data to write out\n</code></pre>"},{"location":"mos/API/#0x84-ffs_flseek","title":"<code>0x84</code>: ffs_flseek","text":"<p>Move the read/write pointer in a file (Available from MOS 1.03)</p> <p>NB this API is deprecated and kept for compatibility reasons.  You are advised to use the <code>ffs_flseek_p</code> API instead.  As this API requires a full 24-bit value to be provided in the <code>DE(U)</code> register it is not directly compatible with programs written to run in Z80 mode.</p> <p>This API call can also be used to expand the file size, by moving the pointer to a location beyond the current end of the file.  It should be noted that the extra allocated disk space will not be cleared, so the data in the new space will be undefined.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Least significant 3 bytes of the offset from the start of the file</li> <li><code>C</code>: Most significant byte of the offset (set to 0 for files &lt; 16MB)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code></p>"},{"location":"mos/API/#0x85-ffs_ftruncate","title":"<code>0x85</code>: ffs_ftruncate","text":"<p>Truncate a file to the current file pointer offset (Available from MOS 2.3.0)</p> <p>To truncate to a specified size you will need to use <code>ffs_flseek_p</code> to move the file pointer to the desired location before calling <code>ffs_ftruncate</code>.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x86-ffs_fsync","title":"<code>0x86</code>: ffs_fsync","text":"<p>Flushes cached information of a writing file</p> <p>When writing to a file, file data may be cached in memory until the file is closed.  This function will flush the cache to the SD card, ensuring that all data has been written.  This can be useful to minimise the risks of data loss in the event of a power failure, SD card removal, or other unexpected shutdown.</p> <p>Please note that MOS 3.0 does not currently cache writes to the SD card.  This API call is provided in case we do add caching in the future.  You may still wish to use this call to ensure that data is guaranteed to be written to the SD card in the event that a future version of MOS adds caching support.  Calling this API on systems that do not support caching will have no effect and be harmless.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul>"},{"location":"mos/API/#0x87-ffs_fforward","title":"<code>0x87</code>: ffs_fforward","text":"<p>This API is not implemented, as the FatFS <code>f_forward</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>The documented purpose of the <code>f_forward</code> function is to read file data and forward it to a \"data streaming device\" (a callback function).  It is unlikely that this feature would be enabled in the future as we do not have a clear use-case for it, and similar functionality can be achieved by other means.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0x88-ffs_fexpand","title":"<code>0x88</code>: ffs_fexpand","text":"<p>This API is not implemented, as the FatFS <code>f_expand</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>The purpose of the <code>f_expand</code> function is to expand a file allocating a contiguous data area to the file.  Files can be expanded using the <code>ffs_flseek</code> API, although this will not guarantee that the data area is contiguous.  It is unlikely that this API will be implemented in the future, as on an SD card there is little advantage to be had in allocating a contiguous data area for a file.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0x89-ffs_fgets","title":"<code>0x89</code>: ffs_fgets","text":"<p>Reads a string from a file</p> <p>Reads characters into a buffer until a newline <code>\\n</code> character is reached, the end of file encountered, or the buffer is filled.  The string read will be zero terminated.</p> <p>It should be noted that this API does not return a status code in the <code>A</code> register.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a buffer to store the string in</li> <li><code>BC(U)</code>: Buffer size</li> </ul> <p>Returns:</p> <ul> <li><code>DE(U)</code>: Pointer to the target buffer, or NULL if an error occurred</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>"},{"location":"mos/API/#0x8a-ffs_fputc","title":"<code>0x8A</code>: ffs_fputc","text":"<p>Writes a single character to a file</p> <p>It should be noted that this API does not return a status code in the <code>A</code> register.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>C</code>: Character to write</li> </ul> <p>Returns:</p> <ul> <li><code>BC(U)</code>: Number of bytes written</li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x8b-ffs_fputs","title":"<code>0x8B</code>: ffs_fputs","text":"<p>Writes a zero-terminated string to a file.  The termination character will not be written to the file.</p> <p>It should be noted that this API does not return a status code in the <code>A</code> register.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a zero-terminated string</li> </ul> <p>Returns:</p> <ul> <li><code>BC(U)</code>: Number of bytes written</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>"},{"location":"mos/API/#0x8c-ffs_fprintf","title":"<code>0x8C</code>: ffs_fprintf","text":"<p>Whilst our configuration of FatFS does support the <code>f_printf</code> function, we do not currently support it in the MOS API.  This is because the function accepts a variable number of arguments, and it is not clear how this could be implemented in a way that is consistent with the rest of the APIs that MOS supports.</p> <p>The <code>f_printf</code> function is made available via the <code>mos_getfunction</code> API call.  It can therefore be used from any (ADL mode) code that complies with the Zilog eZ80 C calling convention.  This API is not available in Z80 mode code.</p>"},{"location":"mos/API/#0x8d-ffs_ftell","title":"<code>0x8D</code>: ffs_ftell","text":"<p>Get the current read/write offset pointer of a file</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a 4-byte buffer to store the returned 32-bit offset in</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code> (<code>0</code> = Success, or <code>19</code> = Invalid parameter)</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>"},{"location":"mos/API/#0x8e-ffs_feof","title":"<code>0x8E</code>: ffs_feof","text":"<p>Detect end of file</p> <p>Please note that whilst this API has been present since MOS 1.03 its implementation had an error which meant that it would return the value of the <code>L</code> register passed in as a parameter, rather than the correct value.  This was fixed in MOS 3.0.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: 1 if at the end of the file, otherwise 0</li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x8f-ffs_fsize","title":"<code>0x8F</code>: ffs_fsize","text":"<p>Get the size of a file</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a 4-byte buffer to store the returned 32-bit file size in</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code> (<code>0</code> = Success, or <code>19</code> = Invalid parameter)</li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x90-ffs_ferror","title":"<code>0x90</code>: ffs_ferror","text":"<p>Tests for an error on a file</p> <p>Returns a non-zero value if a hard error has returned, otherwise will return a status of <code>0</code> (OK).</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x91-ffs_dopen","title":"<code>0x91</code>: ffs_dopen","text":"<p>Open a directory (Available from MOS 2.2.0)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a blank <code>DIR</code> structure</li> <li><code>DE(U)</code>: Pointer to a C (zero-terminated) directory path string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>"},{"location":"mos/API/#0x92-ffs_dclose","title":"<code>0x92</code>: ffs_dclose","text":"<p>Close a directory (Available from MOS 2.2.0)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>DIR</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x93-ffs_dread","title":"<code>0x93</code>: ffs_dread","text":"<p>Read next directory entry into a <code>FILINFO</code> data structure (Available from MOS 2.2.0)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>DIR</code> structure</li> <li><code>DE(U)</code>: Pointer to a <code>FILINFO</code> structure</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>"},{"location":"mos/API/#0x94-ffs_dfindfirst","title":"<code>0x94</code>: ffs_dfindfirst","text":"<p>Searches a directory for a matching item</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a blank <code>DIR</code> struct</li> <li><code>DE(U)</code>: Pointer to a blank <code>FILINFO</code> struct</li> <li><code>BC(U)</code>: Pointer to directory path string</li> <li><code>IX(U)</code>: Pointer to matching pattern string</li> </ul> <p>The directory path provided in <code>BC(U)</code> must be a fully resolved path, and the matching pattern in <code>IX(U)</code> should be a zero-terminated string.  The matching pattern can include wildcards, such as <code>*</code> and <code>?</code>, and will be used to match against the directory entries.  Subsequent entries can be found using <code>ffs_dfindnext</code> passing in the same <code>DIR</code> structures as passed to this call, and the pattern string must also be preserved.</p> <p>If a matching file is found, the <code>FILINFO</code> structure will be populated with information about the file.</p> <p>NB as this API requires a pointer in <code>IX(U)</code>, and is therefore difficult to use from C code, the underlying C function this API uses can be accessed using the <code>mos_getfunction</code> API.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code>, <code>BC(U)</code>, <code>IX(U)</code></p>"},{"location":"mos/API/#0x95-ffs_dfindnext","title":"<code>0x95</code>: ffs_dfindnext","text":"<p>Find next matching item in a directory</p> <p>This API call is used to find the next matching item in a directory after a successful call to <code>ffs_dfindfirst</code>.  It will return the next matching file or directory in the same way as <code>ffs_dfindfirst</code>, but will not require the path and pattern strings to be passed in again.  Please note that whilst it is not a parameter for this API, the pattern string passed to <code>ffs_dfindfirst</code> must be preserved, as it will be used to match against the directory entries.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>DIR</code> structure, as set up by <code>ffs_dfindfirst</code></li> <li><code>DE(U)</code>: Pointer to a <code>FILINFO</code> structure</li> </ul> <p>NB for completeness/convenience as the <code>ffs_dfindfirst</code> API is available as a C function via the <code>mos_getfunction</code> API, this API is also available as a C function.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>"},{"location":"mos/API/#0x96-ffs_stat","title":"<code>0x96</code>: ffs_stat","text":"<p>Get file information (Available from MOS 1.03)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FILINFO</code> structure</li> <li><code>DE(U)</code>: Pointer to a C (zero-terminated) filename string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p> <p>Example:</p> <pre><code>            LD  HL, filinfo             ; FILINFO buffer\n            LD  DE, filename            ; Filename (0 terminated)\n            MOSCALL ffs_stat\n            RET\n\nfilename:   DB  \"example.txt\", 0        ; The file to read\n\nfilinfo:    DS  FILINFO_SIZE            ; FILINFO buffer (defined in mos_api.inc)\n</code></pre>"},{"location":"mos/API/#0x97-ffs_unlink","title":"<code>0x97</code>: ffs_unlink","text":"<p>Removes (\"unlinks\") a file or sub-directory from the volume (Requires MOS 3.0 or above)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated file path string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code></p>"},{"location":"mos/API/#0x98-ffs_rename","title":"<code>0x98</code>: ffs_rename","text":"<p>Rename and/or move a file or sub-directory</p> <p>This is a raw rename function that does not perform any path resolution, and does not support wildcards.  For more sophisticated behaviour you should use the <code>mos_ren</code> API instead.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated source file path string</li> <li><code>DE(U)</code>: Pointer to a zero-terminated destination file path string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>DE(U)</code></p>"},{"location":"mos/API/#0x99-ffs_chmod","title":"<code>0x99</code>: ffs_chmod","text":"<p>This API is not implemented, as the FatFS <code>f_chmod</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>The purpose of the <code>f_chmod</code> function is to change the attributes set against a file or directory.  A future version of MOS may include support for this API.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0x9a-ffs_utime","title":"<code>0x9A</code>: ffs_utime","text":"<p>This API is not implemented, as the FatFS <code>f_utime</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>The purpose of the <code>f_utime</code> function is to change the timestamp of a file or directory.  A future version of MOS may include support for this API.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0x9b-ffs_mkdir","title":"<code>0x9B</code>: ffs_mkdir","text":"<p>Creates a new directory</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated directory name string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul>"},{"location":"mos/API/#0x9c-ffs_chdir","title":"<code>0x9C</code>: ffs_chdir","text":"<p>Change the current working directory</p> <p>It is strongly recommended to use the <code>mos_cd</code> API API call instead of this one, as it will automatically resolve the path for you.  Using this API may result in MOS not understand the current working directory until a call to <code>mos_cd</code> is made or a version of the <code>CD</code> command is run.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated directory name string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul>"},{"location":"mos/API/#0x9d-ffs_chdrive","title":"<code>0x9D</code>: ffs_chdrive","text":"<p>This API is not implemented, as no Agon platform computer currently supports multiple drives.</p>"},{"location":"mos/API/#0x9e-ffs_getcwd","title":"<code>0x9E</code>: ffs_getcwd","text":"<p>Get the current working directory (Available from MOS 2.2.0)</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a buffer to store the directory path in</li> <li><code>BC(U)</code>: Maximum length of the buffer</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p>"},{"location":"mos/API/#0x9f-ffs_mount","title":"<code>0x9F</code>: ffs_mount","text":"<p>Mounts a volume/SD card</p> <p>Whilst this API has documented parameters, as the current hardware configurations of Agon machines do not support multiple volumes or drives all of the parameters will be ignored.  They are documented here for completeness, and to allow for future expansion of the API in case a future Agon model is released that does support multiple SD cards.  For future compatibility you are advised to set all parameters to zero.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a blank FATFS <code>FATFS</code> structure (set to zero)</li> <li><code>DE(U)</code>: Pointer to a zero-terminated volume path string (set to zero)</li> <li><code>C</code>: Options byte (set to zero)</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul>"},{"location":"mos/API/#0xa0-ffs_mkfs","title":"<code>0xA0</code>: ffs_mkfs","text":"<p>This API is not implemented, as the FatFS <code>f_mkfs</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0xa1-ffs_fdisk","title":"<code>0xA1</code>: ffs_fdisk","text":"<p>This API is not implemented, as the FatFS <code>f_fdisk</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>Returns</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0xa2-ffs_getfree","title":"<code>0xA2</code>: ffs_getfree","text":"<p>Get free space information on a volume</p> <p>Please note that this call does not directly return the number of free bytes on the volume, but instead returns the number of free clusters and the size of each cluster.  The number of free bytes can be calculated by multiplying these two values together.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a path string (ideally caller should set this to zero)</li> <li><code>DE(U)</code>: Pointer to a block of memory to store number of free clusters, 32-bit value</li> <li><code>BC(U)</code>: Pointer to a block of memory to store cluster size, 32-bit value</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>Whilst this API will let you pass in a pointer to a path in the <code>HL(U)</code> register, you are recommended to set this to <code>0</code>, as the way that MOS uses FatFS means that the path is not needed, and the call will likely fail if any path other than an empty string is provided.  This API call also differs slightly from the underlying <code>f_getfree</code> function which does not directly return the cluster size, but instead returns a pointer to the <code>FATFS</code> structure for the volume, which will contain the cluster size.  As the <code>FATFS</code> structure is sensitive to the FatFS configuration and may change in future versions of MOS, we have chosen to return the cluster size directly instead.</p>"},{"location":"mos/API/#0xa3-ffs_getlabel","title":"<code>0xA3</code>: ffs_getlabel","text":"<p>Gets the label of a volume</p> <ul> <li><code>HL(U)</code>: Pointer to a path string (ideally caller should set this to zero)</li> <li><code>DE(U)</code>: Pointer to a buffer to store the label in (for safety and future proofing this should be 23 bytes long)</li> <li><code>BC(U)</code>: Pointer to a block of memory to store the 32-bit volume serial number</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul> <p>As with the <code>ffs_getfree</code> API you should set the <code>HL(U)</code> parameter to <code>0</code>, as the way that MOS uses FatFS means that the path is not needed, and the call will likely fail if any path other than an empty string is provided.</p> <p>It should be noted that this API call does not include a parameter for the size of the buffer to store the label in.  If your buffer is not large enough any memory after the label may be overwritten.  As of MOS 3.0 the maximum size of a volume label is 12 bytes (11 characters plus a zero terminator), however for future proofing you are advised to ensure your buffer is 23 bytes long.  The reason for this is that in the future we may enable support for discs using the exFAT filing system, which supports longer volume labels.</p>"},{"location":"mos/API/#0xa4-ffs_setlabel","title":"<code>0xA4</code>: ffs_setlabel","text":"<p>Sets the label of a volume</p> <p>Please note that the label string must be a valid FAT volume label, which basically means that it must be 11 characters or less.  Setting a label to an empty string will remove the label.</p> <p>Owing to how filing systems work some labels may be rejected, and characters may be converted to upper-case.  The <code>f_setlabel</code> function that this API calls will attempt to look for a \"drive prefix\" in the label to specify a drive number, but owing to how we use FatFS in MOS this will not work.  As such you should not include a drive prefix in the label.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a zero-terminated volume label string</li> </ul> <p>Returns:</p> <ul> <li><code>A</code>: <code>FRESULT</code></li> </ul>"},{"location":"mos/API/#0xa5-ffs_setcp","title":"<code>0xA5</code>: ffs_setcp","text":"<p>This API is not implemented, as the FatFS <code>f_setcp</code> function is not supported by the current configuration of the FatFS library used in MOS.</p> <p>The purpose of <code>f_setcp</code> is to set the active code page for file paths, and this is not available as our FatFS configuration is restricted to a single code page.  Adding this feature would greatly expand the size of FatFS, and consequently also MOS, which would almost certainly exceed the available flash space on the eZ80.  As such it is highly unlikely that this API will be implemented in the future.</p> <p>Returns:</p> <ul> <li><code>A</code>: <code>23</code> (Not implemented)</li> </ul>"},{"location":"mos/API/#0xa6-ffs_flseek_p","title":"<code>0xA6</code>: ffs_flseek_p","text":"<p>Move the read/write offset pointer in a file</p> <p>This API can be used to expand the size of a file, although you should note that the file data in the expanded part will be undefined.</p> <p>Whilst the <code>ffs_flseek</code> API can essentially perform the same function as this API, this is the preferred API to use for moving the current read/write pointer offset within a file.  As it accepts a pointer to the 32-bit offset value, it is compatible with both Z80-mode and ADL-mode code.</p> <p>Parameters:</p> <ul> <li><code>HL(U)</code>: Pointer to a <code>FIL</code> structure</li> <li><code>DE(U)</code>: Pointer to a 32-bit value for the desired new offset from the start of the file</li> </ul> <p>Preserves: <code>HL(U)</code>, <code>BC(U)</code></p> <p>Returns:</p> <ul> <li><code>A</code>: Status code</li> </ul>"},{"location":"mos/API/#status-codes","title":"Status Codes","text":"<p>Many MOS API calls will return a status code in the <code>A</code> register.  In general these follow a consistent set of result values, with a few exceptions which are documented against the individual API calls.  Programs and commands will also return a status code when they complete.  If you are using MOS 3, the status code value can be captured in a system variable if the command or program is run using the <code>try</code> command.</p> <p>API calls that are documented above as returning an <code>FRESULT</code> value are returning a status code from the FatFS library.  These directly equate to status codes 0-19 in the table below.</p> <p>Status codes can be translated into a human-readable string using the <code>mos_getError</code> API call.</p> <p>The possible status codes are as follows:</p> Code Error message Description 0 OK Call succeeded (NB this will not be displayed when running a program or star command) 1 Error accessing SD card An error has occurred when trying to access the SD card 2 Internal error An internal error has occurred.  Generally, if possible, a more specific error will be used 3 SD card failure The SD card has failed 4 Could not find file The file could not be found 5 Could not find path The path could not be found 6 Invalid path name The path name is invalid 7 Access denied or directory full A file could not be saved to a directory either because of an access error or too many files in the directory 8 Access denied A file or directory cannot be accessed because it is not readable 9 Invalid file/directory object This is an internal filing system error 10 SD card is write protected The SD card cannot be written to as it is write protected 11 Logical drive number is invalid This is an internal filing system error, which should not occur 12 Volume has no work area This is an internal filing system error 13 No valid FAT volume The SD card does not contain a FAT format volume your Agon can understand 14 Error occurred during mkfs This is an internal filing system error 15 Volume timeout A problem has occured attempting to access your SD card 16 Volume locked The FAT volume cannot be written to 17 LFN working buffer could not be allocated This is an internal filing system error 18 Too many open files Occurs when too many separate files have been opened 19 Invalid parameter A parameter for the command or API is incorrect 20 Invalid command The command was not recognised or found on disc 21 Invalid executable An executable program does not have a valid header 22 Out of memory Either MOS has run out of internal memory, or a buffer provided to an API was not large enough 23 Not implemented The API call is not implemented in this version of MOS 24 Load overlaps system area File load prevented to stop overlapping system memory 25 Bad string A bad or incomplete string has been encountered 26 Too deep Too many nested commands have been detectedThis is usually caused by a faulty alias definition including file load/run types <p>Please note that Quark MOS 1.04 will only return status codes 0-21.  The MOS 2.x release series added status codes 22-25, and MOS 3.0 added status code 26.  </p>"},{"location":"mos/API/#sysvars","title":"System State Information (SysVars)","text":"<p>The MOS API command mos_sysvars returns a pointer to the base of the MOS SysVars (system state variables/information) area in IXU as a 24-bit pointer.  These are different from System Variables which can be used in commands and scripts, so these these internal MOS system state variables are often simply referred to as sysvars.</p> <p>The following sysvars are available in mos_api.inc:</p> <pre><code>; SysVars (System State Information) indexes for api_sysvars\n; Index into _sysvars in globals.asm\n;\nsysvar_time:            EQU 00h ; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)\nsysvar_vpd_pflags:      EQU 04h ; 1: Flags to indicate completion of VDP commands\nsysvar_keyascii:        EQU 05h ; 1: ASCII keycode, or 0 if no key is pressed\nsysvar_keymods:         EQU 06h ; 1: Keycode modifiers\nsysvar_cursorX:         EQU 07h ; 1: Cursor X position\nsysvar_cursorY:         EQU 08h ; 1: Cursor Y position\nsysvar_scrchar:         EQU 09h ; 1: Character read from screen\nsysvar_scrpixel:        EQU 0Ah ; 3: Pixel data read from screen (R,B,G)\nsysvar_audioChannel:    EQU 0Dh ; 1: Audio channel\nsysvar_audioSuccess:    EQU 0Eh ; 1: Audio channel note queued (0 = no, 1 = yes)\nsysvar_scrWidth:        EQU 0Fh ; 2: Screen width in pixels\nsysvar_scrHeight:       EQU 11h ; 2: Screen height in pixels\nsysvar_scrCols:         EQU 13h ; 1: Screen columns in characters\nsysvar_scrRows:         EQU 14h ; 1: Screen rows in characters\nsysvar_scrColours:      EQU 15h ; 1: Number of colours displayed\nsysvar_scrpixelIndex:   EQU 16h ; 1: Index of pixel data read from screen\nsysvar_vkeycode:        EQU 17h ; 1: Virtual key code from FabGL\nsysvar_vkeydown         EQU 18h ; 1: Virtual key state from FabGL (0=up, 1=down)\nsysvar_vkeycount:       EQU 19h ; 1: Incremented every time a key packet is received\nsysvar_rtc:             EQU 1Ah ; 8: Real time clock data\nsysvar_keydelay:        EQU 22h ; 2: Keyboard repeat delay\nsysvar_keyrate:         EQU 24h ; 2: Keyboard repeat rate\nsysvar_keyled:          EQU 26h ; 1: Keyboard LED status\nsysvar_scrMode:         EQU 27h ; 1: Screen mode (from MOS 1.04)\nsysvar_rtc_enable:      EQU 28h ; 1: RTC enable status (from MOS 2.0.0)\nsysvar_mouseX:          EQU 29h ; 2: Mouse X position\nsysvar_mouseY:          EQU 2Bh ; 2: Mouse Y position\nsysvar_mouseButtons:    EQU 2Dh ; 1: Mouse left+right+middle buttons (bits 0-2, 0=up, 1=down)\nsysvar_mouseWheel:      EQU 2Eh ; 1: Mouse wheel delta\nsysvar_mouseXDelta:     EQU 2Fh ; 2: Mouse X delta\nsysvar_mouseYDelta:     EQU 31h ; 2: Mouse Y delta\n</code></pre> <p>Example: Reading a virtual keycode in ADL mode (24-bit): <pre><code>        MOSCALL mos_getkey\n        LD  A, (IX + sysvar_vkeycode)   ; Load A with the virtual keycode from FabGL\n</code></pre></p> <p>Example: Reading a virtual keycode in Z80 mode (16-bit): <pre><code>        MOSCALL mos_getkey\n        LD.LIL  A, (IX + sysvar_vkeycode)   ; Load A with the virtual keycode from FabGL\n</code></pre></p>"},{"location":"mos/API/#sysvar_rtc","title":"Real Time Clock","text":"<p>For efficiency, the real-time clock data in the sysvars is stored in a packed format, using subsets of bits within the 8 bytes of the <code>sysvar_rtc</code> data.  An API is provided from MOS 3 onwards to allow for this to be unpacked mos_unpackrtc into a buffer in a friendlier, more easy to use format.  MOS uses the following C function to unpack the RTC data into a <code>vdp_time_t</code> object: <pre><code>void rtc_unpack(UINT8 * sysvar_rtc, vdp_time_t * t) {\n    UINT32  d = *(UINT32 *)sysvar_rtc;\n\n    t-&gt;month =      (d &amp; 0x0000000F);       // uint32_t month : 4;      00000000 00000000 00000000 0000xxxx : 00 00 00 0F &gt;&gt; 0\n    t-&gt;day =        (d &amp; 0x000001F0) &gt;&gt; 4;  // uint32_t day : 5;        00000000 00000000 0000000x xxxx0000 : 00 00 01 F0 &gt;&gt; 4\n    t-&gt;dayOfWeek =  (d &amp; 0x00000E00) &gt;&gt; 9;  // uint32_t dayOfWeek : 3;  00000000 00000000 0000xxx0 00000000 : 00 00 0E 00 &gt;&gt; 9\n    t-&gt;dayOfYear =  (d &amp; 0x001FF000) &gt;&gt; 12; // uint32_t dayOfYear : 9;  00000000 000xxxxx xxxx0000 00000000 : 00 1F F0 00 &gt;&gt; 12\n    t-&gt;hour =       (d &amp; 0x03E00000) &gt;&gt; 21; // uint32_t hour : 5;       000000xx xxx00000 00000000 00000000 : 03 E0 00 00 &gt;&gt; 21\n    t-&gt;minute =     (d &amp; 0xFC000000) &gt;&gt; 26; // uint32_t minute : 6;     xxxxxx00 00000000 00000000 00000000 : FC 00 00 00 &gt;&gt; 26\n\n    t-&gt;second = sysvar_rtc[4];\n    t-&gt;year = (char)sysvar_rtc[5] + 1980;\n}\n</code></pre></p> <p>This real-time clock data is also available to programs, scripts, and the command line via system variables.</p>"},{"location":"mos/Argument-Substitution/","title":"Argument substitution","text":"<p>Several features in MOS have support for \"argument substitution\".  This includes how the system handles aliases, hotkeys, loading/running files with given file extensions, and running Obey files.</p> <p>Argument substitution is used by MOS as a way to insert arguments into a new command.  Essentially, a source string is defined which includes placeholder tokens for arguments to be inserted into.  When the command is executed, the system will replace these tokens with the actual arguments that were passed to the command.</p> <p>Before MOS 3 the only command that supported argument substitution was the <code>Hotkey</code> command.  It would only support a single form of substitution token in the given command string in the form of <code>%s</code>, which would insert the whole of the current input line at that point.  This has changed in MOS 3 where the system now supports a more flexible form of argument substitution.</p> <p>From MOS 3 onwards, arguments substitution is done by using the <code>%</code> character followed by a number from 0-9 to specify which argument to insert.  These are arguments are taken from the original command.  For instance, <code>%0</code> will be replaced by the first argument to the command, <code>%1</code> will be replaced by the second argument, and so on.  If you want to include a literal <code>%</code> character in the command, you can escape it by using <code>%%</code>.  You can also use <code>%*&lt;n&gt;</code> to insert all arguments starting from a particular numbered argument into the command.  For example, <code>%*2</code> will insert all arguments from the second argument onwards.  For backwards compatibility, <code>%s</code> is still supported, and is equivalent to <code>%*0</code>.</p> <p>Arguments can be wrapped with double-quote characters <code>\"</code> to allow for arguments that contain spaces.</p> <p>Arguments may also be used multiple times in the command string.  For example, the command <code>*set Alias$DoubleEcho echo %0 %0</code> will create a command alias called <code>DoubleEcho</code> that will echo the first argument twice, so performing the command <code>*DoubleEcho hello</code> would produce the output <code>hello hello</code>.</p> <p>Command aliases, including file load/run types, will automatically append any arguments beyond the last used argument to the end of the resultant command.</p> <p>Creating a command alias with the name of an existing command allows you to override that command, changing how it works.  The original command can still be used by prefixing the command with a <code>%</code> character, as prefixing a command with <code>%</code> causes alias-resolution to be skipped.  An example of where you might wish to do this is to set the <code>Dir</code> command to display the directory by default in long format, rather than short form.  This can be achieved with <code>*set Alias$Dir %dir -l %0</code>.  If you omit the <code>%</code> character here before the <code>dir</code> command, the system will attempt to recursively call the alias, and you will get a <code>Too deep</code> error.</p> <p>Prefixing aliases with the <code>%</code> character to skip alias resolution can be useful in script files to help ensure that you are definitely using the original command, rather than an alias that another script may have set up.</p> <p>The argument substitution system in MOS 3 is available for use by programs through the <code>mos_substituteargs</code> API call.  Whilst this is commonly used to construct commands, it can be used for other purposes too.  At its core, argument substitution is a simple text replacement system, and can be used for any purpose where you need to insert text into a string.  It takes a template string, a separate string for the arguments, and a buffer to write the resultant string to where placeholders in the template string have been replaced with sub-strings taken from the arguments.</p>"},{"location":"mos/C-Functions/","title":"Using MOS C functions","text":"<p>MOS 3.0 added a new API, mos_getfunction, which allows programs to get the address of various C functions.  These functions comply with the Zilog eZ80 C calling conventions.</p> <p>As MOS already provides an extensive API, the range of C functions this API provides is limited.  There are essentially three potential reasons why a function has been made available via this API:</p> <ol> <li>The function cannot be made available via a traditional MOS API</li> <li>The equivalent MOS API is difficult to use from programs written in C (in general because it uses the <code>IX(U)</code> register)</li> <li>Direct access to the function may be useful for efficiency reasons</li> </ol> <p>It is important to note that these functions are only accessible to programs written to run in the eZ80's ADL mode.  Z80 mode programs cannot use the <code>mos_getfunction</code> API, and would not be able to use these functions even if they could, as the calling convention is not compatible with Z80 mode code.</p> <p>The complete list of functions available from the <code>mos_getfunction</code> API is provided in the MOS C functions section below.</p>"},{"location":"mos/C-Functions/#the-c-function-calling-convention","title":"The C function calling convention","text":"<p>Zilog's documentation for their C function calling convention is described in a document with the very catchy name ZDS II for eZ80Acclaim!: Calling C Functions from Assembly and Vice Versa.  This document is essentially an edited except from the \"ZiLOG Developer Studio II eZ80Acclaim!\u00ae User Manual\" with some additional examples.</p> <p>When considering function pointers returned by the <code>mos_getfunction</code> API the notes around function naming conventions in Zilog's documentation are not really important.</p> <p>If you are using these functions from a C program, assuming your compiler understands the Zilog eZ80 C calling convention (which is currently true for all C compilers for the Agon platform) you will need to let your compiler know the function prototype.</p> <p>The underlying details of how the C function calling convention works should not be important to you if you are only using these functions from C.  You can skip ahead to the descriptions of the functions available from the <code>mos_getfunction</code> API.</p> <p>However if you are using these functions from assembly then you will need to understand how the calling convention works.</p>"},{"location":"mos/C-Functions/#passing-parameters-to-functions","title":"Passing parameters to functions","text":"<p>Function parameters are passed on the stack in reverse order, i.e. the rightmost parameter is pushed first, and the leftmost parameter is pushed last.  The leftmost argument is therefore at the top of the stack when the function is called.</p> <p>After a function call, the caller is responsible for cleaning up the stack.  This means that the caller must remove the arguments from the stack after the function has returned.</p> <p>Arguments of different types are always a multiple of 3 bytes in size, essentially because the eZ80's registers are 3 bytes wide in ADL mode.  As most variable types are not a multiple of 3 bytes in size, some bytes pushed to the stack will be ignored by functions that take arguments of those types.  C compilers that support the eZ80 C calling convention will automatically understand this and ignore any extra padding bytes on the stack when handling function arguments.  For example, a <code>char</code> type is 1 byte in size, and will be padded to 3 bytes when passed to a function.  The compiler will automatically ignore the extra 2 bytes.</p> <p>The following table provides a guid the types of arguments that can be passed to functions, their size, and how they are arranged in memory on the stack.  As type names can vary, the table may show various common names used for the same underlying type, and is not exhaustive.  For example the table does not list <code>int8_t</code>, <code>unsigned char</code> or <code>BYTE</code>, as they are essentially equivalent to <code>char</code> and <code>uint8_t</code>.  The \"memory\" column shows how the values are arranged from the least significant byte to the most significant byte.  It is always a multiple of 3 bytes, with each individual value byte shown as <code>xx</code>; bytes that will be ignored by the function are shown as <code>??</code>.</p> Type Native Size Size on stack Memory (Low to high) <code>char</code>/<code>uint8_t</code> 1 byte 3 bytes <code>xx ?? ??</code> <code>short</code>/<code>uint16_t</code> 2 bytes 3 bytes <code>xx xx ??</code> <code>int</code>/<code>uint24_t</code> 3 bytes 3 bytes <code>xx xx xx</code> <code>long</code>/<code>uint32_t</code> 4 bytes 6 bytes <code>xx xx xx xx ?? ??</code> <code>long long</code>/<code>uint64_t</code> 8 bytes 9 bytes <code>xx xx xx xx xx xx xx xx ??</code> <code>float</code> 4 bytes 6 bytes <code>xx xx xx xx ?? ??</code> <code>double</code> 4 bytes 6 bytes <code>xx xx xx xx ?? ??</code> <code>void *</code> (any pointer) 3 bytes 3 bytes <code>xx xx xx</code> <ul> <li>as noted above, the types in this table are not exhaustive, and similar types of the same length/size will be treated the same way</li> <li><code>uint24_t</code> is not part of the C standard, but may be supported by some compilers that support the eZ80.  As the eZ80 includes several 24-bit registers when in ADL mode, this is also the default integer <code>int</code> type used by these compilers.</li> <li>the Zilog C compiler does not support the <code>long long</code>/<code>uint64_t</code> type, and this is not part of their C calling convention standard, but it is a common extension that other compilers for the eZ80 supports.  This type is not currently used by any of the functions available from the <code>mos_getfunction</code> API, but is included for completeness.</li> <li>owing to constraints of the eZ80 architecture, both <code>float</code> and <code>double</code> are IEEE-754 single precision 32-bit floating point values by compilers that target the eZ80.</li> </ul>"},{"location":"mos/C-Functions/#calling-c-functions-from-assembly","title":"Calling C functions from assembly","text":"<p>As values are passed to functions using the stack, the process of calling a C function from assembly is generally to push arguments in reverse order.  As noted above, all arguments must be a multiple of 3 bytes in size; the nature of the eZ80 when running in ADL mode is that as you can only push wide registers to the stack you will always push 3-bytes to the stack.  This means that if you have an 8-bit value in an 8-bit register for an 8-bit argument (e.g. a <code>BYTE</code> or a <code>char</code>), you just need to ensure the value is in the least signficant register of a 3-byte register, and then push that register to the stack.  The other two bytes will be ignored by the function.</p> <p>The <code>mos_getfunction</code> API returns a pointer to the requested function in the <code>HLU</code> register.  In principle your program needs to \"call\" this function, but the eZ80 does not have a version of the <code>CALL</code> instruction that can use a register as the address to call.  There is, however, a <code>JP (HL)</code> instruction.  There is more than one way to use this instruction to \"call\" a function, but the simplest is probably the following:</p> <pre><code>; Call a function pointer in HL\n; use `CALL call_HL` to call the function, ensuring return address is pushed\n.call_HL    JP (HL)\n</code></pre> <p>With this in place, to call a function provided from the <code>mos_getfunction</code> API from eZ80 assembler code, you would do the following:</p> <ol> <li>Push the arguments to the stack in reverse order</li> <li>Ensure that the <code>HLU</code> register contains the address of the function to call</li> <li>Perform a <code>CALL call_HL</code> instruction to push the return address onto the stack</li> <li>Execution continues after that call, with the return value set as per the calling convention</li> <li>Pop arguments off the stack</li> </ol> <p>Step 2 here could be a call to <code>mos_getfunction</code> at that point in the process, or that could be done earlier in your program.  Please note however that there may in future be some issues with caching function pointers when MOS Modules so please read the guidance below.</p>"},{"location":"mos/C-Functions/#return-values","title":"Return values","text":"<p>The return value from a function will be placed in one or more of the eZ80's registers.</p> <p>Exactly which registers are used depends on the type of the value returned.  The following table shows how different types of return values are returned.  As with the table above for arguments, the types in this table are not exhaustive, and similar types of the same length/size will be treated the same way.  Some types are returned across multiple registers; the table below illustrates register contents from the most significant byte to the least significant byte.</p> Type Return registers Register contents <code>char</code>/<code>uint8_t</code> <code>A</code> <code>xx</code> <code>short</code>/<code>uint16_t</code> <code>HLU</code> <code>?? xx xx</code> <code>int</code>/<code>uint24_t</code> <code>HLU</code> <code>xx xx xx</code> <code>long</code>/<code>uint32_t</code> <code>E:HLU</code> <code>xx: xx xx xx</code> <code>long long</code>/<code>uint64_t</code> <code>BC:DEU:HLU</code> <code>?? xx xx: xx xx xx: xx xx xx</code> <code>float</code> <code>E:HLU</code> <code>xx: xx xx xx</code> <code>double</code> <code>E:HLU</code> <code>xx: xx xx xx</code> <code>void *</code> (any pointer) <code>HLU</code> <code>xx xx xx</code> <ul> <li>as noted above, the types in this table are not exhaustive, and similar types of the same length/size will be treated the same way</li> <li>as with the argument table, <code>uint24_t</code> is not part of the C standard, and the <code>int</code> type is a 24-bit value</li> <li>as with the argument table, <code>long long</code>/<code>uint64_t</code> is not part of the Zilog C calling convention standard, but is a common extension that other compilers for the eZ80 supports.  This type is not currently used by any of the functions available from the <code>mos_getfunction</code> API, but is included for completeness.</li> </ul>"},{"location":"mos/C-Functions/#functions","title":"Functions available from the <code>mos_getfunction</code> API","text":"<p>The following functions are available from the <code>mos_getfunction</code> API.</p> <p>It should be noted that that whilst MOS APIs will return <code>FRESULT</code> or \"status\" values in the 8-bit <code>A</code> register, most of the underlying functions return an <code>FRESULT</code> or an <code>int</code> for their status, which are actually 24-bit values.  The calling convention means they will be returned in <code>HL(U)</code>.</p> <p>This list is complete as of the MOS 3.0 release, but may change in future releases of MOS to include additional functions.</p>"},{"location":"mos/C-Functions/#0x00-byte-sd_init","title":"0x00 - <code>BYTE    SD_init();</code>","text":"<p>Initialises the low-level SD card handling system </p>"},{"location":"mos/C-Functions/#0x01-byte-sd_readblocksdword-sector-byte-buf-word-count","title":"0x01 - <code>BYTE    SD_readBlocks(DWORD sector, BYTE *buf, WORD count);</code>","text":"<p>Read raw sector data from SD card.</p> <p><code>DWORD</code> is a 32-bit value, <code>WORD</code> is a 16-bit value, and <code>BYTE</code> is an 8-bit value.  The <code>buf</code> pointer is a pointer to a buffer of data that will be filled with the data read from the SD card.  The <code>count</code> parameter indicates how many bytes to read from the SD card.</p>"},{"location":"mos/C-Functions/#0x02-byte-sd_writeblocksdword-sector-byte-buf-word-count","title":"0x02 - <code>BYTE    SD_writeBlocks(DWORD sector, BYTE *buf, WORD count);</code>","text":"<p>Write raw sector data to SD card.</p> <p>This function works in a similar way to the <code>SD_readBlocks</code> function.  The <code>buf</code> pointer here is a pointer to the buffer of data used to write to the SD card.</p>"},{"location":"mos/C-Functions/#0x03-na","title":"0x03 - n/a","text":"<p>Calling <code>mos_getfunction</code> asking for this function number will succeed, but return a <code>NULL</code> pointer.</p> <p>Reserved for potential future <code>SD_status</code> function</p>"},{"location":"mos/C-Functions/#0x04-na","title":"0x04 - n/a","text":"<p>Calling <code>mos_getfunction</code> asking for this function number will succeed, but return a <code>NULL</code> pointer.</p> <p>Reserved for potential future <code>SD_ioctl</code> function</p>"},{"location":"mos/C-Functions/#0x05-int-f_printf-fil-fp-const-tchar-str","title":"0x05 - <code>int f_printf (FIL* fp, const TCHAR* str, ...);</code>","text":"<p>The FatFS <code>f_printf</code> function.  This function is documented in the FatFS documentation.</p>"},{"location":"mos/C-Functions/#0x06-fresult-f_findfirst-dir-dp-filinfo-fno-const-tchar-path-const-tchar-pattern","title":"0x06 - <code>FRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);</code>","text":"<p>The FatFS <code>f_findfirst</code> function, equivalent to the <code>ffs_dfindfirst</code> API call.  This function is documemented in the FatFS documentation.</p> <p>Please note that for C functions, an <code>FRESULT</code> is an <code>int</code> type, and therefore will be returned in the <code>HLU</code> register.  This differs from the MOS APIs for FatFS which returns an 8-bit <code>FRESULT</code> value.  The return values however are otherwise identical.</p>"},{"location":"mos/C-Functions/#0x07-fresult-f_findnext-dir-dp-filinfo-fno","title":"0x07 - <code>FRESULT f_findnext (DIR* dp, FILINFO* fno);</code>","text":"<p>The FatFS <code>f_findnext</code> function, equivalent to the <code>ffd_dfindnext</code> API call.  This function is documemented in the FatFS documentation.</p> <p>As with the <code>f_findfirst</code> function, an <code>FRESULT</code> is an <code>int</code> type, and will be returned in the <code>HLU</code> register.</p>"},{"location":"mos/C-Functions/#0x08-byte-open_uart1uart-puart","title":"0x08 - <code>BYTE    open_UART1(UART * pUART);</code>","text":"<p>Equivalent to the <code>mos_uopen</code> API call.  Please refer to the API documentation for details of the <code>UART</code> structure.</p>"},{"location":"mos/C-Functions/#0x09-int-setvarvalchar-name-void-value-char-actualname-byte-type","title":"0x09 - <code>int     setVarVal(char * name, void * value, char ** actualName, BYTE * type);</code>","text":"<p>The underlying function the <code>mos_setvarval</code> API call uses.  Please see the API documentation for information about variable names and types.</p> <p>Please note that the way this function works differs slightly from the API; the API handles creating pointers for some arguments, and getting the values from them to return in registers.</p> <p>The parameters are as follows: - <code>name</code> is the name of the variable to set.  As with the API, if this name is a pattern the first matched name will be set, unless an <code>actualName</code> pointer has been provided. - <code>value</code> is a pointer to the value to be set, or if setting a number type variable this will be the actual number to set. - <code>actualName</code> is a pointer to a pointer to a string.  Providing this pointer is optional, but if it is set then on first call the pointer it points to should be set to <code>NULL</code>.  After the function has been called, the pointer will be set to the actual name string of the variable that has been set.  Please note that it is important to not adjust that string in any way.  If you have used a pattern in the <code>name</code> parameter, and have provided an <code>actualName</code> pointer, then subsequent calls to this function will set the next variable that matches the pattern, and the <code>actualName</code> pointer will be updated accordingly. - <code>type</code> is a pointer to a <code>BYTE</code> for the variable type to be set.  This is required.  This value will be updated after the function has been called to reflect the actual type of the variable that has been set; please note that varible types 3 and 4 (\"expanded\" and \"literal string\") will be replaced with either \"string\" or \"number\" as appropriate.</p> <p>The return value is a MOS status code, which will be in the <code>HLU</code> register.</p>"},{"location":"mos/C-Functions/#0x0a-int-readvarvalchar-namepattern-void-value-char-actualname-int-length-byte-typeflag","title":"0x0A - <code>int     readVarVal(char * namePattern, void * value, char ** actualName, int * length, BYTE * typeFlag);</code>","text":"<p>The underlying function the <code>mos_readvarval</code> API call uses.</p> <p>This function is very similar to the <code>setVarVal</code> function, and it's arguments work in a very similar way.  These are the differences:</p> <ul> <li><code>value</code> can be <code>null</code> to measure the length of a variable, but otherwise must always point to a buffer into which the variable value will be read/copied.  This is in contrast to the <code>setVarVal</code> function which will accept a raw number as the value to be set for \"number\" type variables.</li> <li>a pointer to a 24-bit <code>length</code> value is required.  On entry, this indicates the length of the <code>value</code> buffer, if one has been provided.  If a matching variable is found, this value will always be updated to reflect the full length of the variable that has been read, or will be <code>0</code> if no variable was found.</li> <li>the <code>typeFlag</code> pointer is required.  On entry, if the value this points to is <code>3</code> then the variable being read will be \"expanded\" before it is returned.  This means that if the variable being read is a \"macro\" type, the returned string will be the expanded string with variables referenced in the macro replaced with their values.  If the variable being read is a \"number\", then it will be converted into a string.  On return, this value will be set to the underlying type of the variable that has been read, if a variable was found.</li> </ul> <p>The return value from this function is a MOS status code, which will be in the <code>HLU</code> register.  If a <code>value</code> buffer was provided, and the variable was found, then the value will be copied into that buffer.  If the buffer was not large enough to hold the variable then as much of the variable as will fit will be copied into the buffer, the <code>length</code> will reflect the total length of the variable (which will be more than was copied) and the function will return an \"out of memory\" status code.</p>"},{"location":"mos/C-Functions/#0x0b-int-gstranschar-source-char-dest-int-destlen-int-read-byte-flags","title":"0x0B - <code>int     gsTrans(char * source, char * dest, int destLen, int * read, BYTE flags);</code>","text":"<p>The underlying function the <code>mos_gstrans</code> API call uses.</p> <p>The \"GSTrans\" functionality in MOS is used to translate a source string that may include references to system variables into a new string with those variables expanded.  It can also convert other special character sequences into non-printable characters.  Guidance on this can be found in the documentation for the <code>echo</code> star command.</p> <p>The arguments to this function are as follows:</p> <ul> <li><code>source</code> is a pointer to the source \"template\" string to be translated</li> <li><code>dest</code> is a pointer to the destination buffer where the translated string will be written.  If this is set to <code>NULL</code> then the function will not write to the buffer, but will still calculate the length of the translated string.</li> <li><code>destLen</code> is the size of the destination buffer, if one is provided</li> <li><code>read</code> is a pointer to an integer to store the number of translated characters read from source</li> <li><code>flags</code> is a set of flags that control how the translation is performed.  These flags are described in the <code>mos_gsinit</code> API documentation.</li> </ul> <p>The <code>source</code> and <code>read</code> pointers are both always required.  The <code>dest</code> pointer is optional, but if provided it cannot be the same as the <code>source</code> pointer.</p> <p>The GSTrans process essentially performs a call to the <code>mos_gsinit</code> API and then calls <code>mos_gsread</code> until it reaches the end of the source string.</p> <p>This function returns a MOS status code, which will be in the <code>HLU</code> register.  Various return values are possible, and may indicate that the source string was not valid, or various other errors.</p>"},{"location":"mos/C-Functions/#0x0c-int-substituteargschar-template-char-args-char-dest-int-length-byte-flags","title":"0x0C - <code>int substituteArgs(char * template, char * args, char * dest, int length, BYTE flags);</code>","text":"<p>The underlying function the <code>mos_substituteargs</code> API call uses to perform argument substitution.</p> <p>This function works in a very similar manner to its corresponding API call.  For information on the arguments to this function, please see the API documentation.</p> <p>The return value from this function is the total length of the substituted string.  If a destination buffer was provided that was not large enough to hold the entire substituted string then the function will fill the buffer with as much of the substituted string as will fit.</p>"},{"location":"mos/C-Functions/#0x0d-int-resolvepathchar-filepath-char-resolvedpath-int-length-byte-index-dir-dir-byte-flags","title":"0x0D - <code>int resolvePath(char * filepath, char * resolvedPath, int * length, BYTE * index, DIR * dir, BYTE flags);</code>","text":"<p>The underlying function the <code>mos_resolvepath</code> API call uses.</p> <p>The <code>resolvePath</code> function resolves a file path.  The primary use for this function is to take a MOS-style file path that may include a path prefix or use other system variables and to resolve it into a full path that can be used by the underlying file system, i.e. the FatFS APIs.  It can also be used to find files within a directory that match a given pattern.</p> <p>The arguments to this function are as follows:</p> <ul> <li><code>filepath</code> is a pointer to the file path string that is to be resolved</li> <li><code>resolvedPath</code> is a pointer to the buffer where the resolved path will be written.  If this is set to <code>NULL</code> then the function will calculate the length of the resolved path.</li> <li><code>length</code> is a pointer to an integer that on entry indicates the size of the <code>resolvedPath</code> buffer.  On exit, this will be set to the length of the resolved path.</li> <li><code>index</code> is a pointer to a <code>BYTE</code> that is used to keep track of which version of a path prefix is being used.  This is used when resolving paths that use a prefix where the corresponding system variable contains multiple values.  If the <code>index</code> pointer is set to <code>NULL</code> then only the first matching path will be returned.  You can use this to manually iterate through the available prefixes.</li> <li><code>dir</code> is a pointer to a <code>DIR</code> object.  This is optional, but if it is not provided then the function can only return the first matching path.  If a <code>DIR</code> object is provided, then repeated calls to this function can be used to find all matching paths.  This is useful for finding files that match a given pattern.</li> <li><code>flags</code> is a set of flags that control how the path is resolved.  These flags are described in the <code>mos_resolvepath</code> API documentation.</li> </ul> <p>This function will return a MOS status code, in the <code>HLU</code> register.  For more guidance on possible return values, please see the API documentation for the <code>mos_resolvepath</code> API call.</p>"},{"location":"mos/C-Functions/#0x0e-int-getdirectoryforpathchar-srcpath-char-dir-int-length-byte-index","title":"0x0E - <code>int getDirectoryForPath(char * srcPath, char * dir, int * length, BYTE index);</code>","text":"<p>The underlying function the <code>mos_getdirforpath</code> API call uses.</p> <p>This function will return the directory for a given file path, omitting the leaf name.</p> <p>The arguments to this function are as follows:</p> <ul> <li><code>srcPath</code> is a pointer to the file path string that is to be resolved</li> <li><code>dir</code> is a pointer to the buffer where the resolved path will be written.  If this is set to <code>NULL</code> then the function will calculate the length of the resolved path.</li> <li><code>length</code> is a pointer to an integer that on entry indicates the size of the <code>dir</code> buffer.  On exit, this will be set to the length of the resolved path.</li> <li><code>index</code> is used to determine which version of a path prefix is used</li> </ul> <p>This function is purely a string manupulation function.  It does not perform any filing system operations, </p> <p>This function returns a MOS status code, in the <code>HLU</code> register.  If the path contains a prefix that is not recognised, or if the prefix was recognised but the <code>index</code> value is out of range, then the function will return a \"no path\" status code.</p>"},{"location":"mos/C-Functions/#0x0f-int-resolverelativepathchar-path-char-resolved-int-length","title":"0x0F - <code>int resolveRelativePath(char * path, char * resolved, int * length);</code>","text":"<p>This is the underlying function that <code>mos_api_getabsolutepath</code> uses.</p> <p>This function will take a relative path, i.e. one that may contain <code>.</code> or <code>..</code> path components, and resolve it into an absolute path.  Please note that this function does not perform a file path resolution, i.e. it will not resolve any path prefixes or system variables.  This function does however verify that the path provided is valid (at least in terms of does the containing directory exist), and will return an error if it is not.</p> <p>At the time of writing, this function requires both the source <code>path</code> argument and a destination <code>resolved</code> pointer to be provided.  To come into line with other functions this may change in the future to allow for the <code>resolved</code> pointer to be <code>NULL</code> in order to calculate the length of the resolved path.  As with the other functions above, the <code>length</code> pointer is used to indicate the size of the destination buffer, and will be updated to reflect the length of the resolved path.</p> <p>Returns a MOS status code, in the <code>HLU</code> register.</p>"},{"location":"mos/C-Functions/#0x10-void-getsysvars","title":"0x10 - <code>void * getsysvars()</code>","text":"<p>Returns a pointer to the system variables area.  Directly equivalent to the <code>mos_sysvars</code> API call.</p> <p>The sysvars pointer will be returned in the <code>HLU</code> register.</p>"},{"location":"mos/C-Functions/#0x11-void-getkbmap","title":"0x11 - <code>void * getkbmap()</code>","text":"<p>Returns a pointer to the keyboard map.  Directly equivalent to the <code>mos_getkbmap</code> API call.</p> <p>The keyboard map pointer will be returned in the <code>HLU</code> register.</p>"},{"location":"mos/C-Functions/#modules","title":"A note for the future: MOS modules","text":"<p>It is highly likely that a future version of MOS will introduce a module system that will allow some parts of MOS to be loaded and unloaded at run-time.</p> <p>What this means is that the address of a function returned by the <code>mos_getfunction</code> API might not be valid if the module that provides it has been unloaded.</p> <p>Functions provided by \"Core MOS\" will always be present.  At this time the exact details of what will be included in \"Core MOS\" have yet to be finalised, but it is likely that all of the APIs and star commands present in MOS 2.3 will be included.  Whilst some new features added in MOS 3.0 are also likely to be included in \"Core MOS\" are also likely to be included, not all of them will be.</p> <p>For now, the safest way to use the <code>mos_getfunction</code> API would be to call it each time you need to use a function, immediately before you call the function it returns.  This should guarantee that the module containing the function has been loaded and is present in memory.</p>"},{"location":"mos/Executables/","title":"MOS Executables","text":"<p>Executable programs for the Agon platform have, to date, conventionally used a <code>.bin</code> file extension.  In principle however any file can be used as an executable.</p> <p>Essentially the process for running any executable is the same.  The following three steps will be performed:</p> <ol> <li>The program file will be opened and read into memory</li> <li>It will then will be checked to see if it is a valid executable</li> <li>If it is valid, then the program will be run</li> </ol> <p>The exact details of these steps may differ and vary slightly depending on the version of MOS you are using, but essentially these steps broadly remain the same.</p> <p>MOS essentially supports two different types of programs; \"moslets\" and regular programs.</p> <p>Moslets are always built to be loaded and run at address <code>0x0B0000</code>, the start of the \"moslet\" memory space in the Agon platform's memory map, and should be smaller than 32 kilobytes in size to fit into that space.</p> <p>Regular programs are usually built to be loaded and run at address <code>0x040000</code>, the start of the \"user RAM\" area of memory.  This is the address that MOS will automatically use when loading and running a program.</p> <p>MOS 2.3 and later will additionally check to ensure that a program cannot be loaded into memory that will overlap the MOS system area of memory.</p>"},{"location":"mos/Executables/#parameters","title":"Parameters passed to executables","text":"<p>When a program is run, whether that is through the use of the <code>Run</code> command or via a different mechanism, MOS will set up the following processor registers before the program is entered:</p> <ul> <li><code>A</code> will be set to the current memory bank value <code>MB</code></li> <li><code>DE(U)</code> the execution address</li> <li><code>HL(U)</code> pointer to any additional command line parameters</li> </ul> <p>Notes about the processor stack can be found here.</p>"},{"location":"mos/Executables/#the-mos-executable-file-format","title":"The MOS Executable File Format","text":"<p>To facilitate checking for valid executables, MOS uses a simple executable file format.</p> <p>The basic format requires a header to be present at an offset of 64 bytes into the file, as follows:</p> Offset Size Contents 0x40 3 bytes the word <code>MOS</code> in ASCII bytes 0x43 1 byte header version 0x44 1 byte executable type: <code>0</code> = Z80, <code>1</code> = ADL <p>You will note that this header format is very simple and essentially includes only one piece of information, whether the executable code should be run in Z80 or ADL mode on the eZ80 processor.  There is no information here about where the program should be loaded into memory, so it is not possible to tell from the header whether a program is a moslet, a regular program, or some other type of program file.</p> <p>The header version byte should be set to <code>0</code> for all programs that were written for MOS 1 and MOS 2.  Up to and including MOS 3.0 the version byte is not actually checked.</p>"},{"location":"mos/Executables/#advanced-header","title":"The \"advanced\" header format","text":"<p>As of the MOS 3.0 release an advanced header format is being introduced which allows for the inclusion of additional information in the header.</p> <p>Please note that this header format is backwards compatible with the original header format, and programs that use this new header format will still be able to run on earlier versions of MOS.</p> <p>The main reason for this new format is is to prepare for MOS Modules.  When the MOS modules system is introduced, executables with a header version of <code>0</code> will not be considered to be \"module safe\", and API calls, commands, and functions provided by modules will not be available to them.</p> <p>Some APIs, commands, and functions introduced in MOS 3.0 may be moved to modules in the future.  To guarantee that a program using these features will continue to work in the future you should ensure that your program is \"module safe\" and has an appropriate header.</p> <p>As previous versions of MOS do not actually check the header version, it is possible to use the new header format in existing programs that can run on all versions of MOS.  As a result you should be aware that any additional information or or settings included in the header will be ignored by previous versions of MOS.  You should not assume that including such information is a guarantee that it will be understood when your program is run.</p> <p>The new header format is as follows:</p> Offset Size Contents 0x40 3 bytes the word <code>MOS</code> in ASCII bytes 0x43 1 byte header version (this should be <code>1</code> for \"advanced\") 0x44 1 byte executable type: <code>0</code> = Z80, <code>1</code> = ADL 0x45 1 byte flags 0x46 1 byte bit-inverted copy of the flags byte at offset <code>0x45</code> 0x47 3 bytes optional load/execution address (little-endian) - only use this if the corresponding flag is set <p>The flags byte is a bit field.  As the original header version byte was not well documented, and is not actively checked inside earlier versions of MOS, it is possible that some programs may exist that have the header version byte set to <code>1</code>.  To avoid any potential false-positives, an inverted copy of the flags byte is included to allow the flags byte to be verified.</p> <p>The following bits are defined:</p> Bit Meaning Description 0 Module safe The program is \"module safe\", as it does not use the \"moslet\" area of memory (where modules are loaded) 1 Module compatible The program uses the moslet area of memory, but modules can be loaded into that area of memory.  When this bit is set when a module needs to be loaded MOS will save the moslet area of memory to disk before loading a module and executing the command or API that required it.  On returning from the module, MOS will restore the moslet area of memory from disk.  Programs with this bit set must ensure that any API calls they make will not use the moslet area for data buffers the API calls require. 2 Strip trailing spaces from arguments When this bit is set, any trailing spaces in the arguments string passed to the program will be stripped.  Please note that this is the default behaviour for executables with a header version of <code>0</code>, but the default behaviour for executables with a header version of <code>1</code> is to not strip trailing spaces.  This bit is provided for backwards compatibility with earlier versions of MOS. 3 Header includes load/execution address The default address to load and execute this executable is set at offset 0x47-49.  For Z80 executables the most significant byte (at 0x49) will be ignored 4-7 Reserved These bit is reserved for future use, and must be set to zero <p>More advice on the meanings of \"module safe\" and \"module compatible\" can be found in the MOS Modules documentation.</p> <p>Future versions of this header version may include support for more bits in the flags byte to indicate that further information is provided.  When support for new flags is added unless there is a good reason to do so the header version will not be changed and remain <code>1</code>.</p> <p>It should also be noted that whilst this new header format has been introduced with the release of MOS 3.0, the MOS 3.0 release does not understand the new header extensions, and will ignore them.  They are included and documented here to allow developers to start using them in their programs in preparation for future versions of MOS.</p> <p>It is likely that the next release of MOS will understand this new header format and at least provide support for bits 2 and 3 in the flags byte.  When MOS Modules are introduced, bits 0 and bit 1 will be supported.</p>"},{"location":"mos/Modules/","title":"MOS Modules","text":"<p>As of MOS 3.0, MOS does not have a module system.  However it is highly likely that one will be introduced in the future, most likely in either in MOS 3.1 or MOS 3.2.</p> <p>As we add new features to MOS, its size is growing, and we are fast running out of space in the flash memory of the eZ80 CPU where MOS is stored.  We therefore have a choice: stop adding new features, or find a way to allow those new features without taking up more space in the flash memory.</p> <p>\"Stop adding new features\" wouldn't be a popular option as we have lots of ideas for new features we'd like to add to MOS.  One possibility is to work really hard to make MOS smaller, but that would have its limits too.</p> <p>A better solution is to allow some parts of MOS to be loaded and unloaded from the SD card at run-time.  A module system.</p> <p>Note</p> <p>It is possible that some of the new commands and APIs added in MOS 3.0 may be moved into modules in the future.  To guarantee that a program using these features will work in the future, you will need to ensure that your program is \"module safe\", and ensure your program has an appropriate header.</p> <p>The MOS module system is still being designed and developed, and so the exact details of how it will work have not yet been finalised.  The following things howver are likely to be true.</p>"},{"location":"mos/Modules/#core-mos","title":"\"Core MOS\"","text":"<p>\"Core MOS\" will be the part of MOS that is always present, and which cannot be unloaded.  The exact details of what will be included in \"Core MOS\" are still being worked out, but for compatibility with existing programs written for MOS 1 and MOS 2, all of the star commands and APIs present up to and including MOS 2.3 will be included in \"Core MOS\".</p> <p>Some new features added in MOS 3.0 will also be included in \"Core MOS\", but not all of them.  For example, the underlying functionality that supports System Variables will need to be present in \"Core MOS\", however it may not be necessary to include all of the star commands and APIs used to manage them.  It is possible that some of these may be moved into a module.</p> <p>As we add new features to MOS we will need to carefully consider which features need to be a part of \"Core MOS\" and therefore always present, and which can be implemented in modules.</p>"},{"location":"mos/Modules/#what-mos-modules-may-contain","title":"What MOS modules may contain","text":"<p>It is highly likely that MOS modules will be able to include implementations of API calls, star commands, as well as C functions.  The module design is likely to use an extensible format to allow for future expansion, allowing us to add new types of functionality to modules in the future.</p>"},{"location":"mos/Modules/#how-modules-are-likely-to-work","title":"How modules are likely to work","text":"<p>MOS modules will almost certainly be loaded into the \"moslet\" area of memory.  This area of memory is defined as the RAM from address <code>0xB0000</code> to <code>0xB7FFF</code>, which is 32 kilobytes in size, which will therefore be the module size limit.</p> <p>When attempting to use a star command or API call that is implemented in a module, MOS will take care of loading the module into memory as required.  (This will be fairly sophisticated behaviour so as to support calling features in one module present in another module, and so on.)</p> <p>The reality of the Agon platform however is that access to RAM from the eZ80 CPU is not, and cannot be, restricted.  A program can therefore potentially use the moslet area of memory should it choose to do so.</p> <p>Existing programs may therefore be using the moslet area of memory.  There could therefore be problems if a module is loaded there, as the program's code or data could be overwritten, causing it to crash or behave unexpectedly.</p> <p>The solution to this will be for programs to be \"module safe\".</p> <p>A new advanced executable header format has been introduced with MOS 3.0 to allow for programs to indicate to MOS whether they are \"module safe\" or \"module compatible\".</p>"},{"location":"mos/Modules/#module-safe-programs","title":"\"Module safe\" programs","text":"<p>A program is \"module safe\" if it does not use the moslet area of memory.</p> <p>This means that the program can safely use any and all of the features provided by modules, and will not be affected by a module being loaded into RAM.</p>"},{"location":"mos/Modules/#module-compatible-programs","title":"\"Module compatible\" programs","text":"<p>A \"module compatible\" program is one that uses the moslet area of memory, but does so in a way that is compatible with modules.</p> <p>When MOS detects a program that is marked as \"module compatible\", and the program attempts to use a feature that is implemented in a module, it will save the contents of the moslet area of memory to disk before loading the module.  When the module has finished executing, MOS will restore the contents of the moslet area of memory from disk.</p> <p>A \"module compatible\" program must ensure that any API calls it makes will not use the moslet area of memory for data buffers.  Ideally API calls implemented in modules will detect when they are being given a buffer that overlaps the moslet area and return an error, but this cannot be guaranteed.</p> <p>It will be safe for a \"module compatible\" program to use \"Core MOS\" APIs to be passed buffers that overlap the moslet area of memory.</p>"},{"location":"mos/Modules/#using-modules-from-moslets","title":"Using modules from moslets","text":"<p>As moslets are designed to be loaded into the same area of memory as modules, it is not possible to use features provided by modules from moslets, and unlikely that this will be possible in the future.</p> <p>It should be noted however that the purpose of moslets was essentially to provide a way to add new star commands to MOS.  As modules provide a different way to add new star commands to MOS, arguably we do not need to add support for using modules from moslets.</p> <p>Unfortunately this means that if you write a moslet today that uses a MOS 3.0 API that is later moved into a module, it will not be able to run in future versions of MOS.  Calls to that API will fail with an error indicating that the API is not available.  You will likely need to rewrite your moslet to be a module instead that provides a star command.</p>"},{"location":"mos/Modules/#the-future-of-modules","title":"The future of modules","text":"<p>The exact details of the module system will likely change and evolve as the system is developed.</p> <p>Some possibilities for the future include:</p> <ul> <li>\"Driver\" modules<ul> <li>One of the oldest ideas we had for a MOS module was for a \"joystick module\".  The concept was to define a standard set of Joystick APIs, but to load a joystick driver module specific for the joystick interface being used that implemented those APIs.  Whilst the Agon community has mostly settled on the joystick interface system used by the Agon Console8, other interfaces do exist.</li> <li>Other types of \"driver\" modules could be considered</li> </ul> </li> <li>I/O modules<ul> <li>A concept being considered for a future version of MOS is \"unified I/O\", which would allow lots of different types of I/O to be performed in a consistent way</li> <li>An I/O module could contain data that identifies which \"stream\" identifier it implements connections for, and implement a set of functions to support that stream</li> </ul> </li> <li>User-defined/provided modules<ul> <li>In principle, users should be able to create their own modules to extend MOS</li> <li>These could add new star commands, APIs, or C functions, or whatever other functionality is supported by the module system</li> <li>In the case of APIs, we may need to have a registration system to ensure that the same API number does not get multiple different and incompatible/conflicting implementations</li> </ul> </li> <li>Non-code modules<ul> <li>If modules are implemented in an extensible format, this may allow for modules to be used to store other things, such as data files, bitmaps, or other resources</li> </ul> </li> <li>User-space modules<ul> <li>It may be possible to allow the module system to be used by programs to load and unload modules into their own address space, rather than the moslet area of memory</li> <li>By using user-space modules, a program could potentially load/unload multiple modules simultaneously, and use them to extend the program's functionality</li> <li>The use of non-code modules could be useful here; for example a game could use modules for level data, or other resources</li> </ul> </li> </ul>"},{"location":"mos/Modules/#more-information","title":"More information","text":"<p>At the time of writing the full details of the MOS module system are still being worked out.  If you wish to learn more and see how these ideas develop you can check the corresponding issue on GitHub.</p>"},{"location":"mos/Star-Commands/","title":"MOS Commands","text":"<p>MOS contains a number of inbuilt commands that are always available to the MOS CLI.  These are sometimes referred to as \"star commands\" because the MOS command line interpreter has historically used a <code>*</code> character as its command prompt, and additionally these commands can be used from inside BBC BASIC by prefixing them with a <code>*</code> character.</p> <p>MOS commands are case-insensitive, and can be abbreviated with a dot <code>.</code>.  For example, <code>Delete myfile</code>, <code>DELETE myfile</code> and <code>DEL. myfile</code> are all equivalent.  When you abbreviate a command, the first matching command is used, so whilst there are several commands that begin with <code>C</code>, <code>C.</code> will execute the <code>CAT</code>.  Commands that accept multiple parameters will expect those parameters to be space-delimited.</p> <p>You should note that across versions of MOS, command abbreviations may change, as new commands may be added.  When writing script files, or using commands in BBC BASIC programs, it is recommended to use the full command name to avoid any potential issues with command abbreviations changing.</p> <p>Commands that expect a number will, by default, expect that number to be given in decimal.  To specify a hexadecimal number, prefix it with an ampersand <code>&amp;</code>.  For example, <code>*JMP &amp;8000</code> will jump to address <code>&amp;8000</code>.</p> <p>MOS 3 extends the CLI number support allowing them to be provided in various other formats.  Hexadecimal numbers can be specified with a <code>0x</code> prefix, or an <code>h</code> suffix.  Numbers in any numeric base from 2 to 36 can also be used by prefixing the number with the base (in decimal) followed by an underscore and then the number.  For instance, <code>2_111</code> indicates the binary number <code>111</code> (7 in decimal), <code>16_41</code> is hexadecimal number <code>41</code> (65 in decimal), and <code>8_72</code> is octal <code>72</code> (58 in decimal).</p> <p>To aid users coming from other systems, several commands have aliases built in, for example <code>Delete</code> and <code>Erase</code> are equivalent.  The aliases are listed in the command descriptions below.</p> <p>As of MOS 3.0, MOS also supports user-defined aliases.  For compatibility the existing aliases supported in MOS 2 are maintained.  MOS 3.0 also allows the use of system variables in the command line.  For information on how variables are interpreted and expanded in commands, see the <code>echo</code> command.  Support for custom files paths in commands, which can be used for any command that requires a file or directory name, is also now included.</p> <p>The various commands MOS supports are described below.  Commands parameters are described with angle brackets <code>&lt;param&gt;</code> and optional parameters are indicated with square brackets <code>[&lt;param&gt;]</code> or <code>[-flag]</code>, and alternative parameters are shown either side of a <code>|</code> character.</p> <p>Any command that requires a memory address will expect a 24-bit address value.</p> <p>The commands available in MOS are as follows:</p>"},{"location":"mos/Star-Commands/#comment-hash","title":"'#'","text":"<p>Syntax: <code>*#&lt;text&gt;</code></p> <p>The command interpreter ignores any command that starts with a <code>#</code> character.  This can be used to add comments to a script file, or to disable a command in a script without deleting it.</p> <p>Support for comments using <code>#</code> was added in MOS 2.2.0.</p>"},{"location":"mos/Star-Commands/#comment-pipe","title":"<code>|</code>","text":"<p>Syntax: <code>*| &lt;text&gt;</code></p> <p>The command interpreter will ignore any command that starts with a <code>|</code> character followed by a space.  As with <code>#</code>, this can be used to add comments to a script file, or to disable a command in a script without deleting it.</p> <p>Support for comments using <code>|</code> was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#skip-aliases","title":"<code>%</code>","text":"<p>Syntax: <code>*%&lt;command&gt;</code></p> <p>Prefixing any command with the <code>%</code> character makes the command interpreter skip command alias resolution.  This means for example that you could redefine an internal MOS command with an alias, but have the alias make sure it uses the original command.  NB unlike other commands, no space is required after the <code>%</code> character.</p> <p>This feature was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#dot","title":"<code>.</code> (dot)","text":"<p>Syntax: <code>*. [-l] [-a] [-s] [-v] [&lt;path&gt;]</code> (Alias for <code>Cat</code>)</p> <p>This command is an alias for the <code>Cat</code> command.  Please see the <code>Cat</code> command for more information on how this command works and the options it supports.</p>"},{"location":"mos/Star-Commands/#cat","title":"<code>Cat</code>","text":"<p>Syntax: <code>*Cat [-l] [-a] [-s] [-v] [&lt;path&gt;]</code> (Aliases include <code>Dir</code> and <code>.</code>)</p> <p>The \"Catalogue\" command, which displays a directory listing of the current directory, or of the directory at the path given.</p> <p>Before MOS 2.2.0 this command did not support any flags and would always show a long-form directory listing of all files in a directory, which includes the file modification date/time, file size and file name.</p> <p>From MOS 2.2.0 onwards, by default a short listing is shown.  MOS 3.0 will, by default, hide hidden and system files from directory listings.</p> <p>The flags supported by the <code>Cat</code> command are as follows:</p> <ul> <li><code>-l</code>: Display the long form of the directory listing, which includes the file size and date/time of last modification, introduced in MOS 2.2.0</li> <li><code>-a</code>: Show hidden files, introduced in MOS 3.0</li> <li><code>-s</code>: Show system files, introduced in MOS 3.0</li> <li><code>-v</code>: Hide volume information, introduced in MOS 3.0</li> </ul> <p>When running MOS 3.0 with VDP 2.14.0 or later, the output of the <code>Cat</code> command and its various aliases can be automatically paged.  When auto-paging is enabled and the output is longer than the screen output will pause at the end of a page, and you will need to press the \"shift\" key to continue.</p>"},{"location":"mos/Star-Commands/#cd","title":"<code>CD</code>","text":"<p>Syntax: <code>*CD &lt;path&gt;</code></p> <p>Change current directory.</p> <p>The path provided to the <code>CD</code> command uses <code>/</code> as the directory separator, and can be either an absolute path or a relative path.  The root directory is <code>/</code>.  <code>CD ..</code> can be used to move up one directory level.</p>"},{"location":"mos/Star-Commands/#cdir","title":"<code>CDir</code>","text":"<p>Syntax: <code>*CDir &lt;path&gt;</code></p> <p>This command is an alias for the <code>CD</code> command.</p> <p>Available from MOS 2.2.0 onwards.</p>"},{"location":"mos/Star-Commands/#cls","title":"<code>CLS</code>","text":"<p>Syntax: <code>*CLS</code></p> <p>Clear the screen.</p> <p>(This command performs a <code>VDU 12</code>, which is the same as the <code>CLS</code> command in BBC BASIC.)</p>"},{"location":"mos/Star-Commands/#copy","title":"<code>Copy</code>","text":"<p>Syntax: <code>*Copy &lt;source&gt; &lt;destination&gt;</code></p> <p>Create a copy of a file.</p> <p>From MOS 2.2.0 onwards, the <code>Copy</code> command will also support the use of wildcards in the source file name, such as <code>*.txt</code>, and can support the destination being a directory.  It should be noted that the destination path cannot include wildcards.</p>"},{"location":"mos/Star-Commands/#cp","title":"<code>CP</code>","text":"<p>Syntax: <code>*CP &lt;source&gt; &lt;destination&gt;</code></p> <p>This command is an alias for the <code>Copy</code> command.</p> <p>Available from MOS 2.2.0 onwards.</p>"},{"location":"mos/Star-Commands/#credits","title":"<code>Credits</code>","text":"<p>Syntax: <code>*Credits</code></p> <p>Outputs some credits and version numbers for third-party libraries used in the Agon firmware.</p>"},{"location":"mos/Star-Commands/#delete","title":"<code>Delete</code>","text":"<p>Syntax: <code>*Delete [-f] &lt;filename&gt;</code> (Aliases include <code>Erase</code> and <code>RM</code>)</p> <p>Delete a file or folder (must be empty).</p> <p>As of Console8 VDP 2.2.0 this command supports wild-cards in the filename.  Additionally when deleting a file a confirmation step is required, but if the <code>-f</code> flag is provided then the command will not prompt for confirmation before deleting the file.</p>"},{"location":"mos/Star-Commands/#dir","title":"<code>Dir</code>","text":"<p>Syntax: <code>*Dir [-l] [-a] [-s] [-v] [&lt;path&gt;]</code></p> <p>This command is an alias for the <code>Cat</code> command.  Please see the <code>Cat</code> command for more information on how this command works and the options it supports.</p>"},{"location":"mos/Star-Commands/#do","title":"<code>Do</code>","text":"<p>Syntax: <code>*Do &lt;command&gt;</code></p> <p>Execute a command.  The command string passed to <code>Do</code> will be sent through the GSTrans transformation process before use, expanding any system variables that may be present in the arguments.  One use of this would be to allow for a variable to define which command to execute, which is not usually possible with the command interpreter.  Another use is to allow for commands that do not expand variables by default to use variable values, such as the <code>PrintF</code> command.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#echo","title":"<code>Echo</code>","text":"<p>Syntax: <code>*Echo &lt;text&gt;</code></p> <p>Prints the given text to the screen.  Before outputting the text is run through a transformation process which allows for the full use of the VDP's control codes.  If you are using MOS 3.0 or later, then you can also use system variables in the text.</p> <p>Text will be read one character at a time, and if a translation token is found then the text will be transformed accordingly.  The following tokens are supported:</p> Token Replaced by <code>|\"</code> <code>\"</code> <code>|&lt;</code> <code>&lt;</code> <code>||</code> <code>|</code> <code>|?</code> Character 127 (A deleting backspace) <code>|!</code> Forces top-bit of next character to be set <code>|char</code> Ctrl (ASCII (uppercase(char)) - 64) <code>&lt;num&gt;</code> Converts num to character <code>&lt;variable_name&gt;</code> Replaced with the value of the system variable <code>variable_name</code> (added in MOS 3) <p>The <code>|char</code> and <code>&lt;num&gt;</code> tokens provide a simple way to send \"control codes\" to the VDP.</p> <p>The <code>|char</code> token works with a single character, which will be replaced with the ASCII value of the uppercase character minus 64.  This means that a value of <code>|A</code> or <code>|a</code> will be replaced with character 1, <code>|B</code> or <code>|b</code> will be replaced with character 2, and so on, equivalent to performing a <code>VDU 1</code> or <code>VDU 2</code> respectively for <code>|a</code> and <code>|b</code>.  This provides a simple way to insert control codes into your text.  For example using <code>|M|J</code> will send characters 13 and 10, a carriage return and a line feed.  Using <code>|g</code> will send a \"bell\" character and make a beep sound.</p> <p>A <code>&lt;num&gt;</code> token will be replaced with the character represented by the number given.  For example using <code>&lt;65&gt;</code> will send the character <code>A</code>, and <code>&lt;13&gt;</code> will send a carriage return.  Various formats of number are recognised.  You can specify a specific base to be used for a number, so <code>&lt;2_111&gt;</code> specifies using number 111 in base 2, which will equate to 7 in decimal, and thus be the same as <code>|g</code> and make a beeping sound.  Similarly <code>&lt;3_21&gt;</code> also produces a beep (as 21 in base 3 is 7 in decimal).  Bases up to 36 are supported, with \"digits\" in bases over 10 using letters - the most common base over 10 would be base 16, hexadecimal.  You can also specify a hexadecimal number using the <code>&amp;</code> prefix, so <code>&lt;&amp;41&gt;</code> will also send the character <code>A</code>.</p> <p>These options are essentially just VDU commands that are being sent to the VDP - you should refer to the VDP documentation for all the commands available.</p> <p>Incomplete tokens, such as ending a string with <code>|</code> or <code>|!</code> will result in a <code>Bad string</code> error.</p> <p>When using MOS 2.3.0, if you had an invalid number inside <code>&lt;</code> and <code>&gt;</code> characters then the token would be ignored.  In MOS 3.0 the string between the <code>&lt;</code> and <code>&gt;</code> characters will be treated as a system variable name, and replaced with the value of that system variable.  If the variable does not exist, then the token will be ignored.</p> <p>Numeric system variables will be converted to text for output, and macro variables will be evaluated and expanded before being output.</p> <p>This command was added in MOS 2.3.0, and support for system variables added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#erase","title":"<code>Erase</code>","text":"<p>Syntax: <code>*Erase [-f] &lt;filename&gt;</code></p> <p>This command is an alias for the <code>Delete</code> command.</p>"},{"location":"mos/Star-Commands/#exec","title":"<code>Exec</code>","text":"<p>Syntax: <code>*Exec &lt;filename&gt;</code></p> <p>Executes commands from a text file.</p> <p>Commands will be executed one at a time.  If an error occurs processing a command, execution will stop and the error will be reported.</p> <p>(This is essentially how the <code>autoexec.txt</code> file is processed at boot time.)</p> <p>NB: This command is not available in Quark 1.04.</p>"},{"location":"mos/Star-Commands/#help","title":"<code>Help</code>","text":"<p>Syntax: <code>*Help [&lt;command&gt; | all]</code></p> <p>Displays help information for a command.  If no command is provided, a list of available commands will be displayed.</p> <p>NB prior to MOS 2.2.0 the <code>Help</code> command required a command name to be provided, or the <code>all</code> keyword to display all commands.</p> <p>As of MOS 3.0, the <code>Help</code> command will accept a space-separated list of commands to show help for, and will also match commands abreviated with a <code>.</code> in the same manner as the command line.  <code>*Help c.</code> for example would show help for all commands beginning with <code>C</code>.</p> <p>When running MOS 3.0 with VDP 2.14.0 or later, the output of the <code>Help</code> command can be automatically paged.  When auto-paging is enabled and the output is longer than the screen output will pause at the end of a page, and you will need to press the \"shift\" key to continue.</p>"},{"location":"mos/Star-Commands/#hotkey","title":"<code>Hotkey</code>","text":"<p>Syntax: <code>*Hotkey [&lt;n&gt; [&lt;command string&gt;]]</code></p> <p>Sets or clears programmable function keys.</p> <p>Using this command you can set the function keys <code>F1-F12</code> on your to perform a specific command.  There are three ways in which this command works:</p> <ol> <li>If no parameters are provided, then the current hotkeys will be displayed.</li> <li>If a function key number <code>n</code> is provided alone without a command string, then the current command assigned to that function key will be cleared.</li> <li>If a function key number <code>n</code> and a command string are provided, then the command string will be assigned to that function key.<ul> <li>If the command string includes <code>%s</code> then the current input line will be substituted in place of <code>%s</code></li> <li>MOS 3.0 supports more sophisticated argument substitution options</li> </ul> </li> </ol> <p>Pressing a function key that has a hotkey definition set will result in the current input line being replaced with the defined hotkey string and \"return\" being automatically pressed.</p> <p>As of MOS 3.0, hotkeys are stored using system variables, and can be defined using the <code>Set</code> or <code>SetMacro</code> commands.  By directly setting the corresponding variables you can define hotkeys that do not automatically press \"return\".  For more information how how hotkeys are handled, and suggestions on how to allow a hotkey to trigger multiple commands, see the hotkey system variable documentation.</p>"},{"location":"mos/Star-Commands/#if","title":"<code>If</code>","text":"<p>Syntax: <code>*If &lt;expression&gt; Then &lt;command&gt; [Else &lt;command&gt;]</code></p> <p>Conditionally execute another command depending on the value of an expression.</p> <p>At the time of writing, <code>&lt;expression&gt;</code> can only be a variable name or a number, as there is not yet a full expression engine available.  The expression will evaluate as true if the variable exists and is either non-zero (for numeric variables) or not an empty string.</p> <p>The absence of a full expression engine in MOS means that it is not currently possible to check only for the non-existence of a variable as you must always include a <code>then</code> command.  There are a few ways to work around this limitation.  One example would be <code>*if MyVar then try invalid-command else echo MyVar does not exist</code>, although this would set Try related system variables.  An alternative approach would be <code>*if MyVar then set MyVar &lt;MyVar&gt; else echo MyVar does not exist</code>, which would just set MyVar to its current value if it already existed.</p> <p>Support for this command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#ifthere","title":"<code>IfThere</code>","text":"<p>Syntax: <code>*IfThere &lt;filename&gt; Then &lt;command&gt; [Else &lt;command&gt;]</code></p> <p>Conditionally executes another command depending on the presence of a file or directory.</p> <p>Support for this command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#jmp","title":"<code>JMP</code>","text":"<p>Syntax: <code>*JMP &lt;address&gt;</code></p> <p>Jumps to the specified address in memory.  Using this command, you can jump to any address in memory, including the ROM.  If used from the MOS command line, the processor will be in the eZ80 ADL mode.</p>"},{"location":"mos/Star-Commands/#load","title":"<code>Load</code>","text":"<p>Syntax: <code>*Load &lt;filename&gt; [&lt;address&gt;]</code></p> <p>Load a file from the SD card into the specified address in memory.  If no address parameters is specified, then the address will default to <code>&amp;40000</code>.</p>"},{"location":"mos/Star-Commands/#loadfile","title":"<code>LoadFile</code>","text":"<p>Syntax: <code>*LoadFile &lt;filename&gt; [&lt;arguments&gt;]</code></p> <p>This command will load a file in a manner appropriate to the file type.  MOS looks up the \"load type\" information for the file based on its file name extension using a matching system variable, and will then execute the appropriate command to load the file.  If the file type is not recognised, then you will see an \"Invalid command\" error.</p> <p>For more information see the documentation for the corresponding system variables.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#ls","title":"<code>LS</code>","text":"<p>Syntax: <code>*LS [-l] [-a] [-s] [-v] [&lt;path&gt;]</code></p> <p>This command is an alias for the <code>Cat</code> command.  Please see the <code>Cat</code> command for more information on how this command works and the options it supports.</p>"},{"location":"mos/Star-Commands/#mem","title":"<code>Mem</code>","text":"<p>Syntax: <code>*Mem</code></p> <p>Displays information on MOS memory usage.</p>"},{"location":"mos/Star-Commands/#mkdir","title":"<code>MkDir</code>","text":"<p>Syntax: <code>*MkDir &lt;name&gt;</code></p> <p>Make a new directory on the SD card.</p>"},{"location":"mos/Star-Commands/#mount","title":"<code>Mount</code>","text":"<p>Syntax: <code>*Mount</code></p> <p>Mount the SD card.</p> <p>If you have ejected your SD card, you can use this command to re-mount it.</p>"},{"location":"mos/Star-Commands/#move","title":"<code>Move</code>","text":"<p>Syntax: <code>*Move &lt;source&gt; &lt;destination&gt;</code></p> <p>This command is an alias for the <code>Rename</code> command.</p>"},{"location":"mos/Star-Commands/#mv","title":"<code>MV</code>","text":"<p>Syntax: <code>*MV &lt;source&gt; &lt;destination&gt;</code></p> <p>This command is an alias for the <code>Rename</code> command, and is available from MOS 2.2.0 onwards.</p>"},{"location":"mos/Star-Commands/#obey","title":"<code>Obey</code>","text":"<p>Syntax: <code>*Obey [-v] &lt;filename&gt; [&lt;arguments&gt;]</code></p> <p>Runs an Obey (script) file. The <code>Obey</code> command works in a similar manner to <code>Exec</code> but offers a few more features. Firstly running a script file with <code>Obey</code> will set a system variable <code>Obey$Dir</code> to reflect the directory in which the obey file is located. Secondly lines in an Obey file will have argument substitution run on them before they are executed.</p> <p>The <code>-v</code> flag makes the Obey file execute in \"verbose\" mode, printing each line out before it is executed.</p> <p>As with <code>Exec</code>, if a command fails in an obey file then the file execution will stop and the error from that command reported.</p> <p>By convention, an Obey file should use the file extension <code>.obey</code>.</p> <p>Support for this command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#printf","title":"<code>PrintF</code>","text":"<p>Syntax: <code>*PrintF &lt;string&gt;</code></p> <p>Prints the given string to the screen.  This command is similar to the <code>Echo</code> command, but supports a subset of unix-style escape transformations for the string, does not expand system variables by default, and does not automatically add a newline to the printed output.  Support for this command was added in MOS 2.3.0.</p> <p>The following escape sequences are supported:</p> Sequence Replaced by <code>\\f</code> Form feed <code>\\n</code> New line <code>\\r</code> Carriage return <code>\\t</code> Horizontal tab <code>\\\\</code> Backslash <code>\\xhh</code> Hexadecimal value <p>If an invalid escape sequence is found, it will be ignored/skipped.</p> <p>Please note that using the <code>Do</code> command will allow you to use system variables with the <code>PrintF</code> command, as any variables will be expanded.  So whilst <code>*PrintF &lt;Sys$Time&gt;</code> would just output the string <code>&lt;Sys$Time&gt;</code>, the current time can be printed using <code>*Do PrintF &lt;Sys$Time&gt;</code>.</p>"},{"location":"mos/Star-Commands/#rename","title":"<code>Rename</code>","text":"<p>Syntax: <code>*Rename &lt;source&gt; &lt;destination&gt;</code> (Aliases include <code>MOVE</code>)</p> <p>This is the command to rename a file or move a file to a different folder.</p> <p>To rename a file in the same folder.</p> <p><code>*Rename autoexec.txt autoexec.bak</code></p> <p>Rename a file and move to a different folder (the destination folder must exist).</p> <p><code>*Rename test.bas archive/test.bas</code></p> <p>From MOS 2.2.0 onwards, the <code>Rename</code> command also supports allowing the destination to specify a directory.  If the destination is a directory, the source file will be moved to that directory and keep the same filename.  Additionally if the destination is a directory then the source file specified can include a wildcard, such as <code>*.txt</code>.</p> <p>As of MOS 3.0, the <code>Rename</code> command supports the use of system variables and custom file paths inside both the source and destination file names.</p>"},{"location":"mos/Star-Commands/#rm","title":"<code>RM</code>","text":"<p>Syntax: <code>*RM [-f] &lt;filename&gt;</code></p> <p>This command is an alias for the <code>Delete</code> command, and is available from MOS 2.2.0 onwards.</p>"},{"location":"mos/Star-Commands/#run","title":"<code>Run</code>","text":"<p>Syntax: <code>*Run [&lt;address | .&gt; [&lt;parameters&gt;]]</code></p> <p>The <code>Run</code> command will call an executable binary loaded in memory. If no parameters are passed, then the address will default to <code>&amp;040000</code>.  The address parameter can also be replaced with <code>.</code> to indicate that the default address of <code>&amp;040000</code> should be used.  Any additional parameters will be passed through to the executable.</p> <p>When using the <code>Run</code> command, MOS will check for the presence of a valid executable at the given address by looking for valid header.  If the header header is not found, or is invalid, then it will return an \"Invalid executable\" error.</p> <p>More information about parameters that will be passed to an executable when it is run can be found in the executable documentation.</p>"},{"location":"mos/Star-Commands/#runbin","title":"<code>RunBin</code>","text":"<p>Syntax: <code>*RunBin &lt;filename&gt; [&lt;arguments&gt;]</code></p> <p>This command will load and run a binary file. It differs from performing a <code>Load</code> followed by a <code>Run</code> in that it will work out the appropriate memory address to load the file into.  This is done by comparing the path to the given file with the current <code>Moslet$Path</code> system variable, so moslets will get loaded and run at the appropriate moslet memory location.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#runfile","title":"<code>RunFile</code>","text":"<p>Syntax: <code>*RunFile &lt;filename&gt; [&lt;arguments&gt;]</code></p> <p>This command will run a file in a manner appropriate to the file type.  MOS looks up the \"run type\" information for the file based on its file name extension using a matching system variable, and will then execute the appropriate command to run the file.  If the file type is not recognised, then you will see an \"Invalid command\" error.</p> <p>For more information see the documentation for the corresponding system variables.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#save","title":"<code>Save</code>","text":"<p>Syntax: <code>*Save &lt;filename&gt; &lt;address&gt; &lt;size&gt;</code></p> <p>Save a block of memory to the SD card.</p>"},{"location":"mos/Star-Commands/#set","title":"<code>Set</code>","text":"<p>Syntax: <code>*Set &lt;option&gt; &lt;value&gt;</code> Syntax: <code>*Set &lt;variable-name&gt; &lt;value&gt;</code> (MOS 3.0 or later)</p> <p>Set a system option, or a system variable.</p> <p>NB before MOS 2.2.0 the <code>Set</code> command was case-sensitive for the option name.</p> <p>On MOS 2.3.x or earlier this command would only support two system options, <code>KEYBOARD</code> and <code>CONSOLE</code>, as documented below.</p>"},{"location":"mos/Star-Commands/#keyboard-layout","title":"Keyboard Layout","text":"<p>Syntax: <code>*SET KEYBOARD &lt;n&gt;</code></p> <p>Sets the current system keyboard layout.</p> <ul> <li>0: UK (default)</li> <li>1: US</li> <li>2: German</li> <li>3: Italian</li> <li>4: Spanish</li> <li>5: French</li> <li>6: Belgian</li> <li>7: Norwegian</li> <li>8: Japanese</li> <li>9: US International *</li> <li>10: US International (alternative) *</li> <li>11: Swiss (German) *</li> <li>12: Swiss (French) *</li> <li>13: Danish *</li> <li>14: Swedish *</li> <li>15: Portuguese *</li> <li>16: Brazilian Portuguese *</li> <li>17: Dvorak *</li> </ul> <p>* These layouts are only supported from MOS 2.2.0 onwards.  The exact keyboard layouts supported will depend on the version of the VDP firmware you have installed.  Prior to MOS 2.2.0 keyboard values of 9 or above would be ignored.  From MOS 2.2.0 onwards any keyboard value can be specified - if the keyboard layout is not supported by the VDP firmware then it will be ignored.</p>"},{"location":"mos/Star-Commands/#console-mode","title":"Console Mode","text":"<p>Syntax: <code>*SET CONSOLE &lt;n&gt;</code></p> <p>Sets the console mode, where if <code>n</code> is <code>0</code> then console mode will be disabled, and if <code>n</code> is <code>1</code> then console mode will be enabled.</p> <p>When console mode is enabled, all (initial) \"command\" and text bytes sent to the VDP will be echoed out of the VDP to any attached USB serial device.  This can be useful for debugging purposes.</p> <p>It is recommended that instead of using this command, if you are running Console8 VDP 2.5.0 or later, you should use <code>VDU 2</code> instead to enable the \"printer\", which also outputs from the VDP to the same serial device.  The main difference is that the \"printer\" device will filter out any control codes, providing a safer output, whereas the console mode will output everything.  The printer can be disabled with <code>VDU 3</code>.  Additionally pressing <code>CTRL+B</code> on the keyboard will enable the printer, <code>CTRL+C</code> will disable it, and <code>CTRL+P</code> will toggle it.</p>"},{"location":"mos/Star-Commands/#system-variables","title":"System Variables","text":"<p>From MOS 3.0 onwards, the <code>Set</code> command can also be used to set system variables.  The syntax for setting a system variable is <code>*Set &lt;variable-name&gt; &lt;value&gt;</code>.</p> <p>When you use this command a string-type system variable of the given name will either be set or changed to the given value.</p> <p>Some variables provided by MOS are \"code\" type variables, which means that they are not just a simple string, but have some special behaviour.  Examples of these are the <code>Sys$Date</code>, <code>Sys$Time</code> and <code>Sys$Year</code> variables which expose the real-time clock as system variables.  Attempting to set any of these date/time variables will adjust the real-time clock on the system.  The prior uses of the <code>Set</code> command for <code>keyboard</code> and <code>console</code> are both supported via \"code\" variables, so existing scripts that use those commands will continue to work.</p> <p>It should be noted that the \"value\" part of this command is transformed when the variable is set, so for example <code>Set TimeNow The time is &lt;sys$time&gt;</code> will set the <code>TimeNow</code> variable to a string with the time when the command was executed.  Thus if you then did an <code>Echo &lt;timenow&gt;</code> you would see the time when the <code>Set</code> command was run.  To avoid this problem you should use the <code>SetMacro</code> command instead.</p>"},{"location":"mos/Star-Commands/#seteval","title":"<code>SetEval</code>","text":"<p>Syntax: <code>*SetEval &lt;variable-name&gt; &lt;expression&gt;</code></p> <p>This command evaluates an expression and sets the named variable to the result.</p> <p>As of when this document was written, MOS does not yet have a full expression engine.  For now, when you use <code>SetEval</code> it will create (or replace) the named variable with the result of the expression.  If the expression is a number, or refers to a number variable, then the resultant variable will be a \"number\" type variable of the value given.  If the expression is a string (or a macro) then the new variable will be a \"string\" type variable copy of the named variable.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#setmacro","title":"<code>SetMacro</code>","text":"<p>Syntax: <code>*SetMacro &lt;variable-name&gt; &lt;value&gt;</code></p> <p>This works in a similar manner to the <code>Set</code> command but will set a \"macro\" style variable.  With a macro, the variable value is not pre-transformed when the variable is set, but instead will get transformed when the variable is used.  This means that <code>SetMacro TimeNow The time is &lt;sys$time&gt;</code> would mean that a command to <code>Echo &lt;TimeNow&gt;</code> would show the time when the command is executed, not when the variable was defined.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#show","title":"<code>Show</code>","text":"<p>Syntax: <code>*Show [&lt;variable-name&gt;]</code></p> <p>Displays the value of a system variable matching the given name.</p> <p>The name given can use wildcards, specifically <code>*</code> to match any number of characters, and <code>#</code> to match a single character.  All variables matching the given pattern will be shown.  If no variable name is provided, then all system variables will be displayed.</p> <p>This command was added in MOS 3.0.</p> <p>When running MOS 3.0 with VDP 2.14.0 or later, the output of the <code>Show</code> command can be automatically paged.  When auto-paging is enabled and the output is longer than the screen output will pause at the end of a page, and you will need to press the \"shift\" key to continue.</p>"},{"location":"mos/Star-Commands/#time","title":"<code>Time</code>","text":"<p>Syntax: <code>*Time [&lt;YYYY&gt; &lt;MM&gt; &lt;DD&gt; &lt;hh&gt; &lt;mm&gt; &lt;ss&gt;]</code></p> <p>Set and read the ESP32 real-time clock.</p> <p>When no parameters are provided, the current date and time will be displayed.  Setting the real-time clock requires a complete set of parameters, including the year, month, day, hour, minute and second.  </p> <p>It should be noted that the Agon platform has no concept of time zones, or daylight savings time, so you should consider the time set as your local time.</p>"},{"location":"mos/Star-Commands/#try","title":"<code>Try</code>","text":"<p>Syntax: <code>*Try &lt;command&gt;</code></p> <p><code>Try</code> will perform the given command, trapping any errors that may occur.  It will set <code>Try$ReturnCode</code> with the return code value for the command, and if an error occurred it will set <code>Try$Error</code> to the corresponding error string.</p> <p>The <code>Try</code> command allows for commands that can fail to be included in script files that are run using <code>Exec</code> or <code>Obey</code> as they allow for the execution of the script to continue.</p> <p>This command was added in MOS 3.0.</p>"},{"location":"mos/Star-Commands/#type","title":"<code>Type</code>","text":"<p>Syntax: <code>*Type &lt;filename&gt;</code></p> <p>Display the contents of a text file on the screen.</p> <p>From MOS 3.0 onwards the <code>Type</code> command is tolerant of control characters in the file, and will display them by \"escaping\" them, showing them as a two character combination of a <code>|</code> character followed by a letter corresponding to the control character.  For example, a carriage return will be displayed as <code>|M</code>, and a line feed as <code>|J</code>.  This is similar to how the <code>Echo</code> command works.  Prior to MOS 3.0 the <code>Type</code> command would not check for control characters and just output the file as-is to the screen which could cause unexpected results.</p> <p>When running MOS 3.0.1 with VDP 2.14.0 or later, the output of the <code>Type</code> command can be automatically paged.  When auto-paging is enabled and the output is longer than the screen output will pause at the end of a page, and you will need to press the \"shift\" key to continue.</p>"},{"location":"mos/Star-Commands/#unset","title":"<code>Unset</code>","text":"<p>Syntax: <code>*Unset &lt;variable-name&gt;</code></p> <p>Unsets a system variable matching the given variable name.  This will work for any variable set, except for code variables which cannot be unset.  As with the <code>Show</code> command, the variable name given can include wildcards, in which case all variables that match the given name pattern will be removed.</p>"},{"location":"mos/Star-Commands/#vdu","title":"<code>VDU</code>","text":"<p>Syntax: <code>*VDU &lt;char1&gt; &lt;char2&gt; ... &lt;charN&gt;</code></p> <p>Write a stream of character bytes to the VDP.  This can be used to perform various control functions, such as clearing the screen, changing the screen mode, setting the cursor position, or changing the text colour.  More information on VDU commands can be found in the VDP documentation.</p> <p>This command is similar to the <code>VDU</code> command in BBC BASIC, but instead of separating arguments with commas you must instead separate them with spaces.</p> <p>Prior to MOS 2.2.0, the <code>VDU</code> command would only accept 8-bit numbers as arguments.  Any values provided greater than 255 would be ignored.</p> <p>From MOS 2.2.0 onwards this command will now also support 16-bit numbers as arguments, and several different ways to indicate hexadecimal numbers.  The BBC BASIC standard of suffixing a number with a semicolon character <code>;</code> to indicate a 16-bit number is supported.  As well as the <code>&amp;</code> prefix for hexadecimal numbers, you can also use <code>0x</code> as a prefix, or <code>h</code> as a suffix.  Hexadecimal numbers provided greater than 255 will always be treated as 16-bit numbers.</p> <p>As noted above, from MOS 3.0 on numbers can be provided in various other formats, which is supported by the <code>VDU</code> command.</p>"},{"location":"mos/System-Variables/","title":"System Variables","text":"<p>System variables are global variables that store various settings relating to different parts of the current operating system environment.  MOS support a few different types of system variables, and they are used by the system in several different ways.</p> <p>Applications/programs are welcome to use system variables for their own needs.  MOS provides two API calls to allow for variables to be read and written by application code, and the command line also has several commands that will make use of system variables.</p> <p>System variables are a new feature added to MOS 3.0.</p>"},{"location":"mos/System-Variables/#type-of-system-variables","title":"Type of System Variables","text":"<p>There are a few different data types that system variables can be.  The following are the types of system variables that are supported by MOS:</p> Type Description How to set How to remove String A string of characters <code>*Set</code> <code>*Unset</code> Integer Three-byte integers <code>*SetEval</code> <code>*Unset</code> Macros Macros are strings that can be expanded, passed through the GSTrans mechanism, when they are read <code>*SetMacro</code> <code>*Unset</code> Code A machine code routine will be called when the variable is read or set. This allows the OS to provide some more sophisticated behaviour, such as access to real-time clock data n/a n/a <p>The GSTrans mechanism is used by the command line in various ways.  For instance, when setting a system variable using the <code>*Set</code> command, the string value in the command line will first be passed through the GSTrans mechanism, allowing for variables to be expanded in the string before the variable is set.  The <code>*Echo</code> command also uses the GSTrans mechanism, allowing for variables to be expanded in the string that is echoed to the screen.</p>"},{"location":"mos/System-Variables/#naming-of-system-variables","title":"Naming of system variables","text":"<p>Users are free to name their system variables as they wish, but there are some limitations to bear in mind.</p> <ul> <li>Using wholly numeric names is not recommended, as this can cause difficulties with GSTrans operations when looking up a variable.  For instance, GSTrans will always interpret <code>&lt;123&gt;</code> to mean the ASCII character with the value 123, rather than looking up the name as a variable.</li> <li>When setting a variable, the case of a name is preserved, however variable lookup is not case-sensitive.  This means that <code>MyVar</code> and <code>myvar</code> are considered to be the same variable.</li> <li>Names can contain essentially any non-space, or non-control character</li> <li>When looking up variables, wildcard characters <code>#</code> and <code>*</code> can be used.  <code>#</code> will match any single character, and <code>*</code> will match any number of characters.</li> </ul> <p>By default, MOS's system variables follow a naming convention where the variable is named loosely in the format <code>Class$VariableName</code>.  You do not have to follow this convention, but following it can help to keep your variables organised.</p>"},{"location":"mos/System-Variables/#path-variables","title":"Path variables","text":"<p>Variables that are named in the format <code>Name$Path</code> are considered to be path variables.  When loading or running a file, MOS will supports prefixing filenames with a path and a colon.  Let's say we have a variable named <code>Foo$Path</code>, which is set to <code>/home/foo/</code>.  If you try to load a file named <code>Foo:Bar</code>, the system will look for the file <code>/home/foo/Bar</code>.</p> <p>Path variables can contain multiple paths to search, separated by commas.  For instance, if <code>Foo$Path</code> is set to <code>/home/foo/,/home/bar/</code>, the system will look for <code>Foo:Bar</code> in <code>/home/foo/Bar</code> and <code>/home/bar/Bar</code>, opening the first it finds.  If the file is not found in any of the paths and the file was opened for creation/update, the system will create the file in the first path in the list.</p> <p>It is important to note that directories used in path variables should end with a <code>/</code> character.  If this is omitted then the system will not be able to find files in that directory.  For example, if <code>Foo$Path</code> is set to <code>/home/foo</code>, then the system will look for <code>Foo:Bar</code> in <code>/home/fooBar</code>, which is unlikely to be correct.</p>"},{"location":"mos/System-Variables/#system-path-variables","title":"System Path variables: <code>Run$Path</code> and <code>Moslet$Path</code>","text":"<p>The MOS system makes use of two path variables, which it will set to default values on startup.  These are <code>Run$Path</code> and <code>Moslet$Path</code>.</p> <p>The <code>Moslet$Path</code> variable is used to identify the directory where \"moslet\" programs are located.  By default this will be set to <code>/mos/</code>.  Moslets differ from normal programs in that they are written to be loaded and run from a different memory location, which should usually allow them to be used whilst a different program is running.  Their purpose is essentially to allow for new star commands to be added to MOS.  When you run a program, the system will use this variable to check to see whether the program you are trying to run is a moslet, and if it is, it will load the moslet and run it in the moslet memory space.</p> <p>The <code>Run$Path</code> variable used to identify directories in which the command line should search when trying to run a program.  By default it is a macro variable set to <code>&lt;Moslet$Path&gt;, ./, /bin/</code>, which provides the same default search path for running programs as MOS 2.</p> <p>These variables can be redefined to allow you to change where the system looks for moslets and programs to run.</p>"},{"location":"mos/System-Variables/#application-variables","title":"Application variables","text":"<p>By convention, application variables are named in the format <code>App$VariableName</code> where <code>App</code> is the name of the application that the variable is associated with.  This helps prevent clashes between variables that serve similar purposes for different applications.</p> <p>If an application is started up using an <code>obey</code> file, then often the obey file will set a variable named in the format <code>App$Dir</code> or <code>App$Path</code> to represent the directory the program is located in, which may be used by the program to locate its resources.  Typically this is achieved with a command such as <code>set App$Dir &lt;Obey$Dir&gt;</code>.</p>"},{"location":"mos/System-Variables/#command-aliases","title":"Command aliases","text":"<p>If you set up a system variable in the format <code>Alias$Name</code> then this will set up a new command alias that can be used from the command line with the given name.  For example, one could add a new <code>Mode</code> command using <code>*set Alias$Mode vdu 22 %0</code>.  This would allow you to run the command <code>mode 1</code> to change the screen mode to mode 1.  The command will be expanded to <code>vdu 22 1</code> when the command is run.</p> <p>When attempting to interpret a command, the MOS command interpreter checks for aliases first.  As with regular commands the matching of the command name is not case-sensitive, and the command can be abbreviated with a <code>.</code> character.  So if you have defined the <code>Mode</code> command alias above, and no other aliases beginning with <code>m</code>, then <code>*m. 1</code> will be interpreted as <code>*mode 1</code>.  Only if no matching alias is found will the system look for a matching in-built command.</p> <p>Alias resolution can be disabled by prefixing a command with the <code>%</code> character.  So <code>*%m.</code> will skip alias resolution and run the first in-built command that matches <code>m.</code>, which in MOS 3.0 would be the <code>Mem</code> command.  Disabling alias resolution can be useful in script files to ensure you're running the command you expect, and not an alias that may have been defined by the user.</p> <p>Aliases support argument substitution.  Any unused arguments (beyond the last used argument) will be automatically appended to the end of the resultant command.</p> <p>An alias can include multiple commands, separated by carriage return characters (<code>|M</code>).  If one command in an alias sequence fails, the rest of the commands will not be executed, and the error reported.</p> <p>As an alias will append any unused arguments to the end of the command, the example above for a <code>mode</code> command is actually flawed.  Whilst <code>mode 1</code> would result in a <code>vdu 22 1</code> command, <code>mode 1 2 3 4</code> would result in the command <code>vdu 22 1 2 3 4</code> which is still technically a valid VDU command, but would send 3 extra bytes to the VDP, performing a <code>VDU 2</code>, <code>VDU 3</code> and <code>VDU 4</code> commands (enable printer, disable printer, and \"write text at text cursor\"), and is unlikely to be the intended behaviour.  Therefore a better version of the command would be <code>*set Alias$Mode vdu 22 %0|M#</code>.  This splits the alias into two separate commands, the first being a <code>vdu 22</code> passing in the first argument, and the second command will be a <code>#</code> with all other arguments following it.  The command interpreter considers commands beginning with a <code>#</code> to be a comment, and will ignore it.</p>"},{"location":"mos/System-Variables/#file-type-variables","title":"File load/run type aliases","text":"<p>System variables are used to define how certain files should be loaded or run when using either the <code>LoadFile</code> or <code>RunFile</code> commands.  Additionally the MOS 3 CLI will use run type aliases to determine how to run a file if the user enters a filename without a preceding command.</p> <p>Load and run type variables are a special type of command alias named in the format <code>Alias$@LoadType_extension</code> or <code>Alias$@RunType_extension</code>, where the <code>extension</code> matches the filing system extension for that file type.  As with command aliases, these support argument substitution.  The system defines a few such aliases by default.</p> <p>Attempting to load or run a file with an extension that does not have a corresponding alias (using <code>LoadFile</code> or <code>RunFile</code>) will result in an <code>Invalid command</code> error.</p> <p>The system will set a variable named either <code>LastFile$Run</code> or <code>LastFile$Load</code> to the alias expansion that was used to run or load the file.  This can be useful for debugging purposes, as it allows you to see exactly what command (or sequence of commands) was executed when the file was loaded or run.</p> <p>As load and run aliases are essentially a special type of command alias, they work in the same way as other aliases.  They can therefore also contain mutiple commands, separated by carriage return characters (<code>|M</code>), and will automatically append any unused arguments to the end of the expanded command string.</p> <p>MOS 3.0 contains a few built in file load and run-types.  These are:</p> Type variable File extension Definition Description <code>Alias$@LoadType_bin</code> <code>.bin</code> <code>Load %*0</code> Load a binary file <code>Alias$@LoadType_obey</code> <code>.obey</code> <code>Type %*0</code> Prints the contents of an obey file to the screen <code>Alias$@RunType_bas</code> <code>.bas</code> <code>BBCBasic %*0</code> Run a text-format BBC BASIC program * <code>Alias$@RunType_bbc</code> <code>.bbc</code> <code>BBCBasic %*0</code> Run a BBC BASIC program * <code>Alias$@RunType_bin</code> <code>.bin</code> <code>RunBin %*0</code> Run a binary file <code>Alias$@RunType_exec</code> <code>.exec</code> <code>Exec %*0</code> Run a script using the <code>*exec</code> command <code>Alias$@RunType_obey</code> <code>.obey</code> <code>Obey %*0</code> Run a script using the <code>*obey</code> command <p>* The aliases to run BBC BASIC assume that a <code>BBCBasic.bin</code> executable is present in your current run path.  Often this is the plain Z80 version of BASIC.  If you wish to use the eZ80 version of BASIC, or BASIC V, then you can either rename their executable to <code>BBCBasic.bin</code> or redefine the <code>Alias$@RunType_bas</code> and <code>Alias$@RunType_bbc</code> variables to point to the correct executable.  For example, if you have a copy of BBC BASIC V in your current run path, with an executable named <code>BBCBasicV.bin</code>, you could use the following commands to redefine the aliases:</p> <pre><code>*set Alias$@RunType_bas BBCBasicV %*0\n*set Alias$@RunType_bbc BBCBasicV %*0\n</code></pre> <p>It is common for boot-up scripts to set up load and run type variables to add support for other file types, or change the in-built behaviour.</p>"},{"location":"mos/System-Variables/#cli","title":"CLI","text":""},{"location":"mos/System-Variables/#cliprompt","title":"<code>CLI$Prompt</code>","text":"<p>The command prompt that the MOS CLI displays is defined using the variable named <code>CLI$Prompt</code>.  By default this is a macro set to <code>&lt;Current$Dir&gt; *</code> to match the default prompt from MOS 2.2 onwards.  The prompt can be changed to anything you like, and if it is set as a macro it can include variables that will be expanded when the prompt is displayed.</p> <p>If you unset the <code>CLI$Prompt</code> variable, the system will revert to displaying the default prompt which is <code>*</code>.</p>"},{"location":"mos/System-Variables/#autopaged","title":"<code>CLI$AutoPaged</code>","text":"<p>Setting a variable <code>CLI$AutoPaged</code> to any value will enable the auto-paging feature of the CLI, if you are using VDP 2.14.0 or later by temporarily enabling paged mode.  By default this variable is not set.</p> <p>When this variable is set then commands that can produce a lot of output will automatically use the VDP's \"paged mode\" for output.  This means that output will pause after a page of text has been displayed, and output will continue when the user presses the \"shift\" key.  This behaviour specifically applies to <code>*Dir</code> (and its various aliases), <code>*Help</code>, <code>*Show</code> and <code>*Type</code>.  Other commands that could produce a lot of output such as running a program or a script explicitly do not use this feature so as to allow the user to control the output.</p> <p>Auto-paging applies whether you are using the MOS command line, or executing MOS commands via some other means, such as using the <code>mos_oscli</code> API, or using the command from a BBC BASIC program.</p> <p>Support for this variable was added in MOS 3.0.1.  In MOS 3.0.0 the system would always use auto-paging, and the feature could not be disabled.</p> <p>To automatically enable paged mode for the CLI, you can add the following line to your boot script:</p> <pre><code>*set CLI$AutoPaged 1\n</code></pre>"},{"location":"mos/System-Variables/#obey-files","title":"Obey files: <code>Obey$Dir</code>","text":"<p>When an obey file is run with the <code>obey</code> command, the system will set the variable <code>Obey$Dir</code> to the directory that the obey file is located in.  This can be used by the obey file to locate resources that it needs to run.</p> <p>It should be noted that the <code>Obey$Dir</code> variable will not include a trailing <code>/</code> character, so if you are using it to build a path to a file, you will need to add the <code>/</code> character yourself.  For example, if you have an obey file located in <code>/home/foo/</code>, and wished from that obey file to run a program called <code>foo.bin</code> located in the same directory, your script should use the command <code>*RunBin &lt;Obey$Dir&gt;/foo.bin</code>.</p>"},{"location":"mos/System-Variables/#time-and-date","title":"Time and date: <code>Sys$Date</code>, <code>Sys$Time</code> and <code>Sys$Year</code>","text":"<p>MOS provides three system variables that expose the current real-time clock information.  These are <code>Sys$Date</code>, <code>Sys$Time</code> and <code>Sys$Year</code>.  The date variable is in the format of <code>Day, n Mon</code>.  It is possible to set these variables, and the real-time clock should update accordingly.  The exception to that is setting <code>Sys$Date</code> if the value cannot be interpreted as a valid date.</p> <p>The real-time clock information can also be displayed and updated using the <code>*Time</code> command</p>"},{"location":"mos/System-Variables/#hotkeys","title":"Hotkeys: <code>Hotkey$&lt;n&gt;</code>","text":"<p>Hotkey definitions are stored as system variables in the format <code>Hotkey$n</code> where <code>n</code> is a number from 1-12 equating to the F1-F12 keys on your keyboard.  Hotkeys can also be defined using the <code>*Hotkey</code> command.</p> <p>Hotkey definitions support argument substitution.  Any unused arguments are discarded.</p> <p>If a hotkey definition is set as a macro variable (using <code>SetMacro</code>), then the system will expand the macro when the hotkey is pressed.</p> <p>A hotkey definition that ends with a carriage return character (<code>|M</code>) will automatically press return when the hotkey is pressed.  When used in a CLI this means the command will execute immediately.  Hotkeys set using the <code>*Hotkey</code> will automatically append a carriage return to the end of the command.</p> <p>In MOS 3.0, whilst a hotkey variable can technically contain multiple lines, split by <code>|M</code>, the system will only use the first line of the variable, and the rest will be discarded.  This limitation is due to how the MOS line editor works.</p> <p>If you wish to create a hotkey that can run a sequence of commands then there are two options.  Firstly you could create an obey file, and define a hotkey to run the obey file passing in all the arguments.  Alternatively you could define a command alias that can run a sequence of commands, and define a hotkey to use that alias.  Please note that both of these options are only suitable for running multiple MOS commands, and cannot be used for multi-line input in other environments such as the BBC BASIC command line.</p> <p>Support for multiple commands in a hotkey may be added in a future version of MOS.</p>"},{"location":"mos/System-Variables/#system","title":"System","text":"<p>As noted above, there are several \"system\" variables that MOS provides to give access to system information and control how MOS behaves.</p> <p>Another two system variables are the <code>Console</code> variable and <code>Keyboard</code>.  These are two special write-only variables that will turn on or disable \"console mode\", and set the current keyboard layout respectively.  These variables are named to be compatible with earlier versions of MOS.</p>"},{"location":"mos/System-Variables/#return-codes","title":"Return codes","text":"<p>When a command or program finishes running MOS will set a numeric variable <code>Sys$ReturnCode</code> to indicate the success or failure of the program.  This variable is set to 0 if the program ran successfully, and to a non-zero value if the program reported an error.</p> <p>The <code>Try</code> command can also be used to run a command and set a system variable <code>Try$ReturnCode</code> to the return code of that command.  If an error occurred then a variable <code>Try$Error</code> will also be set to the error message.  This can be useful in script files to check for errors and take appropriate action.  Running commands without using the <code>Try</code> command inside a script file (executed using either <code>exec</code> or <code>obey</code>) that fail will cause the script to stop running.  You can then use the <code>if</code> command to check the return code and take appropriate action.</p>"},{"location":"vdp/Bitmaps-API/","title":"VDU 23, 27: Bitmaps, sprites, and mouse cursor","text":"<p>VDU 23, 27 is reserved for the bitmap, sprite, and mouse cursor functionality.</p> <p>As of VDP 1.04, the bitmap system is integrated with the Buffered Commands API.  Bitmap data is stored in buffers, and can be manipulated using the Buffered Commands API on the VDP.</p>"},{"location":"vdp/Bitmaps-API/#bitmaps","title":"Bitmaps","text":"<p>The bitmap system we have on the Agon uses commands that are inspired by Acorn's Graphics eXtension ROM (GXR) system.  Some mistakes were made in the original interpretation of the GXR commands, and so until the Console8 VDP 2.2.0 release it was not possible to use code written for GXR on the Agon.</p> <p>Acorn only actually had two VDU commands for what it called \"sprites\", which in the Agon we consider to be \"bitmaps\".  The first command was used to select a bitmap (so that it may later be used with an appropriate PLOT command), and the second was to define a bitmap from an area of screen.</p> <p>The approach taken on Agon (initially at least) was to redefine the \"define bitmap from screen\" command to instead allow the uploading of a binary bitmap image.  In doing so, the parameters of the command changed, and the bitmap identifier was lost from the command parameters.  Instead, on the Agon, you need to always perform a \"select bitmap\" command before any other bitmap commands to set the bitmap being used.  Additionally on the Agon, prior to Console8 VDP 2.2.0, plotting bitmaps could only be performed with a custom command, and not with the standard <code>PLOT</code> commands.</p> <p>As of Console8 VDP 2.2.0, it is now possible to use Acorn GXR style \"sprite\" code on an Agon.  The <code>PLOT</code> code for drawing bitmaps is now supported, and bitmap command 1 can now be used to capture screen data into a bitmap identically to the GXR.  The documentation on the <code>PLOT</code> command (<code>VDU 25</code>) explains how to use it to draw bitmaps.</p> <p>In addition to GXRs two commands, the Agon VDP has several other commands for managing bitmaps, and additional commands to manage \"sprites\".</p> <p>As has been noted above, bitmap data is stored in buffers.  Acorn's original API design only allows for a maximum of 255 bitmaps, as they used an 8-bit ID, however buffers are identified with a 16-bit identifier.  This means that the Agon VDP can support a much larger number of bitmaps, in theory up to 65534 of them.  To allow access to these additional bitmaps, the Agon VDP several additional commands working with bitmaps using 16-bit IDs.  Those 16-bit IDs directly correspond to the IDs of the buffers in which the bitmaps are stored.  Bitmaps with 8-bit IDs are automatically mapped onto buffer IDs in the range 64000-64255.</p> <p>In general, commands to manage bitmaps using 16-bit IDs are numbered 32 higher than the equivalent command using an 8-bit ID (32 is <code>&amp;20</code> in hexadecimal).  For instance, the command to select a bitmap with an 8-bit ID is <code>VDU 23, 27, 0, n</code>, whereas the command to select a bitmap with a 16-bit ID is <code>VDU 23, 27, &amp;20, bufferId;</code>.</p> <p>Storing bitmaps in buffers allows for their data to be manipulated using the buffered commands API.  This can, for instance, allow for the colours of bitmaps to be changed, or for a bitmap to be mirrored, or split into multiple bitmaps.</p> <p>* Commands marked with an asterisk are only available in VDP 2.2.0 or later. * Commands marked with a double asterisk are only available in VDP 2.6.0 or later. ** Commands marked with a triple asterisk are only available in VDP 2.12.0 or later.</p> <p>The commands to manage bitmaps are as follows:</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-0-n-select-bitmap-n","title":"<code>VDU 23, 27, 0, n</code>: Select bitmap n","text":"<p>This selects the bitmap with the given 8-bit ID as being the currently \"active\" bitmap for subsequent bitmap commands.</p> <p>As noted above, bitmaps with 8-bit IDs are stored in buffers with an ID of 64000+<code>n</code>.</p> <p>You need to select a bitmap before it can be plotted onto the screen or use any other bitmap commands.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-1-w-h-b1-b2-bn-load-colour-bitmap-data-into-current-bitmap","title":"<code>VDU 23, 27, 1, w; h; b1, b2 ... bn</code>: Load colour bitmap data into current bitmap","text":"<p>This command is used to load bitmap data directly into the currently selected bitmap.</p> <p>Before you can load bitmap data into a bitmap, you must first select the bitmap using <code>VDU 23, 27, 0, n</code>, where <code>n</code> is the 8-bit ID of the bitmap to be loaded, or using <code>VDU 23, 27, &amp;20, bufferId;</code> using a 16-bit buffer ID.</p> <p>The bitmap data is given as a series of bytes as part of the command in RGBA8888 format, meaning that each pixel is represented by four bytes, one each for the red, green, blue, and alpha components of the pixel.  Each component value is in the range of 0-255.  The bytes are given in row-major order, starting at the top left of the bitmap, and working across the rows, and then down the columns.</p> <p>The width and height of the bitmap must be given in pixels, and must match the number of bytes given in the data.  If the width and height do not match the data then the command will fail.</p> <p>It should be noted that whilst the image format supported by this command is for full 24-bit colour images with 256 levels of transparency (alpha) per pixel, the Agon hardware is only capable of displaying 2-bits per colour channel.  The graphics system also does not really support transparency, so any non-zero alpha value is interpreted as \"fully visible\".  Data loaded via this command remains in RGBA8888 format on the VDP, but is converted on the fly when the bitmap is drawn to the screen.</p> <p>(As RGBA8888 is a very wasteful format, given the hardware limitations, other options are now available.  Loading bitmaps with this command can take a long time, and it is not possible to intersperse other commands, such as showing progress on-screen, whilst the data is being sent.  There are however alternative ways of managing the data which avoids these issues.  Please see the section on \"Using buffers for bitmaps\" in the Buffered Commands API document for more information.)</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-1-n-0-0-capture-screen-data-into-bitmap-n","title":"<code>VDU 23, 27, 1, n, 0, 0;</code>: Capture screen data into bitmap n *","text":"<p>This command, added in Agon Console8 VDP 2.2.0, is compatible with the Acorn GXR command of the same number.  It captures the screen data into the bitmap with the given 8-bit ID.</p> <p>This version of the <code>VDU 23, 27, 1</code> command differs from the one documented before in that you do not need to explicitly select a bitmap before capturing screen data into it.  The bitmap ID is passed as a parameter to this version of the command.</p> <p>As you may have noticed, this command does not include any dimensions for the bitmap.  Those are set via the graphics system, taking the last two graphics cursor positions to define the bitmap rectangle.  Any <code>PLOT</code>, or <code>VDU 25</code>, style command will push the graphics cursor position - typically \"move\" style plot commands are used to define the rectangle.</p> <p>To be clear, this command should be performed after two \"move\" style PLOT commands.</p> <p>If a bitmap with the given ID already exists then it will be overwritten, and similarly if a buffer was already defined with the ID 64000+<code>n</code> then that will be overwritten too.</p> <p>Up to and including the Console8 VDP 2.5.0 release, the bitmap data captured using this command will be stored in \"native\" format.  The nature of the \"native\" format varies depending on the screen mode.  For all screen modes the bitmap will use 1 byte per pixel, but the data within that byte varies.  In 64 colour modes, the data is essentially in RGB222 with no alpha channel.  It is possible to convert bitmaps captured in 64 colour modes to RGBA2222 format by using the OR operation of the \"adjust\" command from the Buffered Commands API, ORing all the bytes in the bitmap's buffer with <code>&amp;C0</code> to set the pixel alpha bits to be \"opaque\", and then re-creating the bitmap from the corresponding buffer to be RGBA2222 (format 1).  For all other screen modes, the byte represents a palette index.  An unfortunate effect of this is that a bitmap captured in one screen mode may not be compatible with other screen modes.</p> <p>Also up to and including the Console8 VDP 2.5.0 release, bitmaps captured with this command would use \"exclusive\" coordinates, and so would be 1 pixel shorter and narrower than the area defined by the graphics cursor positions.  (This is not consistent with the behaviour of this command on Acorn systems.)</p> <p>From Console8 VDP 2.6.0, the bitmap data captured using this command will be stored in RGBA2222 format, regardless of the screen mode.  This is to ensure that the data is consistent and predictable, and to allow for the use of the bitmap in any screen mode.</p> <p>Bitmaps captured on Console8 VDP 2.6.0 or later also now use \"inclusive\" coordinates, and so will be 1 pixel taller and wider than bitmaps captured on earlier versions of the VDP.  This is to ensure that the bitmap captures the entire area defined by the graphics cursor positions.  This is consistent with the behaviour of this command on Acorn systems.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-2-w-h-col1-col2-create-a-solid-colour-rectangular-bitmap","title":"<code>VDU 23, 27, 2, w; h; col1; col2;</code>: Create a solid colour rectangular bitmap","text":"<p>Creates a new bitmap in RGBA8888 format with the given width and height, and fills it with a solid colour.  The colour is given as two 16-bit numbers, col1 and col2, which are combined to form a 32-bit number in RGBA colour range.</p> <p>The bitmap is created in the buffer with the ID 64000+<code>n</code>, where <code>n</code> is the 8-bit ID given in the command.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-3-x-y-draw-current-bitmap-on-screen-at-pixel-position-x-y","title":"<code>VDU 23, 27, 3, x; y;</code>: Draw current bitmap on screen at pixel position x, y","text":"<p>Prior to Agon Console8 VDP 2.2.0, this was the only way to draw a bitmap on-screen.  On more up to date VDP versions is strongly recommended that you use the appropriate PLOT command instead.</p> <p>Before this command can be used, a bitmap must be selected using <code>VDU 23, 27, 0, n</code>, where <code>n</code> is the 8-bit ID of the bitmap to be drawn, or using <code>VDU 23, 27, &amp;20, bufferId;</code> using a 16-bit buffer ID.</p> <p>The x and y parameters give the pixel position on the screen at which the top left corner of the bitmap will be drawn.  This is in contrast to <code>PLOT</code> commands which will (by default) use OS Coordinates, where the origin is at the bottom left of the screen and the screen is always considered to have the dimensions 1280x1024.</p> <p>Please note that this command does not obey the current graphics viewport or the currently selected coordinate system.  The bitmap will be drawn at the given pixel position, and will not be clipped by the viewport.  To draw bitmaps with clipping, you are advised to use the appropriate bitmap PLOT commands instead.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-20-bufferid-select-bitmap-using-a-16-bit-buffer-id","title":"<code>VDU 23, 27, &amp;20, bufferId;</code>: Select bitmap using a 16-bit buffer ID *","text":"<p>This command is essentially identical to <code>VDU 23, 27, 0, n</code>, however it uses a 16-bit buffer ID instead of an 8-bit bitmap ID.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-21-w-h-format-create-bitmap-from-selected-buffer","title":"<code>VDU 23, 27, &amp;21, w; h; format</code>: Create bitmap from selected buffer *","text":"<p>This command creates a new bitmap from the data in the currently selected buffer.</p> <p>Whilst bitmap data can be loaded into a buffer at any time, before that data can drawn on-screen it must be converted into a bitmap.  The VDP needs to understand the width and height of the bitmap, and the format of the data.  This command performs that conversion.</p> <p>Valid values for the format parameter are:</p> Value Meaning 0 RGBA8888 (4-bytes per pixel) 1 RGBA2222 (1-bytes per pixel) 2 Mono/Mask (1-bit per pixel) 3 Reserved for internal use by VDP (\"native\" format) <p>It should be noted that the \"alpha\" channel in both the RGBA8888 and RGBA2222 formats is not properly used by the Agon VDP.  Any non-zero value in the alpha channel is interpreted as \"fully visible\".  The Agon VDP does not currently support transparency.  The alpha channel is still stored in the bitmap data, and is used when the bitmap is drawn to the screen, but it is not used to blend the bitmap with the background.  (If we improve support for transparency in the future, to maintain compatibility we will do so by adding new bitmap formats, rather than changing the behaviour of the existing formats.)</p> <p>Mono/Mask bitmaps can be of any width, but their data must be sent using a whole number of bytes per row.  Mon/mask bitmaps are also required to have a colour, and will use the currently selected graphics foreground colour.  If you wish to use a different colour then you must change the graphics foreground colour before creating the bitmap.  Mono/mask bitmaps only draw their \"on\" pixels, and the \"off\" pixels are transparent.</p> <p>The use of the \"native\" format is reserved for internal use by the VDP.  They have some significant limitations, and are not intended for general use.</p> <p>As with <code>VDU 23, 27, 1, w; h; b1, b2...bn</code>, the width and height of the bitmap must be given in pixels, and must match the number of bytes given in the data.  If the width and height do not match the data then the command will fail.</p> <p>Prior to the Console8 VDP 2.2.0 release, mono/mask bitmaps were not supported.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-21-bitmapid-0","title":"<code>VDU 23, 27, &amp;21, bitmapId; 0;</code>","text":"<p>This command captures a bitmap from the screen into the buffer with the given 16-bit buffer ID.  It works the same as <code>VDU 23, 27, 1, n, 0, 0;</code>, but using a 16-bit buffer ID instead of an 8-bit bitmap ID.</p> <p>Support for this command was added in VDP 2.2.0.</p>"},{"location":"vdp/Bitmaps-API/#sprites","title":"Sprites","text":"<p>The Sprites system on the Agon VDP is an extension to the bitmap system.  For all versions of the VDP up to and including 2.11.0, they are not true \"hardware sprites\" as one might find on some 8-bit machines or consoles.  Instead they are best thought of as \"automatically drawn bitmaps\".  This brings with it some limitations, and some performance considerations.</p> <p>From VDP 2.12.0 onwards the VDP does support the option to mark some sprites as being \"hardware sprites\".  These have some different limitations and performance considerations.  For clarity when we need to differentiate between the two types of sprites, we will refer to the original sprites as \"software sprites\", and the new sprites as \"hardware sprites\".  In the VDP 2.12.0 release the hardware sprites feature is not enabled by default, and a test flag must be set to enable them using <code>VDU 23, 0, &amp;F8, 2; 1;</code>.</p> <p>For compatibility with existing software, all sprites are by default set to be software sprites.</p> <p>Technically the VDP can support up to 256 sprites.  They must be defined contiguously, and so the first sprite is sprite 0.  (In contrast, bitmaps can have any ID from 0 to 65534.)  Once a selection of sprites have been defined, you can activate them using the <code>VDU 23, 27, 7, n</code> command, where <code>n</code> is the number of sprites to activate.  This will activate the first <code>n</code> sprites, starting with sprite 0.  All sprites from 0 to n-1 must be defined.  You can, however, set sprites within the \"active\" range to be hidden, so they will not be drawn.</p> <p>A single sprite can have multiple \"frames\", referring to different bitmaps.  (These bitmaps do not need to be the same size.)  This allows a sprite to include an animation sequence, which can be stepped through one frame at a time, or picked in any order.</p> <p>With software sprites, any format of bitmap can be used as a sprite frame.  It should be noted however that \"native\" format bitmaps are not recommended for use as sprite frames, as they cannot get erased from the screen.  (As noted above, the \"native\" bitmap format is not really intended for general use.)  This is part of why from Agon Console8 VDP 2.6.0 bitmaps captured from the screen are now stored in RGBA2222 format.</p> <p>Hardware sprites are limited to using bitmaps in RGBA8888 or RGBA2222 format.</p> <p>Moving sprites around the screen is done by changing the position of the sprite.  This can be done either by setting the absolute position of the sprite, or by moving the sprite by a given number of pixels.  (Sprites are positioned using pixel coordinates, and not by the logical OS coordinate system.)  Software sprites will not update their position on-screen until either another drawing operation is performed or an explicit <code>VDU 23, 27, 15</code> command is performed.</p> <p>Here are the sprite commands:</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-4-n-select-sprite-n","title":"<code>VDU 23, 27, 4, n</code>: Select sprite n","text":"<p>This selects the sprite with the given 8-bit ID as being the currently \"active\" sprite for subsequent sprite commands.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-5-clear-frames-in-current-sprite","title":"<code>VDU 23, 27, 5</code>: Clear frames in current sprite","text":"<p>This command clears all frames from the current sprite.  The sprite will be left with no frames, and so will not be drawn on-screen.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-6-n-add-bitmap-n-as-a-frame-to-current-sprite-where-bitmaps-buffer-id-is-64000n","title":"<code>VDU 23, 27, 6, n</code>: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+<code>n</code>)","text":"<p>This command adds a bitmap as a frame to the current sprite.  The bitmap must already be set up and available for use.  Attempting to assign a bitmap has not yet been defined to a frame will be ignored.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-7-n-activate-n-sprites","title":"<code>VDU 23, 27, 7, n</code>: Activate n sprites","text":"<p>This command activates the first <code>n</code> sprites, starting with sprite 0.  Any sprites within that range that have been set to be hidden, or do not have any frames set, will not be drawn.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-8-select-next-frame-of-current-sprite","title":"<code>VDU 23, 27, 8</code>: Select next frame of current sprite","text":"<p>This command selects the next frame of the currently selected sprite.  If the current frame is the last frame of the sprite, then the first frame will be selected.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-9-select-previous-frame-of-current-sprite","title":"<code>VDU 23, 27, 9</code>: Select previous frame of current sprite","text":"<p>This command selects the previous frame of the currently selected sprite.  If the current frame is the first frame of the sprite, then the last frame will be selected.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-10-n-select-the-nth-frame-of-current-sprite","title":"<code>VDU 23, 27, 10, n</code>: Select the nth frame of current sprite","text":"<p>This command selects the nth frame of the currently selected sprite, with frames numbered from zero.  If the frame number is out of range, then the command will be ignored.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-11-show-current-sprite","title":"<code>VDU 23, 27, 11</code>: Show current sprite","text":"<p>This command reverses a previous \"hide\" command, and will cause the current sprite to be drawn on-screen, if it is within the range of active sprites.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-12-hide-current-sprite","title":"<code>VDU 23, 27, 12</code>: Hide current sprite","text":"<p>This command will cause the current sprite to be hidden, and not drawn on-screen.  The sprite will still be active, and can be shown again using the \"show\" command.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-13-x-y-move-current-sprite-to-pixel-position-x-y","title":"<code>VDU 23, 27, 13, x; y;</code>: Move current sprite to pixel position x, y","text":"<p>This command moves the current sprite to the given pixel position on the screen.  The sprite will be drawn at the top left corner of the sprite bitmap, and so the position given is the top left corner of the sprite.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-14-x-y-move-current-sprite-by-x-y-pixels","title":"<code>VDU 23, 27, 14, x; y;</code>: Move current sprite by x, y pixels","text":"<p>This command moves the current screen location of the currently selected sprite by the given number of pixels.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-15-update-the-sprites-in-the-gpu","title":"<code>VDU 23, 27, 15</code>: Update the sprites in the GPU","text":"<p>This command will cause the sprites to be redrawn on-screen.  This is necessary if you have moved a sprite and want to see the change on-screen.  It is also necessary if you have changed the frame of a sprite, or if you have shown or hidden a sprite.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-16-reset-bitmaps-and-sprites","title":"<code>VDU 23, 27, 16</code>: Reset bitmaps and sprites","text":"<p>This command will clear all bitmap and sprite definitions.  All sprites will be deactivated, and have all their frames cleared, and the current active sprite ID will be set to zero.  All bitmap definitions will be cleared too, and the current active bitmap set to zero (or <code>64000</code> when using 16-bit IDs).  The bitmap data stored in buffers related to the bitmaps will remain, the buffer will just no longer be marked as a bitmap, so should you wish to clear the buffers too that needs to be done separately.  Any uses of bitmaps will also be reset, such as mapping a character to a bitmap, or using a bitmap as the mouse cursor.  This command will also clear the screen.</p> <p>Any sprites that were set to be hardware sprites will be reset to be software sprites, unless the test flag to enable hardware sprites has been set and also the feature flag to use hardware sprites by default has also been set.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-17-reset-sprites-only","title":"<code>VDU 23, 27, 17</code>: Reset sprites (only)","text":"<p>This command will clear all sprite definitions.  All sprites will be deactivated, and have all their frames cleared, and set the current active sprite ID to zero.  As with <code>VDU 23, 27, 16</code> sprites will be reset to be software sprites unless the appropriate flags are set.</p> <p>This command will not affect any bitmap definitions.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-18-n-set-the-current-sprite-gcol-paint-mode-to-n","title":"<code>VDU 23, 27, 18, n</code>: Set the current sprite GCOL paint mode to n **","text":"<p>This command sets the paint mode for the current sprite.  Please see the documentation on the <code>GCOL</code> command for more information on the paint modes.  This command is only supported for software sprites.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-19-set-sprite-to-be-a-hardware-sprite","title":"<code>VDU 23, 27, 19</code>: Set sprite to be a hardware sprite ***","text":"<p>This command sets the currently selected sprite to be drawn a hardware sprite.  This command is only supported on VDP 2.12.0 or later.</p> <p>Please note that at this time to use hardware sprites you need to enable the corresponding test flag for them.  This can be done using <code>VDU 23, 0, &amp;F8, 2; 1;</code>.  Until this flag is set, this command will be ignored.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-20-set-sprite-to-be-a-software-sprite","title":"<code>VDU 23, 27, 20</code>: Set sprite to be a software sprite ***","text":"<p>This command reverses the effect of the <code>VDU 23, 27, 19</code> command, and sets the current sprite to be drawn as a software sprite.  This command is only supported on VDP 2.12.0 or later.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-21-n-replace-currently-selected-frame-of-current-sprite-with-bitmap-n","title":"<code>VDU 23, 27, 21, n</code>; Replace currently selected frame of current sprite with bitmap n ***","text":"<p>This command replaces the currently selected frame of the current sprite with the bitmap with the given 8-bit ID.  The bitmap must already be set up and available for use.  Attempting to assign a bitmap has not yet been defined to a frame will be ignored.  This command is only supported in VDP 2.12.0 or later.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-26-n-add-bitmap-n-as-a-frame-to-current-sprite-using-a-16-bit-buffer-id","title":"<code>VDU 23, 27, &amp;26, n;</code>: Add bitmap n as a frame to current sprite using a 16-bit buffer ID","text":"<p>This command is identical to <code>VDU 23, 27, 6, n</code>, but uses a 16-bit buffer ID instead of an 8-bit bitmap ID.</p>"},{"location":"vdp/Bitmaps-API/#vdu-23-27-35-n-replace-currently-selected-frame-of-current-sprite-with-bitmap-n-using-a-16-bit-buffer-id","title":"<code>VDU 23, 27, &amp;35, n;</code>: Replace currently selected frame of current sprite with bitmap n using a 16-bit buffer ID ***","text":"<p>This command replaces the currently selected frame of the current sprite with the bitmap with the given 16-bit buffer ID.  The bitmap must already be set up and available for use.  Attempting to assign a bitmap has not yet been defined to a frame will be ignored.  This command is only supported in VDP 2.12.0 or later.</p>"},{"location":"vdp/Bitmaps-API/#notes-on-sprites","title":"Notes on sprites","text":"<p>The sprite system on the Agon, up to and including the 2.11.0 release, implemented exclusively software sprites.  These carry with them some significant limitations and performance considerations.  They should be used sparingly, and with care.</p> <p>From the VDP 2.12.0 release the VDP will also support hardware sprites, which bring with them a different set of limitations and considerations for use.</p> <p>The use of software sprites and hardware sprites can be combined to take advantage of the strengths of each system with both visible on screen simultaneously.</p> <p>The following notes are intended to help you understand the limitations of software sprites, and the differences between software and hardware sprites.</p>"},{"location":"vdp/Bitmaps-API/#software-sprite-limitations","title":"Software sprite limitations","text":"<p>Software sprites are best thought of as \"automatically drawn bitmaps\", as that is, essentially, how they are implemented inside the VDP.</p> <p>In single buffer screen modes, performing a drawing operation will cause all sprites to be hidden, the drawing operation performed, and then all sprites are redrawn.  When a sprite is drawn on-screen, a copy of the area of screen that ist covers is made, and then the sprite is drawn over that screen area.  When a sprite is hidden, the area of screen that it covered is copied back onto the screen.  This means that if you have a lot of active sprites, a lot of screen data is being copied around.</p> <p>In single-buffered screen modes, owing to inefficiencies in how software spriates have been implemented, any operation that draws something to the screen will cause all sprites to be hidden, the drawing operation performed, and then all sprites are redrawn.  (This includes, for example, the flashing of the text cursor.)  Sprites are redrawn in order by their ID at the beginning of the screen being drawn to the VGA port.  This means that if there are a lot of active sprites, those later in the list get drawn to the screen buffer later, possibly after that part of the screen has been sent out of the VGA port.  This, essentially, is the cause of the flickering.</p> <p>If you have too many software sprites on-screen then you may notice that some sprites may flicker, especially if they are positioned closer to the top of the screen.  Sprites are always drawn in order, so those with lower IDs will flicker less than those with higher IDs.</p> <p>One way to reduce flickering is to try to avoid using sprites near the top of the screen.  This gives more opportunity for the sprites to be redrawn before the row they occupy is scanned out of the VGA port.</p> <p>Owing to how software sprites work, it is hard to offer definitive advice on how many sprites you can use.  The size of sprites you are using will also be a factor.  It is best to experiment and see what works for you.</p> <p>Software sprites also behave differently on double-buffered screen modes.  In those modes sprites are never \"hidden\" and are instead drawn to screen before a buffer swap.  This means they tend not to flicker, but care needs to be taken to ensure that the screen is properly redrawn.</p> <p>In double-buffered screen modes software sprites are not hidden at all, and instead work exactly as if they were plain automatically drawn bitmaps.  This means that they will not flicker, but care needs to be taken to ensure that the screen is properly redrawn.</p> <p>Performance of the Agon emulator differs significantly from real hardware, owing to how the VDP system is emulated.  You will be able to have more software sprites on-screen on the emulator than you will on real hardware.</p> <p>Up to and including the Console8 VDP 2.5.0 release, sprites using bitmaps captured from screen would not work properly, and would not be erased from the screen.  This is because the bitmaps were stored in \"native\" format, and the VDP did not have the ability to erase them.  This was fixed in the Console8 VDP 2.6.0 release, and bitmaps captured from the screen are now stored in RGBA2222 format, and so can be erased from the screen.</p> <p>Console8 VDP 2.6.0 also introduces the ability to set the GCOL paint mode for software sprites.  This can allow for more sophisticated drawing operations to be performed with sprites, and some interesting effects.</p> <p>On versions of the VDP that only support software sprites, for completely optimal graphical performance, it is usually best to avoid using sprites, and instead use the bitmap system directly.  Using a small number of sprites can be a reasonable compromise.</p>"},{"location":"vdp/Bitmaps-API/#hardware-sprite-limitations","title":"Hardware sprite limitations","text":"<p>Hardware sprites are a new feature in the VDP 2.12.0 release.</p> <p>As of version 2.12.0 the feature is still considered experimental, so to use the command to mark as sprite as being a \"hardware sprite\" you need to set a test flag.  This can be done using <code>VDU 23, 0, &amp;F8, 2; 1;</code>.</p> <p>Hardware sprites have different limitations placed on them when compared with software sprites, but also have some advantages.</p> <p>The main advantages that hardware sprites exhibit is that they will always be shown in full 64 colours, whatever the colour depth of screen mode you are in, and they operate as proper sprites in double-buffered screen modes.  Hardware sprites also do not flicker, and changes made to them will immediately appear on-screen, with no need to send a \"refresh sprites\" command.  They appear above all other graphics on the screen, including software sprites.  When hardware sprites overlap, the sprite with the higher ID will be drawn on top of the sprite with the lower ID.</p> <p>The limitations of hardware sprites are that you can only use bitmaps in RGBA8888 or RGBA2222 format, and they will not support different GCOL paint modes - they will always be shown with a \"set pixel\" style of drawing operation.  There are also limitations on how many hardware sprites can be shown on-screen at once, and these limitations are complex and depend on many factors.</p> <p>Technically the way that hardware sprites work is that the VDP only draws the sprites out during the VGA signal generation.  As they are not drawn into the framebuffer, this means that hardware sprites do not need to be hidden and redrawn in the same way that software sprites do, and so will not flicker.</p> <p>The exact limitations of how many hardware sprites can be displayed at once are complex, depending on the sizes of the sprites, their data format, the resolution, frequency, and colour depth of the screen mode, and the position of the sprites on-screen.  The limitations are, essentially, around how many pixels need to get drawn onto a single scanline of the VGA signal and the time available to generate that signal.  The VDP will try to draw all of the hardware sprites that are active, but if there are too many then this can take too long and cause issues with the VGA signal generation.  If you have too many sprite pixels active on a row then the signal generation can fail, and the VGA signal may break down and not display correctly.  You may see jittery output, or the screen may not display at all.</p> <p>In general, you will be able to use less hardware sprites on a single scanline in higher resolution screen modes, and more in lower resolution modes.  You will be able to show more RGBA2222 format sprites than RGBA8888 format ones.  The colour depth of the screen mode does not have much of an impact on the number of sprites that can be shown, but the resolution does.</p> <p>By way of an example, the BASIC <code>sprites_5.bas</code> test program from the <code>agon-bbc-basic</code> repository is written to show 32 ghost sprites, which are all 16x16 pixels in size, in RGBA8888 format, and run in mode 8 (64 colours, 320x240 resolution).  This demo generally shows quite a lot of flickering, with some of the sprites turning completely invisible towards the top of the screen.  When converted to use hardware sprites, all 32 ghosts will always be visible, and do not flicker at all.  You can increase the number of sprites to 64, and they will still be stable.  Going up to 90 sprites will often still be stable, although you might see some occasional glitchiness in the display output.  The higher you go with the number of active hardware sprites, the more likely you are to see issues with the VGA signal generation.  If you go too far, which experimentation shows happens in the region of around 140+ sprites, then the VDP can end up in a state where it is unable to display anything at all, and you will need to press the reset button on your Agon to recover, or the VDP might crash.</p> <p>In contrast, when adjusting the same demo to run in any of modes 0, 1 or 2, which are 640x480 resolution modes with 16, 4 and 2 colours respectively, the number of sprites that can be shown on-screen at once is significantly reduced.  The original count of 32 sprites will generally be fairly glitchy, and some occasional glitchiness may still be observed with just 20 hardware sprites showing.</p> <p>Wider sprites can also cause issues if used as hardware sprites.  The exact limitations will depend on the resolution of the screen mode, but in general it is best to avoid using wide sprites as hardware sprites.  Tall sprites are less of an issue, so long as they are narrow.</p> <p>As these limtiations are complex with many factors, the VDP does not set any explicit limits on the number of sprites a user can set as hardware sprites.  To do so would place additional burdens on the output system, and further restrict the number of hardware sprites that could be displayed.  It is up to you to experiment and see what works for you.</p>"},{"location":"vdp/Bitmaps-API/#mouse-cursor","title":"Mouse cursor","text":""},{"location":"vdp/Bitmaps-API/#vdu-23-27-40-hotx-hoty-setup-a-mouse-cursor","title":"<code>VDU 23, 27, &amp;40, hotX, hotY</code>: Setup a mouse cursor","text":"<p>Sets up a new mouse cursor using the currently selected bitmap, with a hotspot at hotX, hotY.</p> <p>Once a mouse cursor has been set up in this way, it can be selected for display using <code>VDU 23, 0, &amp;89, 3, bitmapId;</code>.  Please note that this is a 16-bit ID, therefore if a bitmap had been selected using an 8-bit identifier you will need to add 64000 to the ID to get the 16-bit ID.</p> <p>Care should be taken to avoid using bitmapIds from 0-18, as those conflict with existing cursor Ids.</p>"},{"location":"vdp/Buffered-Commands-API/","title":"VDP Buffered Commands API","text":"<p>The VDP Buffered Commands API is a low-level API that allows for the creation of buffers on the VDP.  These buffers can be used for sequences of commands for later execution, storing data, capturing output from the VDP, as well as storing bitmaps, sound samples and fonts.</p> <p>Through the use of the APIs, it is possible to both send commands to the VDP in a \"packetised\" form, as well as to have \"functions\" or \"stored procedures\" that can be saved on the VDP and executed later.</p> <p>These commands are collected under <code>VDU 23, 0, &amp;A0, bufferId; command, [&lt;arguments&gt;]</code>.</p> <p>Examples below are given in BBC BASIC.</p> <p>A common source of errors when sending commands to the VDP from BASIC via VDU statements is to forget to use a <code>;</code> after a number to indicate a 16-bit value should be sent.  If you see unexpected behaviour from your BASIC code that is the most likely source of the problem.</p> <p>All commands must specify a buffer ID as a 16-bit integer.  There are 65534 buffers available for general use, with one buffer ID (number 65535) reserved for special functions, and is generally interpreted as meaning \"current buffer\".  As with all other VDP commands, these 16-bit values are sent as two bytes in little-endian order, and are documented as per BBC BASIC syntax, such as <code>bufferId;</code>.</p> <p>On a restart all buffers will be empty.  One should not assume however that buffers are empty when your program is run, as other programs may have already used the buffers.  Indeed, it is a valid use case to have a \"loader\" program that is designed to be run before another program to prepare a set of buffers for that second program to use.  It is therefore advisable to clear out the buffers before use.</p> <p>A single buffer can contain multiple blocks.  This approach allows for a buffer to be gradually built up over time, and for multiple commands to be sent to the VDP in a single packet.  This can be useful for sending large amounts of data to the VDP, such as a large bitmap or a sound sample, or using smaller blocks to contain for command sequences for more easily referencing an individual command (or indeed even fragments of command sequences).  By breaking up large data into smaller packets it is possible to avoid blocking the screen for long periods of time, allowing for a visual indicator of progress to be made to the user.</p> <p>Many of the commands accept an offset within a buffer.  An offset is typically a 16-bit value, however as buffers can be larger than 64kb an \"advanced\" offset mode is provided.  This advanced mode allows for offsets to be specified as 24-bit values, and also provides for a mechanism to refer to individual blocks within a buffer.  When this mode is used, the offset is sent as 3 bytes in little-endian order.  If the top bit of an advanced offset is set, this indicates that following the offset value there will be a 16-bit block number, with the remaining 23-bit offset value to be applied as an offset within the indicated block.  Using block offsets can be useful for modifying commands within buffers, as using block offsets can make identifying where parameters are placed within commands much easier to work out.</p> <p>At this time the VDP Buffered Commands API does not send any messages back to MOS to indicate the status of a command, or support a mechanism for sending contents of buffers back to MOS.  This will likely change in the future, but that will require changes to agon-mos to support it.</p>"},{"location":"vdp/Buffered-Commands-API/#command-0-write-block-to-a-buffer","title":"Command 0: Write block to a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 0, length; &lt;buffer-data&gt;</code></p> <p>This command is used to store a data block (a sequence of bytes) in a buffer on the VDP.  The exact nature of this data may vary.  It could be a sequence of VDU commands which can be executed later, a bitmap, a sound sample, or just a sequence of bytes.  When used for a sequence of VDU commands, this effectively allows for functions or stored procedures to be created.</p> <p>This is the most common command to use to send data to the VDP.  Typically you will call command 2 first to ensure that the buffer is empty, and then make a series of calls to this command to send data to the buffer.</p> <p>The <code>bufferId</code> is a 16-bit integer that identifies the buffer to write to.  Writing to the same buffer ID multiple times will add new blocks to that buffer.  This allows a buffer to be built up over time, essentially allowing for a command to be sent across to the VDP in multiple separate packets.</p> <p>Whilst the length of an individual block added using this command is restricted to 65535 bytes (as the largest value that can be sent in a 16-bit number) the total size of a buffer is not restricted to this size, as multiple blocks can be added to a buffer.  Given how long it takes to send data to the VDP it is advisable to send data across in smaller chunks, such as 1kb of data or less at a time.</p> <p>As writing to a single buffer ID is cumulative with this command, care should be taken to ensure that the buffer is cleared out before writing to it.</p> <p>When building up a complex sequence of commands it is often advisable to use multiple blocks within a buffer.  Typically this is easier to code, as otherwise working out exactly how many bytes long a command sequence is can be can be onerously difficult.  It is also easier to modify a command sequences that are broken up into multiple blocks.</p> <p>As mentioned above it is advisable to send large pieces of data, such as bitmaps or sound samples, in smaller chunks.  In between each packet of data sent to a buffer, the user can then perform other operations, such as updating the screen to indicate progress.  This allows for long-running operations to be performed without blocking the screen, and larger amounts of data to be transferred over to the VDP than may otherwise be practical given the limitations of the eZ80.</p> <p>If a buffer ID of 65535 is used then this command will be ignored, and the data discarded.  This is because this buffer ID is reserved for special functions.</p>"},{"location":"vdp/Buffered-Commands-API/#using-buffers-for-bitmaps","title":"Using buffers for bitmaps","text":"<p>Whilst it is advisable to send bitmaps over in multiple blocks, they cannot be used if they are spread over multiple blocks.  To use a bitmap its data must be in a single contiguous block, and this is achieved by using the \"consolidate\" command <code>&amp;0E</code>.</p> <p>Once you have a block that is ready to be used for a bitmap, the buffer must be selected, and then a bitmap created for that buffer using the bitmap and sprites API.  This is done with the following commands:</p> <pre><code>VDU 23, 27, &amp;20, bufferId;              : REM Select bitmap (using a buffer ID)\nVDU 23, 27, &amp;21, width; height; format  : REM Create bitmap from buffer\n</code></pre> <p>More extensive information on the bitmap and sprites API calls can be found in the bitmaps and sprites documentation.</p> <p>Until the \"create bitmap\" call has been made the buffer cannot be used as a bitmap.  That is because the system needs to understand the dimensions of the bitmap, as well as the format of the data.  Usually this only needs to be done once.  The format is given as an 8-bit value, with the following values supported:</p> Value Type Description 0 RGBA8888 RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha 1 RGBA2222 RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red 2 Mono/Mask Monochrome, 1-bit per pixel <p>The existing bitmap API uses an 8-bit number to select bitmaps, and these are automatically stored in buffers numbered 64000-64255 (<code>&amp;FA00</code>-<code>&amp;FAFF</code>).  Working out the buffer number for a bitmap is simply a matter of adding 64000.  All bitmaps created with that API will be RGBA8888 format.</p> <p>There is one other additional call added to the bitmap and sprites API, which allows for bitmaps referenced with a buffer ID to be added to sprites.  This is done with the following command:</p> <pre><code>VDU 23, 27, &amp;26, bufferId;              : REM Add bitmap to the current sprite\n</code></pre> <p>This command otherwise works identically to <code>VDU 23, 27, 6</code>.</p> <p>It should be noted that it is possible to modify the buffer that a bitmap is stored in using the \"adjust buffer contents\" and \"reverse contents\" commands (<code>5</code> and <code>24</code> respectively).  This can allow you to do things such as changing colours in a bitmap, or flipping an image horizontally or vertically.  This will even work on bitmaps that are being used inside sprites.</p> <p>Using commands targeting a buffer that create new blocks, such as \"consolidate\" or \"split\", will invalidate the bitmap and remove it from use.</p>"},{"location":"vdp/Buffered-Commands-API/#using-buffers-for-sound-samples","title":"Using buffers for sound samples","text":"<p>Much like with bitmaps, it is advisable to send samples over to the VDP in multiple blocks for the same reasons.</p> <p>In contrast to bitmaps, the sound system can play back samples that are spread over multiple blocks, so there is no need to consolidate buffers.  As a result of this, the sample playback system is also more tolerant of modifications being made to the buffer after a sample has been created from it, even if the sample is currently playing.  It should be noted that splitting a buffer may result in unexpected behaviour if the sample is currently playing, such as skipping to other parts of the sample.</p> <p>Full information on the sound system can be found in the audio API documentation.</p> <p>Once you have a buffer that contains block(s) that are ready to be used for a sound sample, the following command must be used to indicate that a sample should be created from that buffer:</p> <pre><code>VDU 23, 0, &amp;85, 0, 5, 2, bufferId; format\n</code></pre> <p>The <code>format</code> parameter is an 8-bit value that indicates the format of the sample data.  The following values are supported:</p> Value Description 0 8-bit signed, 16KHz 1 8-bit unsigned, 16KHz <p>Once a sample has been created in this way, the sample can be selected for use on a channel using the following command:</p> <pre><code>VDU 23, 0, &amp;85, channel, 4, 8, bufferId;\n</code></pre> <p>Samples uploaded using the existing \"load sample\" command (<code>VDU 23, 0, &amp;85, sampleNumber, 5, 0, length; lengthHighByte, &lt;sample data&gt;</code>) are also stored in buffers automatically.  A sample number using this system is in the range of -1 to -128, but these are stored in the range 64256-64383 (<code>&amp;FB00</code>-<code>&amp;FB7F</code>).  To map a number to a buffer range, you need to negate it, subtract 1, and then add it to 64256.  This means sample number -1 is stored in buffer 64256, -2 is stored in buffer 64257, and so on.</p>"},{"location":"vdp/Buffered-Commands-API/#command-1-call-a-buffer","title":"Command 1: Call a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 1</code></p> <p>This command will attempt to execute all of the commands stored in the buffer with the given ID.  If the buffer does not exist, or is empty, then this command will do nothing.</p> <p>Essentially, this command passes the contents of the buffer to the VDP's VDU command processor system, and executes them as if they were sent directly to the VDP.</p> <p>As noted against command 0, it is possible to build up a buffer over time by sending across multiple commands to write to the same buffer ID.  When calling a buffer with multiple blocks, the blocks are executed in order.</p> <p>Care should be taken when using this command within a buffer, as it is possible to create an infinite loop.  For instance, if a buffer contains a command to call itself, then this will result in an infinite loop.  This will cause the VDP to hang, and the only way to recover from this is to reset the VDP.</p> <p>Using a <code>bufferId</code> of -1 (65535) will cause the current buffer to be executed.  This can be useful for creating loops within a buffer.  It will be ignored if used outside of a buffered command sequence.</p>"},{"location":"vdp/Buffered-Commands-API/#command-2-clear-a-buffer","title":"Command 2: Clear a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 2</code></p> <p>This command will clear the buffer with the given ID.  If the buffer does not exist then this command will do nothing.</p> <p>Please note that this clears out all of the blocks sent to a buffer via command 0, not just the last one.  i.e. if you have built up a buffer over time by sending multiple commands to write to the same buffer ID, this command will clear out all of those commands.</p> <p>Calling this command with a <code>bufferId</code> value of -1 (65535) will clear out all buffers.</p>"},{"location":"vdp/Buffered-Commands-API/#command-3-create-a-writeable-buffer","title":"Command 3: Create a writeable buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 3, length;</code></p> <p>This command will create a new writeable buffer with the given ID.  If a buffer with the given ID already exists then this command will do nothing.  This command is primarily intended for use to create a buffer that can be used to capture output using the \"set output stream\" command (see below), or to store data that can be used for other commands.</p> <p>It is generally quite rare that you will want to use this command.  Typically you will instead want to use command 0 to write data to a buffer.  It is not necessary to use this command before using command 0, and indeed doing so will lead to errors as you will end up with two blocks in the buffer, the first of which will be empty.  If you do wish to use this command to create a buffer for data and then write to it, you would need to use operation 2 of command 5, the \"set\" operation in the \"buffer adjust\" command, to set a sequence of bytes in the buffer to the data you want to write.  This is not recommended, as it is much easier to just use command 0 to write a data block to a buffer.</p> <p>This new buffer will be a single empty single block upon creation, containing zeros.</p> <p>The <code>length</code> parameter is a 16-bit integer that specifies the maximum size of the buffer.  This is the maximum number of bytes that can be stored in the buffer.  If the buffer is full then no more data can be written to it, and subsequent writes will be ignored.</p> <p>After creating a buffer with this command it is possible to use command 0 to write further blocks to the buffer, however this is probably not advisable.</p> <p>A <code>bufferId</code> of -1 (65535) and 0 will be ignored, as these values have special meanings for writable buffers.  See command 4.</p>"},{"location":"vdp/Buffered-Commands-API/#command-4-set-output-stream-to-a-buffer","title":"Command 4: Set output stream to a buffer","text":"<p><code>VDU 23, 0 &amp;A0, bufferId; 4</code></p> <p>NB as of VDP 2.12.0, with the introduction of VDP Variables, the primary use case of this command is arguably obsolete, as that provides different mechanisms for buffered command sequences to determine the VDP state.  You are therefore strongly advised to use VDP Variables instead of this command.</p> <p>Sets then current output stream to the buffer with the given ID.  With two exceptions, noted below, this needs to be a writable buffer created with command 3.  If the buffer does not exist, or the first block within the buffer is not writable, then this command will do nothing.</p> <p>By capturing responses to commands, a buffered command sequence can interogate the state of the VDP, using the same commands that programs running on MOS can use, and make decisions based on that state.</p> <p>Following this command, any subsequent VDU commands that send response packets will have those packets written to the specified output buffer.  This allows the user to capture the response packets from a command sent to the VDP.</p> <p>By default, the output stream (for the main VDU command processor) is the communications channel from the VDP to MOS running on the eZ80.</p> <p>Passing a buffer ID of -1 (65535) to this command will remove/detach the output buffer.  From that point onwards, any subsequent VDU commands that send response packets will have those responses discarded/ignored.</p> <p>Passing a buffer ID of 0 to this command will set the output buffer back to its original value for the current command stream.  Typically that will be the communications channel from the VDP to MOS running on the eZ80, but this may not be the case if a nested call has been made.</p> <p>When used inside a buffered command sequence, this command will only affect the output stream for that sequence of commands, and any other buffered command sequences that are called from within that sequence.  Once the buffered command sequence has completed, the output stream will effectively be reset to its original value.</p> <p>It is strongly recommended to only use this command from within a buffered command sequence.  Whilst it is possible to use this command from within a normal VDU command sequence, it is not recommended as it may cause unexpected behaviour.  If you do use it in that context, it is very important to remember to restore the original output channel using <code>VDU 23, 0, &amp;A0, 0; 4</code>.  (In the future, this command may be disabled from being used outside of a buffered command sequence.)</p> <p>At present, writable buffers can only be written to until the end of the buffer has been reached; once that happens no more data will be written to the buffer.  It is not currently possible to \"rewind\" an output stream.  It is therefore advisable to ensure that the buffer is large enough to capture all of the data that is expected to be written to it.  The only current way to \"rewind\" an output stream would be to clear the buffer and create a new one, and then call set output stream again with the newly created buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#command-5-adjust-buffer-contents","title":"Command 5: Adjust buffer contents","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 5, operation, offset; [count;] &lt;operand&gt;, [arguments]</code></p> <p>This command will adjust the contents of a buffer, at a given offset.  The exact nature of the adjustment will depend on the operation used.</p> <p>Passing a <code>bufferId</code> of -1 (65535) to this command will adjust the contents of the current buffer.  This will only work if this command is used within a buffered command sequence, otherwise the command will not do anything.</p> <p>The basic set of adjustment operations are as follows:</p> Operation Description 0 NOT 1 Negate 2 Set value 3 Add 4 Add with carry 5 AND 6 OR 7 XOR <p>All of these operations will modify a byte found at the given offset in the buffer.  The only exception to that is the \"Add with carry\" operation, which will also store the \"carry\" value in the byte at the next offset.  With the exception of NOT and Negate, each command requires an operand value to be specified.</p> <p>To flip the bits of a byte at offset 12 in buffer 3, you would need to use the NOT operation, and so the following command would be used: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 0, 12;\n</code></pre></p> <p>To add 42 to the byte at offset 12 in buffer 3, you would need to use the Add operation, and so the following command would be used: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 3, 12; 42\n</code></pre></p> <p>When using add with carry, the carry value is stored in the byte at the next offset.  So to add 42 to the byte at offset 12 in buffer 3, and store the carry value in the byte at offset 13, you would need to use the Add with carry operation, and so the following command would be used: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 4, 12; 42\n</code></pre></p>"},{"location":"vdp/Buffered-Commands-API/#advanced-operations","title":"Advanced operations","text":"<p>Whilst these operations are useful, they are not particularly powerful as they only operate one one byte at a time, with a fixed operand value, and potentially cannot reach all bytes in a buffer.  To address this, the API supports a number of advanced operations.</p> <p>The operation value used is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bit Description &amp;10 Use \"advanced\" offsets &amp;20 Operand is a buffer-fetched value (buffer ID and an offset) &amp;40 Multiple target values should be adjusted &amp;80 Multiple operand values should be used <p>These bits can be combined together to modify the behaviour of the operation.</p> <p>Fundamentally, this command adjusts values of a buffer at a given offset one byte at a time.  When either of the \"multiple\" variants are used, a 16-bit <code>count</code> must be provided to indicate how many bytes should be altered.</p> <p>Advanced offsets are sent as a 24-bit value in little-endian order, which can allow for buffers that are larger than 64kb to be adjusted.  If the top-bit of this 24-bit value is set, then the 16-bit value immediately following the offset is used as a block index number, and the remaining 23-bits of the offset value are used as an offset within that block.  When the \"advanced\" offset mode bit has been set then all offsets associated with this command must be sent as advanced offsets.</p> <p>The \"buffer-fetched value\" mode allows for the operand value to be fetched from a buffer.  The operand sent as part of the command in this case is a pair of 16-bit values giving the buffer ID and offset to indicate where the actual operand value should be fetched from.  An operand buffer ID of -1 (65535) will be interpreted as meaning \"this buffer\", and thus can only be used inside a buffered command sequence.  If the advanced offset mode is used, then the operand value is an advanced offset value.</p> <p>The \"multiple target values\" mode allows for multiple bytes to be adjusted at once.  When this mode is used, the <code>count</code> value must be provided to indicate how many bytes should be adjusted.  Unless the \"multiple operand values\" mode is also used, the operand value is used for all bytes adjusted.</p> <p>The \"multiple operand values\" mode allows for multiple operand values to be used.  When this mode is used, the <code>count</code> value must be provided to indicate how many operand values should be used.  This can allow, for instance, to add together several bytes in a buffer.  When this mode is used in conjunction with the \"multiple target values\" mode, the number of operand values must match the number of target values, and the operation happens one byte at a time.</p> <p>Some examples of advanced operations are as follows:</p> <p>Flip the bits of 7 bytes in buffer 3 starting at offset 12: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;40, 12; 7;\n</code></pre> This uses operation 0 (NOT) with the \"multiple target values\" modifier (&amp;40).</p> <p>Add 42 to each of the 7 bytes in buffer 3 starting at offset 12: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;43, 12; 7; 42\n</code></pre></p> <p>Set the byte at offset 12 in the fourth block of buffer 3 to 42: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;12, 12; &amp;80, 4; 42\n</code></pre> This is using operation 2 (Set) with the \"advanced offsets\" modifier (&amp;10).  As BBC BASIC doesn't natively understand how to send 24-bit values it is sent as the 16-bit value <code>12;</code> followed by a byte with its top bit set <code>&amp;80</code> to complete the 24-bit offset in little-endian order.  As the top bit of the offset is set, this indicates that the next 16-bit value will be a block index, <code>4;</code>.  Finally the value to write is sent, <code>42</code>.</p> <p>An operation like this could be used to set the position as part of a draw command.</p> <p>Set the value in buffer 3 at offset 12 to the sum of the five values 1, 2, 3, 4, 5: <pre><code>VDU 23, 0, &amp;A0, 3; 5, 2, 12; 0  : REM clear out the value at offset 12 (set it to 0)\nVDU 23, 0, &amp;A0, 3; 5, &amp;83, 12; 5; 1, 2, 3, 4, 5\n</code></pre></p> <p>AND together 7 bytes in buffer 3 starting at offset 12 with the 7 bytes in buffer 4 starting at offset 42: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;E5, 12; 7; 4; 42;\n</code></pre></p> <p>As we are working on a little-endian system, integers longer than one byte are sent with their least significant byte first.  This means that the add with carry operation can be used to add together integers of any size, so long as they are the same size.  To do this, both the \"multiple target values\" and \"multiple operand values\" modes must be used.</p> <p>The following commands will add together a 16-bit, 24-bit, 32-bit, and 40-bit integers, all targeting the value stored in buffer 3 starting at offset 12, and all using the operand value of 42: <pre><code>VDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer\nVDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer\nVDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer\nVDU 23, 0, &amp;A0, 3; 5, &amp;C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer\n</code></pre> Take note of how the operand value is padded out with zeros to match the size of the target value.  <code>42;</code> is used as a base to send a 16-bit value, with zeros added of either 8-bit or 16-bits to pad it out to the required size.  The \"carry\" value will be stored at the next offset in the target buffer after the complete target value.  So for a 16-bit value, the carry will be stored at offset 14, for a 24-bit value it will be stored at offset 15, and so on.</p>"},{"location":"vdp/Buffered-Commands-API/#command-6-conditionally-call-a-buffer","title":"Command 6: Conditionally call a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 6, operation, &lt;checkBufferId; checkOffset; | vduVariableId;&gt; [arguments]</code></p> <p>This command will conditionally call a buffer if the condition operation passes.  This command works in a similar manner to the \"Adjust buffer contents\" command.</p> <p>With this command a buffer ID of 65535 (-1) is always interpreted as \"current buffer\", and so can only be used within a buffered command sequence.  If used outside of a buffered command sequence then this command will do nothing.</p> <p>The basic set of condition operations are as follows:</p> Operation Description 0 Exists (value is non-zero) 1 Not exists (value is zero) 2 Equal 3 Not equal 4 Less than 5 Greater than 6 Less than or equal 7 Greater than or equal 8 AND 9 OR <p>The value that is being checked is fetched from the specified check buffer ID and offset, or from a VDP Variable.  With the exception of \"Exists\" and \"Not exists\", each command requires an operand value argument to be specified to check against.</p> <p>The operation value used is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bit value Description &amp;10 Use advanced offsets &amp;20 Operand value argument is a buffer-fetched value (buffer ID and an offset) &amp;40 Value to be checked is a VDP Variable * &amp;80 Compare 16-bit values * <p>* These flag bits are only supported from VDP 2.12.0 onwards.</p> <p>These modifiers can be combined together to modify the behaviour of the operation.</p> <p>When bit <code>&amp;20</code> is set on the condition operation byte, the value to check against is fetched from a buffer, so the arguments provided must be a buffer ID and an offset (which can be an advanced offset, if the appropriate bit is set).</p> <p>Up to and including VDP 2.11.0, all comparisons would be conducted against 8-bit values only.  As of VDP 2.12.0 it is possible to specify that the values to compare are 16-bit values by setting bit <code>&amp;80</code> in the operation byte, in which case the operand value argument must be a 16-bit value.</p> <p>Comparisons of values larger than 16-bit are not directly supported.  If you need to compare larger values, you will need to break them down into smaller values and compare them separately, splitting your comparisons across multiple buffers.</p> <p>If the value to be checked is a VDP Variable, then the check buffer ID argument and offset should be omitted and instead a 16-bit variable ID sent in their place.  The \"exists\" and \"not exists\" operations for variables are a true existance check, rather than checking the value against zero.  For all other operations, if the variable does not exist then the operation result will be treated as false.</p> <p>(When the value to be checked is not a VDP variable, a <code>checkOffset;</code> argument must always be provided.  As with other commands, this can be an advanced offset.)</p> <p>The <code>AND</code> and <code>OR</code> operations are logical operations, and so the operand value is used as a boolean value.  Any non-zero value is considered to be true, and zero is considered to be false.  These operations therefore are most useful when used with buffer-fetched operand values (operations &amp;28, &amp;29, &amp;38 and &amp;39).</p> <p>Some examples of condition operations are as follows:</p> <p>Call buffer 7 if the value in buffer 12 at offset 5 exists (is non-zero): <pre><code>VDU 23, 0, &amp;A0, 7; 6, 0, 12; 5;\n</code></pre></p> <p>Call buffer 8 if the value in buffer 12 at offset 5 does not exist (is zero): <pre><code>VDU 23, 0, &amp;A0, 8; 6, 1, 12; 5;\n</code></pre></p> <p>Combining the above two examples is effectively equivalent to \"if the value exists, call buffer 7, otherwise call buffer 8\": <pre><code>VDU 23, 0, &amp;A0, 7; 6, 0, 12; 5;\nVDU 23, 0, &amp;A0, 8; 6, 1, 12; 5;\n</code></pre></p> <p>Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42: <pre><code>VDU 23, 0, &amp;A0, 3; 6, 2, 4; 12; 42\n</code></pre></p> <p>Call buffer 5 if the value in buffer 2 at offset 7 is less than the value in buffer 2 at offset 8: <pre><code>VDU 23, 0, &amp;A0, 5; 6, &amp;24, 2; 7; 2; 8;\n</code></pre></p>"},{"location":"vdp/Buffered-Commands-API/#command-7-jump-to-a-buffer","title":"Command 7: Jump to a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 7</code></p> <p>This command will jump to the buffer with the given ID.  If the buffer does not exist, or is empty, then this command will do nothing.</p> <p>This essentially works the same as the call command (command 1), except that it does not return to the caller.  This command is therefore useful for creating loops.</p> <p>Using this command to jump to buffer 65535 (buffer ID -1) is treated as a \"jump to end of current buffer\".  This will return execution to the caller, and can be useful for exiting a loop.</p>"},{"location":"vdp/Buffered-Commands-API/#command-8-conditional-jump-to-a-buffer","title":"Command 8: Conditional Jump to a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]</code></p> <p>This command operates in a similar manner to the \"Conditionally call a buffer\" command (command 6), except that it will jump to the buffer if the condition operation passes.</p> <p>As with the \"Jump to a buffer\" command (command 7), a jump to buffer 65535 is treated as a \"jump to end of current buffer\".</p>"},{"location":"vdp/Buffered-Commands-API/#command-9-jump-to-an-offset-in-a-buffer","title":"Command 9: Jump to an offset in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]</code></p> <p>This command will jump to the given offset in the buffer with the given ID.  If the buffer does not exist, or is empty, then this command will do nothing.</p> <p>The offset in this command is always an \"advanced\" offset, given as a 24-bit value in little-endian order.  As with other uses of advanced offsets, if the top-bit is set in the high byte of the offset value, a block number must also be provided.</p> <p>When jumping to an offset, using buffer ID 65535 is treated as meaning \"jump within current buffer\".  This can be useful for creating loops within a buffer, or when building up command sequences that may be copied across multiple buffers.</p> <p>Jumping to an offset that is beyond the end of the buffer is equivalent to jumping to the end of the buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#command-10-conditional-jump-to-an-offset-in-a-buffer","title":"Command 10: Conditional jump to an offset in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]</code></p> <p>A conditional jump with an offset works in a similar manner to the \"Conditional call a buffer\" command (command 6), except that it will jump to the given offset in the buffer if the condition operation passes.</p> <p>As with the \"Jump to an offset in a buffer\" command (command 9), the offset in this command is always an \"advanced\" offset, given as a 24-bit value in little-endian order, and the usual advanced offset rules apply.  And similarly, using buffer ID 65535 is treated as meaning \"jump within current buffer\".</p>"},{"location":"vdp/Buffered-Commands-API/#command-11-call-buffer-with-an-offset","title":"Command 11: Call buffer with an offset","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]</code></p> <p>Works just like \"Call a buffer\" (command 1), except that it also accepts an advanced offset.</p>"},{"location":"vdp/Buffered-Commands-API/#command-12-conditional-call-buffer-with-an-offset","title":"Command 12: Conditional call buffer with an offset","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]</code></p> <p>Works just like the \"Conditional call a buffer\" command (command 6), except that it also accepts an advanced offset.</p>"},{"location":"vdp/Buffered-Commands-API/#command-13","title":"Command 13: Copy blocks from multiple buffers into a single buffer","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;</code></p> <p>This command will copy the contents of multiple buffers into a single buffer.  The buffers to copy from are specified as a list of buffer IDs, terminated by a buffer ID of -1 (65535).  The buffers are copied in the order they are specified.</p> <p>This is a block-wise copy, so the blocks from the source buffers are copied into the target buffer.  The blocks are copied in the order they are found in the source buffers.</p> <p>The target buffer will be overwritten with the contents of the source buffers.  This will not be done however until after all the data has been gathered and copied.  The target buffer can therefore included in the list of the source buffers.</p> <p>If a source buffer that does not exist is specified, or a source buffer that is empty is specified, then that buffer will be ignored.  If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.</p> <p>The list of source buffers can contain repeated buffer IDs.  If a buffer ID is repeated, then the blocks from that buffer will be copied multiple times into the target buffer.</p> <p>If there is insufficient memory available on the VDP to complete this command then it will fail, and the target buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-14-consolidate-blocks-in-a-buffer","title":"Command 14: Consolidate blocks in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 14</code></p> <p>Takes all the blocks in a buffer and consolidates them into a single block.  This is useful for bitmaps, as it allows for a bitmap to be built up over time in multiple blocks, and then consolidated into a single block for use as a bitmap.</p> <p>If there is insufficient memory available on the VDP to complete this command then it will fail, and the buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-15-split-a-buffer-into-multiple-blocks","title":"Command 15: Split a buffer into multiple blocks","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 15, blockSize;</code></p> <p>Splits a buffer into multiple blocks.  The <code>blockSize</code> parameter is a 16-bit integer that specifies the target size of each block.  If the source data is not a multiple of the block size then the last block will be smaller than the specified block size.</p> <p>If this command is used on a buffer that is already split into multiple blocks, then the blocks will be consolidated first, and then re-split into the new block size.</p> <p>If there is insufficient memory available on the VDP to complete this command then it will fail, and the buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-16-split-a-buffer-into-multiple-blocks-and-spread-across-multiple-buffers","title":"Command 16: Split a buffer into multiple blocks and spread across multiple buffers","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;</code></p> <p>Splits a buffer into multiple blocks, as per command 15, but then spreads the resultant blocks across the target buffers.  The target buffers are specified as a list of buffer IDs, terminated by a buffer ID of -1 (65535).</p> <p>The blocks are spread across the target buffers in the order they are specified, and the spread will loop around the buffers until all the blocks have been distributed.  The target buffers will be cleared out before the blocks are spread across them.</p> <p>What this means is that if the source buffer is, let's say, 100 bytes in size and we split using a block size of 10 bytes then we will end up with 10 blocks.  If we then spread those blocks across 3 target buffers, then the first buffer will contain blocks 1, 4, 7 and 10, the second buffer will contain blocks 2, 5 and 8, and the third buffer will contain blocks 3, 6 and 9.</p> <p>This command attempts to ensure that, in the event of insufficient memory being available on the VDP to complete the command, it will leave the targets as they were before the command was executed.  However this may not always be possible.  The first step of this command is to consolidate the source buffer into a single block, and this may fail from insufficient memory.  If that happens then all the buffers will be left as they were.  After this however the target buffers will be cleared.  If there is insufficient memory to successfully split the buffer into multiple blocks then the call will exit, and the target buffers will be left empty.</p>"},{"location":"vdp/Buffered-Commands-API/#command-17-split-a-buffer-and-spread-across-blocks-starting-at-target-buffer-id","title":"Command 17: Split a buffer and spread across blocks, starting at target buffer ID","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 17, blockSize; targetBufferId;</code></p> <p>As per the above two commands, this will split a buffer into multiple blocks.  It will then spread the blocks across buffers starting at the target buffer ID, incrementing the target buffer ID until all the blocks have been distributed.</p> <p>Target blocks will be cleared before a block is stored in them.  Each target will contain a single block.  The exception to this is if the target buffer ID reaches 65534, as it is not possible to store a block in buffer 65535.  In this case, multiple blocks will be placed into buffer 65534.</p> <p>With this command if there is insufficient memory available on the VDP to complete the command then it will fail, and the target buffers will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-18-split-a-buffer-into-blocks-by-width","title":"Command 18: Split a buffer into blocks by width","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 18, width; blockCount;</code></p> <p>This command splits a buffer into a given number of blocks by first of all splitting the buffer into blocks of a given width (number of bytes), and then consolidating those blocks into the given number of blocks.</p> <p>This is useful for splitting a bitmap into a number of separate columns, which can then be manipulated individually.  This can be useful for dealing with sprite sheets.</p>"},{"location":"vdp/Buffered-Commands-API/#command-19-split-by-width-into-blocks-and-spread-across-target-buffers","title":"Command 19: Split by width into blocks and spread across target buffers","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;</code></p> <p>This command essentially operates the same as command 18, but the block count is determined by the number of target buffers specified.  The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.</p>"},{"location":"vdp/Buffered-Commands-API/#command-20-split-by-width-into-blocks-and-spread-across-blocks-starting-at-target-buffer-id","title":"Command 20: Split by width into blocks and spread across blocks starting at target buffer ID","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 20, width; blockCount; targetBufferId;</code></p> <p>This command essentially operates the same as command 18, but the generated blocks are spread across blocks starting at the target buffer ID, as per command 17.</p>"},{"location":"vdp/Buffered-Commands-API/#command-21-spread-blocks-from-a-buffer-across-multiple-target-buffers","title":"Command 21: Spread blocks from a buffer across multiple target buffers","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;</code></p> <p>Spreads the blocks from a buffer across multiple target buffers.  The target buffers are specified as a list of buffer IDs, terminated by a buffer ID of -1 (65535).  The blocks are spread across the target buffers in the order they are specified, and the spread will loop around the buffers until all the blocks have been distributed.</p> <p>It should be noted that this command does not copy the blocks, and nor does it move them.  Unless the source buffer has been included in the list of targets, it will remain completely intact.  The blocks distributed across the target buffers will point to the same memory as the blocks in the source buffer.  Operations to modify data in the source buffer will also modify the data in the target buffers.  Clearing the source buffer however will not clear the target buffers.</p>"},{"location":"vdp/Buffered-Commands-API/#command-22-spread-blocks-from-a-buffer-across-blocks-starting-at-target-buffer-id","title":"Command 22: Spread blocks from a buffer across blocks starting at target buffer ID","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 22, targetBufferId;</code></p> <p>Spreads the blocks from a buffer across blocks starting at the target buffer ID.</p> <p>This essentially works the same as command 21, and the same notes about copying and moving blocks apply.  Blocks are spread in the same manner as commands 17 and 20.</p>"},{"location":"vdp/Buffered-Commands-API/#command-23-reverse-the-order-of-blocks-in-a-buffer","title":"Command 23: Reverse the order of blocks in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 23</code></p> <p>Reverses the order of the blocks in a buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#command-24-reverse-the-order-of-data-of-blocks-within-a-buffer","title":"Command 24: Reverse the order of data of blocks within a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 24, options, [valueSize;] [chunkSize;]</code></p> <p>Reverses the order of the data within the blocks of a buffer.  The <code>options</code> parameter is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bit value Description 1 Values are 16-bits in size 2 Values are 32-bits in size 3 (1+2) If both value size bits are set, then the value size is sent as a 16-bit value 4 Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value 8 Reverse blocks <p>These modifiers can be combined together to modify the behaviour of the operation.</p> <p>If no value size is set in the options (i.e. the value of the bottom two bits of the options is zero) then the value size is assumed to be 8-bits.</p> <p>It is probably easiest to understand what this operation is capable of by going through some examples of how it can be used to manipulate bitmaps.  The VDP supports two different formats of color bitmap, either RGBA8888 which uses 4-bytes per pixel, i.e. 32-bit values, or RGBA2222 which uses a single byte per pixel.</p> <p>The simplest example is rotating an RGBA2222 bitmap by 180 degrees, which can be done by just reversing the order of bytes in the buffer: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 0\n</code></pre></p> <p>Rotating an RGBA8888 bitmap by 180 degrees is in principle a little more complex, as each pixel is made up of 4 bytes.  However with this command it is still a simple operation, as we can just reverse the order of the 32-bit values that make up the bitmap by using an options value of <code>2</code>: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 2\n</code></pre></p> <p>Mirroring a bitmap around the x-axis is a matter of reversing the order of rows of pixels.  To do this we can set a custom value size that corresponds to our bitmap width.  For an RGBA2222 bitmap we can just set a custom value size to our bitmap width: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 3, width\n</code></pre></p> <p>As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply our width by 4: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 3, width * 4\n</code></pre></p> <p>To mirror a bitmap around the y-axis, we need to reverse the order of pixels within each row.  For an RGBA2222 bitmap we can just set a custom chunk size to our bitmap width: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 4, width\n</code></pre></p> <p>For an RGBA8888 bitmap we need to set our options to indicate 32-bit values as well as a custom chunk size: <pre><code>VDU 23, 0, &amp;A0, bufferId; 24, 6, width * 4\n</code></pre></p>"},{"location":"vdp/Buffered-Commands-API/#command-25-copy-blocks-from-multiple-buffers-by-reference","title":"Command 25: Copy blocks from multiple buffers by reference","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;</code></p> <p>This command is essentially a version of command 13 that copies blocks by reference rather than by value.  The parameters for this command are the same as for command 13, and the same rules apply.</p> <p>If the target buffer is included in the list of source buffers then it will be skipped to prevent a reference loop.</p> <p>Copying by reference means that the blocks in the target buffer will point to the same memory as the blocks in the source buffers.  Operations to modify data blocks in the source buffers will therefore also modify those blocks in the target buffer.  Clearing the source buffers will not clear the target buffer - it will still point to the original data blocks.  Data blocks are only freed from memory when no buffers are left with any references to them.</p> <p>Buffers that get consolidated become new blocks, so will lose their links to the original blocks, thus after a \"consolidate\" operation modifications to the original blocks will no longer be reflected in the consolidated buffer.</p> <p>This command is useful to construct a single buffer from multiple sources without the copy overhead, which can be costly.  For example, this can be useful for constructing a bitmap from multiple constituent parts before consolidating it into a single block.  In such an example, using command 13 instead would first make a copy of the contents of the source buffers, and then consolidate them into a single block.  Using this command does not make that first copy, and so would be faster.</p> <p>This command is also useful for creating multiple buffers that all point to the same data.</p>"},{"location":"vdp/Buffered-Commands-API/#command-26-copy-blocks-from-multiple-buffers-and-consolidate","title":"Command 26: Copy blocks from multiple buffers and consolidate","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;</code></p> <p>This command is similar to performing a \"copy\" operation followed by a \"consolidate\" operation, and thus has similar behaviour to command 13 and/or command 25.  The parameters for this command are the same as for command 25.  As with command 25, you cannot include the target buffer in the list of source buffers.  If you do, then it will be skipped.</p> <p>This command will replace the target buffer with a new buffer that contains a single block that is the result of consolidating the blocks from the source buffers.  If the target buffer already contains a single block of the same size as the source buffers then it will re-use the memory, and so will be faster than performing a separate \"copy by reference\" and \"consolidate\" operation.</p> <p>It is useful for constructing a single buffer from multiple sources, such as for constructing a bitmap from multiple constituent parts.</p>"},{"location":"vdp/Buffered-Commands-API/#commands-32-and-33-create-or-manipulate-a-2d-or-3d-affine-transformation-matrix","title":"Commands 32 and 33: Create or manipulate a 2D or 3D affine transformation matrix","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 32, operation, [&lt;format&gt;, &lt;arguments...&gt;]</code> <code>VDU 23, 0, &amp;A0, bufferId; 33, operation, [&lt;format&gt;, &lt;arguments...&gt;]</code></p> <p>As of the time of writing, this command is experimental and subject to change.  It features in the VDP 2.9.0 release, but to use this command you need to enable the feature by setting the affine transforms test flag.  This is done using the command <code>VDU 23, 0, &amp;F8, 1; 1;</code>.  The exact operations and arguments supported by this command may change in the future.  Command 33 was added in the VDP 2.10.0 release.</p> <p>The purpose of these commands is to create or manipulate an affine transform matrix stored in a buffer.  Affine transforms are used to manipulate 2D or 3D points, and can be used to perform operations such as translation, rotation, scaling, and shearing.  Command 32 creates or manipulates a 2D affine transform matrix, and command 33 creates or manipulates a 3D affine transform matrix.  Affine transforms are used to manipulate 2D or 3D points, and can be used to perform operations such as translation, rotation, scaling, and shearing.</p> <p>To use this API you do not need to understand the mathematics of affine transformations.  The API is designed to be simple to use, and to allow for complex transformations to be built up from simple operations.</p> <p>Technically, a 2D affine transformation matrix is a 3x3 matrix that can be used to perform transformations on 2D points, and can be applied to drawing operations.  A 3D affine transform uses a 4x4 matrix to account for the extra dimension.  The matrix is stored in row-major order, and is stored as 32-bit single-precision IEEE-754 floating point values.  The matrix is stored in a single block in the buffer.  The drawing system may store a second block in the buffer to cache an inverse of the matrix, but you should not rely on that being there.</p> <p>A challenge with this API is that inherently neither the VDU command system nor the eZ80 CPU directly support floating-point arithmetic.  The API therefore supports sending numbers across in a variety of different formats to help facilitate this, and will convert the values sent to floating-point values as required.  The API supports sending fixed-point values, 16-bit and 32-bit integers, and 16-bit and 32-bit floating-point values.  Values must just be sent across as bytes in the VDU command stream in little-endian order, much like any other value byte must be send.</p> <p>Several different operations are supported by this command.  When an operation is performed, the result is stored back in the buffer, replacing any existing data that may have been there.  Most operations will combine their result with the existing matrix in the buffer.  This means that you can combine for instance rotation and scaling into one transform matrix.  The following operations are supported:</p> Operation Arguments Description 0 0 Set an \"identity matrix\" (effectively a \"reset\" operation) 1 0 Invert the matrix (this will only succeed if the buffer already contains a valid transform matrix) 2 1 (3 for 3D) Rotate anticlockwise by angle in degrees 3 1 (3 for 3D) Rotate anticlockwise by angle in radians 4 1 Multiply all values in the first 8 matrix positions by an amount 5 2 (3 for 3D) Scale X and Y (and Z for 3D) by given scaling factors 6 2 (3 for 3D) Translate X and Y (and Z for 3D) by a number of pixels 7 2 (3 for 3D) Translate X and Y by using currently selected graphics coordinate system units, (Z transform in pixels for 3D version) 8 2 (3 for 3D) Shear X and Y by given amounts 9 2 (3 for 3D) Skew X and Y by angle in degrees 10 2 (3 for 3D) Skew X and Y by angle in radians 11 6 (12 for 3D) Transform (combine with another transform matrix - requires 6 values to be sent, or 12 values for 3D - the final matrix row will be set to <code>0, 0, 1</code>, or <code>0, 0, 0, 1</code> for a 3D matrix) 12 <code>bitmapId;</code>, 2 Translate X and Y by a proportion of the size (width/height) of a given bitmap.  This operation requires a 16-bit bitmap ID to immediately follow the operation byte, before the format byte and X, Y values.  NB the 3D version of this command will also only perform an X, Y translation, and thus also only accepts 2 arguments <p>Repeatedly calling this command with different operations will build up a transform matrix in the buffer.  It should be noted that if the buffer is not cleared out before starting to build up a new matrix (or set to an identity matrix) then the results may not be as expected.</p> <p>Every operation that requires arguments to be provided must then send a byte to indicate the format of the arguments that follow.  The format byte is as follows:</p> Bit value Description 0-&amp;1F Shift (used for fixed-point values, ignored for floating-point) &amp;20 Unused, must be zero (Reserved for future use) &amp;40 When set, data is provided in fixed-point format, otherwise it is IEEE-754 floating point &amp;80 When set, data is presented as 16-bit values, otherwise they are 32-bit values <p>The fixed-point format supported by this command essentially means that values sent will be interpreted as a binary number with a \"binary point\".  The binary point starts out to the right of the right-most bit of the value (the least significant bit), meaning that when a shift value of zero is used the number being sent is an integer.  A shift of 1 will move the binary point one place to the left, effectively dividing the number by 2.  A shift of 2 will divide the number sent by 4, and so on.</p> <p>The shift value is a 5-bit value, and its use varies depending on whether a 16-bit or a 32-bit value is being sent (i.e. if bit 7 has been set).  When a 32-bit value is sent (bit 7 is clear), the shift is interpreted as a 5-bit unsigned integer, i.e. it has the range of 0-31.  For 16-bit values, the 5-bit shift is a signed integer, giving a range of -16 to +15.  This allows for a negative shift to be applied to 16-bit values, meaning the number sent will be multiplied by 2 when a shift of -1 is given, by 4 for a shift of -2, and so on.</p> <p>As can be seen, the API also supports sending IEEE-754 floating point values.  These can be sent either as single-precision values (using 32-bits), or as half-precision values (in 16-bits).  The \"shift\" bits in the format byte will be ignored when sending floating-point values.  A format value of <code>0</code> therefore indicates that values will be sent as 32-bit single-precision IEEE-754 floating point values, and a format value of <code>&amp;80</code> indicates values will be sent as 16-bit half-precision IEEE-754 values.</p> <p>In all cases data should be sent in little-endian byte order.</p>"},{"location":"vdp/Buffered-Commands-API/#advanced-operations_1","title":"Advanced operations","text":"<p>Similar to the Adjust command, it is possible to perform some advanced operations with this command by setting some of the upper bits of the operation byte.  The following bits are defined:</p> Bit value Description &amp;10 Use advanced offsets (when using buffer-fetched values) &amp;20 Fetch values from a buffer (and offset), rather than the command stream &amp;40 Separate arguments will have individual format bytes <p>The most important of these is the \"fetch values from a buffer\" bit.  When this bit is set, a format byte is still read from the VDU command stream, but then the next two bytes in the stream are interpreted as a buffer ID, which should then be followed by an offset (2 further bytes, unless the \"use advanced offsets\" bit is set).  The value to be used in the operation will then be fetched from the buffer at the given offset, and interpreted using the format described in the format byte.  Using this allows for transform matrices to be built up over time in multiple buffers, and then combined into a single buffer.  This can be useful for building up complex transformations in a modular way.</p> <p>When this flag is set, all arguments are fetched from the given buffer, at the given offset.  If the operation requires multiple bytes they will be read consecutively from the buffer.  The format byte is still used to interpret the values fetched from the buffer.</p> <p>When the \"Separate arguments have individual format bits\" flag is set then each argument will be prefaced with its own format byte, rather than a single byte being used to dictate the format of all arguments.  This can be useful when sending multiple arguments of different types.  This can be combined with the other flags.</p>"},{"location":"vdp/Buffered-Commands-API/#command-34-create-or-combine-a-matrix-of-arbitrary-dimensions","title":"Command 34: Create or combine a matrix of arbitrary dimensions","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 34, operation, rows, columns, [&lt;arguments&gt;]</code></p> <p>As of the time of writing, this command is experimental and subject to change.  It features in the VDP 2.10.0 release, but to use this command you need to enable the feature by setting the affine transforms test flag.  This is done using the command <code>VDU 23, 0, &amp;F8, 1; 1;</code>.  The exact operations and arguments supported by this command may change in the future.</p> <p>This command expands on commands 32 and 33 to allow for the creation of a matrix of arbitrary dimensions.  The matrix is stored in a buffer, and is stored in row-major order.  The matrix is stored as 32-bit single-precision IEEE-754 floating point values.  The matrix is stored in a single block in the buffer.</p> <p>This command works in a similar manner to commands 32 and 33, and where applicable supports the same floating point data formats.  The operations supported by this command are as follows:</p> Operation Arguments Description 0 <code>format, &lt;arguments...&gt;</code> Set the matrix to the values provided 1 <code>sourceBufferId; row, column, format, &lt;arguments...&gt;</code> Copy source matrix and set an individual value 2 <code>format, &lt;value&gt;</code> Create a matrix with all entries filled with the given value 3 <code>format, &lt;value&gt;</code> Create a matrix filled with zeros and set the diagonal to the given value 4 <code>sourceBufferId1; sourceBufferId2;</code> Add two matrices together 5 <code>sourceBufferId1; sourceBufferId2;</code> Subtract matrices (target = source1 - source2) 6 <code>sourceBufferId1; sourceBufferId2;</code> Multiply two matrices together 7 <code>sourceBufferId; format, &lt;value&gt;</code> Multiply matrix by a scalar value 8 <code>sourceBufferId; row, column</code> Extract a sub-matrix from a source matrix at given row and column. Target matrix will be filled from top-left, truncating or padding with zeros as necessary 9 <code>sourceBufferId; row</code> Create a new copy of the source matrix, inserting a row at given offset 10 <code>sourceBufferId; column</code> Create a new copy of the source matrix, inserting a column at given offset 11 <code>sourceBufferId; row</code> Create a new copy of the source matrix, removing a row at given offset 12 <code>sourceBufferId; column</code> Create a new copy of the source matrix, removing a column at given offset <p>The target matrix will always be created with the number of rows and columns given in the command.  If the source matrix is not the same size as the target matrix then the source matrix will be truncated or padded with zeros as necessary.</p> <p>When multiplying two different matrixes together, usually it is required that the second matrix will have the same number of rows as there are columns in the first matrix.  This command however will allow different matrixes of different dimensions to be multiplied together.  It does this by making the matrixes square and padding with zeros where necessary, where the square size is the maximum of the dimensions of the sources and target matrixes.</p>"},{"location":"vdp/Buffered-Commands-API/#advanced-operations_2","title":"Advanced operations","text":"<p>Similar to commands 32 and 33, it is possible to perform some advanced operations with this command by setting some of the upper bits of the operation byte.  The following bits are defined:</p> Bit value Description &amp;10 Use advanced offsets (when using buffer-fetched values) &amp;20 Fetch values from a buffer (and offset), rather than the command stream"},{"location":"vdp/Buffered-Commands-API/#command-40-create-a-transformed-bitmap","title":"Command 40: Create a transformed bitmap","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 40, options, transformBufferId; sourceBitmapId; [width; height;]</code></p> <p>As of the time of writing, this command is experimental and subject to change.  It features in the VDP 2.10.0 release, but to use this command you need to enable the feature by setting the affine transforms test flag.  This is done using the command <code>VDU 23, 0, &amp;F8, 1; 1;</code>.  The exact options and arguments supported by this command may change in the future.</p> <p>This command applies an affine transformation to a bitmap, creating a new RGBA2222 format bitmap.  It will replace the target buffer with the new bitmap, and creates a corresponding bitmap.</p> <p>The <code>options</code> parameter is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined, and can be combined together:</p> Bit value Arguments Description 1 Target bitmap should be resized.  When not set, target will be same dimensions as the original bitmap. 2 <code>width; height;</code> Target bitmap will be resized to explicitly given dimensions 4 Automatically translate target bitmap position.  When set the calculated transformed minimum x,y coordinates will be placed at the top left of the target <p>Usually the target bitmap will be the same size as the source bitmap, but it is possible to resize the target bitmap to a different size.  When no explicit size is given, but the \"resize\" bit has been set, then the target bitmap size will depend on the transformation being applied.  This could mean, for example, that applying a progressive series of rotations to a bitmap can result in several different sizes of target bitmap.</p>"},{"location":"vdp/Buffered-Commands-API/#command-41-apply-a-transform-matrix-to-data-in-a-buffer","title":"Command 41: Apply a transform matrix to data in a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 41, options, format, transformBufferId; sourceBufferId; [&lt;arguments&gt;]</code></p> <p>As of the time of writing, this command is experimental and subject to change.  It features in the VDP 2.10.0 release, but to use this command you need to enable the feature by setting the affine transforms test flag.  This is done using the command <code>VDU 23, 0, &amp;F8, 1; 1;</code>.  The exact options and arguments supported by this command may change in the future.</p> <p>This command will copy the source buffer and transform sets of values held within it using the given format and transform matrix.  The transformed values will be stored in the target buffer, replacing any existing data that may have been there.  The options byte, and optional arguments (depending on which bits of the options byte are set), control how the transformation is applied.</p> <p>The <code>options</code> parameter is an 8-bit value that can have bits set to modify the behaviour of this command, including which arguments should be sent.  The following bits are defined, and can be combined together:</p> Bit value Arguments Description &amp;01 <code>size</code> Explicit data set size (otherwise data size will be one less than the number of rows in the transform matrix) &amp;02 <code>offset;</code> Has an offset into the buffer for where to find the first data set (NB this may be an \"advanced offset\" if that option is set) &amp;04 <code>stride;</code> Has an explicit stride (in bytes) between value sets &amp;08 <code>limit;</code> Has an explicit limit to the number of data items to be transformed &amp;10 \"Advanced offsets\" should be used &amp;20 Optional argument values should be fetched from buffers (and thus be a bufferId and offset in the command stream) &amp;40 Data transforms should be applied on a block-by-block basis on data in the source buffer <p>The <code>format</code> argument indicates the format of data in the source buffer, using the same format as for the affine transform commands.  This means that values to be transformed will be interpretted either as fixed-point or floating-point values in either 16 or 32 bits.  Using fixed-point format with a shift value of zero will interpret the values as integers (e.g. a format of <code>&amp;C0</code> means source data is in 16-bit integers).  Data in the target buffer will be stored in the same format as the source buffer.</p> <p>This command works with sets of data.  Typically if you are using this command to transform 2D points the size of the data set will be two, to indicate that you're transforming two values, the X and Y coordinates.  These sets of data values must appear contiguously in the source buffer.  The <code>stride</code> dictates how far apart (in bytes) the start of each set of data lies in the source buffer.  The <code>limit</code> parameter can be used to limit the number of data sets that are transformed.</p> <p>As an example, this command can be used to transform sets of coordinates in a buffer that contains a series of PLOT commands.  A complete PLOT VDU command is a sequence of 6 bytes, where the first byte is <code>25</code> for PLOT, the second byte is the PLOT operation code, and then there are two 16-bit integer values for the X and Y coordinates.  The <code>offset</code> therefore would be set to <code>2</code>, and the <code>stride</code> would be set to <code>6</code>.  Our <code>format</code> needs to indicate we are using 16-bit fixed-point values with no shift, so that equates to <code>&amp;C0</code>.  As we wish to set an explicit (start) offset and stride we need an <code>options</code> value of <code>6</code> (which is 2 + 4).  A command to use a 2D transform matrix stored in buffer <code>10</code> on a command sequence the data stored in buffer 20, writing the transformed data to buffer 30, would look like this:</p> <pre><code>VDU 23, 0, &amp;A0, 30; 41, 6, &amp;C0, 10; 20; 2; 6;\n</code></pre> <p>This example makes two significant assumptions.  The first, as mentioned above, is that the source buffer only contains a series of PLOT commands.  The second assumption is that we are using a 2D affine transform matrix created by command 32, which will have created a 3x3 matrix, and therefore an explicit <code>size</code> argument is not needed - it will be automatically derived as a data set size of 2, i.e. X and Y coordinates.</p> <p>Once this example command has been executed, buffer 30 would contain the same sequence of PLOT commands as buffer 20, but with the X and Y coordinates transformed by the matrix stored in buffer 10.  Buffer 30 could then be called, and a transformed version of the PLOT commands would be drawn on the screen.</p> <p>It should be noted that since it is only the coordinates that are transformed, the nature of the PLOT commands themselves will not be changed.  If the transform matrix was created with only \"translate\" or \"scale\" operations then the effect will work as expected for all PLOT commands (except for bitmap plots, which would not be drawn scaled as only the target coordinates woulld have changed), but if the transform included \"rotate\", \"shear\" or \"skew\" then results may differ.  PLOT commands that only draw lines, or fill triangles, will draw properly transformed versions of those shapes.  The effect on some other PLOT commands, such as those to fill a rectangle, or plot a circle/arc/sector will differ, as it is just the coordinates that are being transformed.  A rectangle may be drawn with a different size, but its sides will still be drawn aligned to the X and Y axis, and a circle will still be round.</p>"},{"location":"vdp/Buffered-Commands-API/#command-48-read-a-vdp-variable-into-a-buffer","title":"Command 48: Read a VDP variable into a buffer","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 48, options, offset; variableId; [default[;]]</code></p> <p>This command will copy the current value read from a VDP variable with the given <code>variableId;</code> into a buffer at the given offset.  Support for this command was added in VDP 2.12.0.</p> <p>The <code>options</code> argument is an 8-bit value that can have bits set to modify the behaviour of this command.  The following bits are defined:</p> Bit value Description &amp;10 Use advanced offsets &amp;40 Use provided default value if no variable of the given ID is set &amp;80 Use 16-bit values <p>The value size for this command will, by default, be a single byte.  VDP Variables are however stored as 16-bit values, and so bit <code>&amp;80</code> in the <code>options</code> byte can be set to indicate that the value should be read as a 16-bit value.  Such values are stored in little-endian order.</p> <p>If the variable does not exist, then the buffer will not be changed unless the <code>&amp;40</code> bit has been set in the options byte, and a default value is provided.  The size of the default value sent must match the size of the value being read from the variable (as determined by bit <code>&amp;80</code>).</p> <p>If the <code>bufferId</code> does not exist, or the offset is out of bounds, then the command will fail.</p>"},{"location":"vdp/Buffered-Commands-API/#command-64-compress-a-buffer","title":"Command 64: Compress a buffer","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 64, sourceBufferId;</code></p> <p>This command will compress the contents of a buffer, replacing the target buffer with the compressed data.  Unless the target buffer is the same as the source, the source buffer will be left unchanged.</p>"},{"location":"vdp/Buffered-Commands-API/#command-65-decompress-a-buffer","title":"Command 65: Decompress a buffer","text":"<p><code>VDU 23, 0, &amp;A0, targetBufferId; 65, sourceBufferId;</code></p> <p>This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data.  Unless the target buffer is the same as the source, the source buffer will be left unchanged.</p> <p>The source buffer must contain a complete set of compressed data, but need not be in a single block.  The decompressed data will be stored in a single block in the target buffer.</p> <p>Using this command, data can be sent from MOS in a compressed form, and then decompressed on the VDP.  This can be useful for sending large amounts of data over to the VDP, as it can reduce the amount of data that needs to be sent.</p> <p>The compression algorithm supported by this command and the corresponding \"compress\" command is \"TurboVega-style\" compression.  Source code for the compression and decompression routines and tools to use them on other systems can be found in the TurboVega agon_compression repository.</p>"},{"location":"vdp/Buffered-Commands-API/#command-72-expand-a-bitmap","title":"Command 72: Expand a bitmap","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 72, options, sourceBufferId; [width;] &lt;mappingDataBufferId; | mapping-data...&gt;</code></p> <p>This command will expend a bitmap stored in the source buffer indicated by <code>sourceBufferId</code> that uses an arbitrary number of bits per pixel into a new buffer (indicated by <code>bufferId</code>) that uses 8-bits per pixel.</p> <p>The primary intent of this command is to allow the VDP to support other formats of bitmap than the natively supported formats.  The bitmap should be mapped to valid RGBA2222 colour values, allowing the destination buffer to then be set as a bitmap in RGBA2222 format.  It should be noted that the destination buffer is not automatically marked as being a bitmap.</p> <p>It should also be noted that this command could be used for purposes other than expanding bitmaps, although the language used to describe the function of this command is based around bitmaps.  This is left to the user to explore.</p> <p>The <code>options</code> parameter is an 8-bit value that can have bits set to modify the behaviour of the operation.  The following bits are defined:</p> Bits Description 0-2 Number of bits per pixel in the source bitmap 3 When set, the source bitmap is aligns to the next byte at a given width (in pixels) 4 When set, mapping data is in a buffer 5-7 Reserved for future use (set to zero) <p>The number of bits per pixel in the source bitmap is specified by the bottom 3 bits of the <code>options</code> parameter.  This can be any value from 1 to 8 where a 0 is interpreted as 8.</p> <p>It is assumed that pixels are stored in the source buffer in a continuous manner, one byte at a time, starting from the top-most bits of the first byte.</p> <p>If bit 3 has been set of the options byte, then following the <code>sourceBufferId</code> should be a 16-bit <code>width</code> parameter.  This value is used as a pixel count, after which the system will align to the next byte.  This is useful when dealing with bitmaps that have widths that do not align to a byte boundary.</p> <p>The various different values that pixels will be mapped to should immediately follow in the command stream, with the number of bits per pixel given dictating how many mapping value bytes are sent (so 1 bits per pixel will have 2 values, 2 bits per pixel will have 4 values, and so on).  If bit 4 has been set of the options byte, then following the <code>width</code> parameter should be a 16-bit <code>mappingDataBufferId</code> parameter.  This buffer should contain the mapping data which will be used instead of values sent as part of the command stream..</p> <p>When a buffer is used for mapping data, that buffer must exist, and must contain a single block of at least the number of values required for the given number of bits per pixel.</p>"},{"location":"vdp/Buffered-Commands-API/#command-80","title":"Command 80: Set a buffer to be used for a callback","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 80, type;</code></p> <p>Sets a buffer to be used as a callback when a certain event is triggered in the VDP.</p> <p>Support for callbacks was added in VDP 2.12.0.</p> <p>The <code>type;</code> argument is a 16-bit value that specifies which type of callback the buffer is to be used for.  The following types are supported:</p> Type Event 0 VSYNC 1 Mode change <p>When a callback is triggered, the buffer will be run as if a \"buffer call\" command has been performed.  A buffer can be set to be used for multiple types of callback, and a type can have multiple buffers set to be used for it.  Adding the same buffer to the same type of callback multiple times will have no effect, it will only be called once when the event happens.</p> <p>Any VSYNC callbacks that may have been set will be cleared after any mode change.  If you wish to automatically restore VSYNC callbacks after a mode change then you should set a mode change callback with commands to set up your VSYNC callback.</p> <p>A buffer will remain as a callback until it is removed or the buffer deleted.  If you wish to have a \"one-shot\" callback then you should remove the buffer from the callback after it has been triggered.</p> <p>Additional callback event types will be added in later versions of the VDP.  These are likely to include callbacks for audio system events.</p>"},{"location":"vdp/Buffered-Commands-API/#command-81-remove-buffer-from-a-callback","title":"Command 81: Remove buffer from a callback","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 81, type;</code></p> <p>Removes a buffer from being used as a callback for a certain event type.</p> <p>Support for callbacks was added in VDP 2.12.0.</p> <p>The types are as described in command 80, with the addition that sending a type of <code>65535</code> will remove the buffer from all callback types.</p> <p>Calling this command with a bufferId value of <code>65535</code> will clear all callbacks for the given type.  Therefore if you wish to clear all callbacks for all types then you can call this command with a bufferId of <code>65535</code> and a type of <code>65535</code>.</p>"},{"location":"vdp/Buffered-Commands-API/#command-128-debug-info-command","title":"Command 128: Debug info command","text":"<p><code>VDU 23, 0, &amp;A0, bufferId; 128</code></p> <p>This command is a debugging command that will print out info on a buffer to the USB serial console.  This is useful for debugging purposes, and can be used to check the contents of a buffer after a series of operations have been performed on it.</p> <p>The info printed to the console will tell you how many blocks/streams are stored against the <code>bufferId</code>.  If the buffer contains a transform matrix, then the matrix will be printed out in a human-readable format.  For other buffers the whole of the first block/stream will be output to the console in hexadecimal format.  NB the whole block/stream will be output, so be aware that if the buffer is large then a lot of data will be sent to the console.</p> <p>Before VDP 2.10.0 this command would only work if you were using a VDP compiled with the <code>DEBUG</code> flag set.  As of VDP 2.10.0 this command will now work without the flag being set.</p>"},{"location":"vdp/Buffered-Commands-API/#examples","title":"Examples","text":"<p>What follows are some examples of how the VDP Buffered Commands API can be used to perform various tasks.</p>"},{"location":"vdp/Buffered-Commands-API/#loading-a-sample","title":"Loading a sample","text":"<p>Sound sample files can be large, and so it is not practical to send them over to the VDP in a single packet.  Even with optimised machine code, it could take several seconds to send a single sample over to the VDP.  This would block the screen, and make it impossible to show progress to the user.  Using the VDP Buffered Commands API we can send a sample over to the VDP in multiple packets.</p> <p>The following example will load a sound sample from a file called <code>sound.bin</code> and send it over to the VDP.  Lines 10-50 prepare things, opening up the file and getting its length.  Line 70 clears out buffer 42 so it is ready to store the sample.  The loop from lines 90 to 170 sends the sample one block at a time, adding the sample data to buffer 42.  Finally, lines 200-220 creates the sample, sets channel 1 to use it, and then plays it.</p> <pre><code> 10 blockSize% = 1000\n 20 infile% = OPENIN \"sound.bin\"\n 30 length% = EXT#infile%\n 40 PRINT \"Sound sample length: \"; length%; \"bytes\"\n 50 remaining% = length%\n 60 REM Load sample data into buffer 42\n 70 VDU 23, 0, &amp;A0, 42; 2       : REM Clear out buffer 42\n 80 PRINT \"Loading sample\";\n 90 REPEAT\n100   IF remaining% &lt; blockSize% THEN blockSize% = remaining%\n110   remaining% = remaining% - blockSize%\n120   PRINT \".\";       : REM Show progress\n130   VDU 23, 0, &amp;A0, 42; 0, blockSize%; : REM Send next blockSize% bytes to buffer 42\n140   FOR i% = 1 TO blockSize%\n150     VDU BGET#infile%\n160   NEXT\n170 UNTIL remaining% = 0\n180 CLOSE #infile%\n190 REM Set buffer 42 to be an 8-bit unsigned sample\n200 VDU 23, 0, &amp;85, 1, 5, 2, 42; 1     : REM Channel is ignored in this command\n210 VDU 23, 0, &amp;85, 1, 4, 8, 42;       : REM Set sample for channel 1 to buffer 42\n220 VDU 23, 0, &amp;85, 1, 0, 100, 750; length% DIV 16;  : REM Play sample on channel 1\n</code></pre> <p>Please note that the BASIC code here is not fast, owing to the fact that it has to read the sample file one byte at a time.  This is because BBC BASIC does not provide a way to read a chunk of a file at once.  This is not a limitation of the VDP Buffered Commands API, but rather of BBC BASIC.</p> <p>This can be optimised by writing a small machine code routine to read a chunk of a file at once, and then calling that from BASIC.  This is left as an exercise for the reader.</p> <p>Whilst this example illustrates loading a sample, it is easily adaptable to loading in a bitmap.</p>"},{"location":"vdp/Buffered-Commands-API/#repeating-a-command","title":"Repeating a command","text":"<p>This example will print out \"Hello \" 20 times.</p> <p>This is admittedly a contrived example, as there is an obvious way to achieve what this code does in plain BASIC, but it is intended to illustrate the API.  The technique used here can be fairly easily adapted to more complex scenarios.</p> <p>This example uses three buffers.  The first buffer is used to print out a string.  The second buffer is used to store a value that will be used to control how many times the string printing buffer is called.  The third buffer is used to call the string printing buffer the required number of times, and is gradually built up.</p> <pre><code> 10 REM Clear the buffers we're going to use (1-3)\n 20 VDU 23, 0, &amp;A0, 1; 2       : REM Clear out buffer 1\n 30 VDU 23, 0, &amp;A0, 2; 2       : REM Clear out buffer 2\n 40 VDU 23, 0, &amp;A0, 3; 2       : REM Clear out buffer 3\n 50 VDU 23, 0, &amp;A0, 1; 0, 6;   : REM Send the next 6 bytes to buffer 1\n 60 PRINT \"Hello \";            : REM The print will be captured into buffer 1\n 70 REM Create a writable buffer with ID 2, 1 byte long for our iteration counter\n 80 VDU 23, 0, &amp;A0, 2; 3, 1;\n 90 REM set our iteration counter to 20 - adjust (5), set value (2), offset 0, value 20\n100 VDU 23, 0, &amp;A0, 2; 5, 2, 0; 20\n110 REM gradually build up our command buffer in buffer 3\n120 VDU 23, 0, &amp;A0, 3; 0, 6;   : REM 6 bytes for the following \"call\" command\n130 VDU 23, 0, &amp;A0, 1; 1       : REM Call buffer 1 to print \"Hello \"\n140 VDU 23, 0, &amp;A0, 3; 0, 10;  : REM 10 bytes for the following \"adjust\" command\n150 REM Decrement the iteration counter in buffer 2\n160 VDU 23, 0, &amp;A0, 2; 5, 3, 0; -1\n170 VDU 23, 0, &amp;A0, 3; 0, 11;  : REM 11 bytes for the following \"conditional call\" command\n180 REM If the iteration counter is not zero, then call buffer 3 again\n190 VDU 23, 0, &amp;A0, 3; 6, 0, 2; 0;\n200 REM That's all the commands for buffer 3\n210 REM Now call buffer 3 to execute those commands\n220 VDU 23, 0, &amp;A0, 3; 1\n</code></pre> <p>It should be noted that after this code has been run the iteration counter in buffer ID 2 will have been reduced to zero.  Calling buffer 3 again at that point will result in the counter looping around to 255 on its first decrement, and then counting down from there, so you will see the loop run 256 times.  To avoid this, the iteration counter in buffer 2 should be reset to the desired value before calling buffer 3 again.</p> <p>Another thing to note is that if there were any additional commands added to buffer 3 beyond the final conditional call then it is likely that the VDP would crash, which is obviously not ideal.  This would happen because the call stack depth (i.e. number of \"calls within a call\") will have become too deep, and the command interpreter inside the VDP will have run out of memory.  This code works as-is because the conditional call is the last command in buffer 3 the VDP uses a method called \"tail call optimisation\" to avoid having to return to the caller.  The call is automatically turned into a \"jump\".  This is a technique that is used in many programming languages, and is a useful technique to be aware of.</p> <p>A safer way to write this code would be to use a conditional jump (command 8) rather than a conditional call.  This would avoid the call stack depth issue, and allow additional commands to be placed in buffer 3 after that jump.</p> <p>As a very simple example, you can imagine replacing buffer 1 with a buffer that draws something to the screen.  Those drawing calls could use relative positioning, allowing for repeated patterns to be drawn.  It could indeed do anything.  The point here is just to illustrate the technique.</p>"},{"location":"vdp/Buffered-Commands-API/#a-simplistic-reset-all-audio-channels-example","title":"A simplistic \"reset all audio channels\" example","text":"<p>Sometimes you will just want the ability to very quickly call a routine to perform a bulk action.  One potential example of this is to reset all audio channels to their default state (default waveform, and remove any envelopes that may have been applied).  The audio API provides a call to reset individual channels, but there is no call to reset them all.</p> <pre><code> 10 REM Clear the buffer we're going to use\n 20 resetAllChannels% = 7\n 30 VDU 23, 0, &amp;A0, resetAllChannels%; 2       : REM Clear out buffer\n 40 FOR channel = 0 TO 31\n 50   VDU 23, 0, &amp;A0, resetAllChannels%; 0, 5; : REM 5 bytes for the following \"reset channel\" command\n 60   VDU 23, 0, &amp;85, channel, 10\n 70 NEXT\n 80 REM Call the clear command\n 90 VDU 23, 0, &amp;A0, resetAllChannels%; 1\n</code></pre> <p>In this example we take a simplistic approach to building up a command that will reset all the audio channels.  The nature of the Audio API is that one can ask any channel to be reset, even if it has not been enabled, so we can just loop through all 32 potential channels.  An alternative approach could have been to disable all the channels and then enable a default number of channels.</p> <p>Once a command buffer has been sent it will remain on the VDP until that buffer is cleared.  This means that the <code>VDU 23, 0, &amp;A0, clearCommand%; 1</code> call can be made many times.  This can be useful if you wanted to reset all the audio channels at the start of a game loop, for instance.</p> <p>It is possible to write a more sophisticated version of this example that would use a loop on the VDP, rather than relying on sending multiple \"reset channel\" commands.  That would require the use of a few more buffers.  The reality of this approach however is that it is significantly more complex to accomplish and require quite a lot more BASIC code.  Since there is a lot of available free memory on the VDP for storing commands, it is not necessary to be overly concerned about the number of commands sent, so often a simpler approach such as the one in this example is on balance the better option.</p>"},{"location":"vdp/Buffered-Commands-API/#other-ideas-techniques-and-principles","title":"Other ideas, techniques, and principles","text":"<p>The examples above are intended to illustrate some of the principles of how the VDP Buffered Commands API can be used.  They are not intended to be complete solutions or illustrations of what is possible.</p>"},{"location":"vdp/Buffered-Commands-API/#stack-depth","title":"Stack depth","text":"<p>It should be noted that the VDP does not have a very deep call stack, and so it is possible to run out of stack space if you have a large number of nested calls.  (At the time of writing, the depth limit appears to be in the region of 20 calls.  For those that don't understand what \"stack depth\" means, an example of this would be calling buffer 1, which in turn calls buffer 2, which in turn calls buffer 3 and so on, up to calling buffer 20.)  If the depth limit is exceeded, the VDP will crash, and you will need to press the reset button.</p> <p>As noted above in the \"repeat\" example, the VDP will use a technique called \"tail call optimisation\" to help avoid/mitigate this issue.  This is where a call is automatically turned into a \"jump\" if it is the last command in a buffer.  This avoids the need to return to the caller, removing the need to start a new VDU command interpreter, and so avoids the call stack depth issue.</p> <p>Often the stack depth issue can be avoided by using a \"jump\" command rather than a \"call\" command (as this also does not need to start a new VDU command interpreter).  A jump differs from a call in that it just changes the command sequence being executed, and does not keep track of where it was being called from.</p> <p>The down-side of using a jump is that over-use of jumps can result in \"spaghetti code\", which can be difficult to follow.  It is therefore recommended to use jumps sparingly, and to use calls where possible.</p>"},{"location":"vdp/Buffered-Commands-API/#using-many-buffers","title":"Using many buffers","text":"<p>The API makes use of 16-bit buffer ID to allow a great deal of freedom.  Buffer IDs do not have to be used sequentially, so you are free to use whatever buffer IDs you like.  It is suggested that you can plan out different ranges of buffer IDs for your own uses.  For example, you could decide to use buffer IDs &amp;100-&amp;1FF for sprite management, &amp;200-&amp;2FF for sound management, &amp;400-&amp;4FF for data manipulation.  This is entirely up to you.</p> <p>Command buffers can be as short, or as long, as you like.  Often it will be easier to have many short buffers in order to allow for sophisticated behaviour.</p> <p>The VDP also has significantly more free memory available for storing commands and data than the eZ80 does, so it is not really necessary to be overly concerned about the number of commands sent.  (Currently there is 4 megabytes of free memory available on the VDP for storing commands, sound samples, and bitmaps.  The memory attached to the VDP is actually an 8 megabyte chip, and a later version of the VDP software may allow for even more of that to be used.)</p>"},{"location":"vdp/Buffered-Commands-API/#self-modifying-code","title":"Self-modifying code","text":"<p>A technique that was fairly common in the era of 8-bit home computers was to use self-modifying code.  This is where a program would modify its own code in order to achieve some effect.  The VDP Buffered Commands API allows for this technique to be used via the \"adjust buffer contents\" command.  For example this could be used to adjust the coordinates that are part of a command sequence to draw a bitmap, allowing for a bitmap to be drawn at different locations on the screen.</p>"},{"location":"vdp/Buffered-Commands-API/#jump-tables","title":"Jump tables","text":"<p>There are a number of ways to implement jump tables using the VDP Buffered Commands API.</p> <p>One such example would be to allocate a range of buffer IDs for use as jump table entries, and to use the \"adjust buffer\" command to change the lower byte of the buffer ID on a \"jump\" or \"call\" command (or a \"conditional\" version) to point to the buffer ID of the jump table entry.</p> <p>An alternative way could be to use \"jump with offset\" command with an advanced offset, specifying a block within a buffer to jump to, and adjusting that block as needed.  This would allow for a jump table to be built up within a single buffer.</p>"},{"location":"vdp/Buffered-Commands-API/#using-the-output-stream","title":"Using the output stream","text":"<p>Some VDU commands will send response packets back to MOS running on the eZ80.  These packets can be captured by using the \"set output stream\" command.  This can be used to capture the response packets from a command.</p> <p>When you have a captured response packet, the contents of the buffer can be examined to determine what the response was.  Values can be extracted from the buffer using the \"adjust buffer contents\" command and used to modify other commands.</p> <p>For example, you may wish to find out where the text cursor position is on screen and then use that information to work out whether the text cursor should be moved before printing new output.</p> <p>Care needs to be taken when using \"set output stream\" to ensure that the sequence of commands you're using doesn't create more response packets than you are expecting.  It is usually best to use this command within a buffered command sequence, as that will ensure that the output stream is reset to its original value once the buffered command sequence has completed.</p> <p>If you are using this command as part of a longer sequence it is recommended to use the \"set output stream\" command to reset the output stream to its original value (by using a buffer ID of 0) once you have captured the response packet you are interested in.</p> <p>Please note that at present the number of commands that send response packets is currently very limited, and so this technique is not as useful as it could be.  This will likely change in the future.</p> <p>Also to note here is that response packets will be written sequentially to the output stream.  There is no mechanism to control where in the output stream a response packet is written.  This means that if you are capturing response packets, you will need to be careful to ensure that the response packets you are interested in are not interleaved with other response packets that you are not interested in.  Clearing and re-creating a buffer before capturing response packets is recommended.</p>"},{"location":"vdp/Buffered-Commands-API/#use-your-imagination","title":"Use your imagination!","text":"<p>As can be seen, by having command sequences that can adjust the contents of buffers, and conditionally call other command sequences, it is possible to build up quite sophisticated behaviour.  You effectively have a programmable computer within the VDP.</p> <p>It is up to your imagination as to how exactly the API can be used.</p>"},{"location":"vdp/Context-Management-API/","title":"VDU 23, 0, &amp;C8: Context Management API","text":"<p>As of Console8 VDP 2.8.0 the VDP now has the ability to create and manage different graphical contexts.  This allows you to easily switch between different settings for drawing text and graphics on the VDP, and to save and restore these settings as needed.</p> <p>Almost all settings related to the text and graphics system are stored in the context.  These include things like the currently selected fonts for the text and graphics cursors, text cursor behaviour, position and display settings, the active cursor (whether the context is in <code>VDU 4</code> or <code>VDU 5</code> mode), the selected graphics coordinate system and last graphics cursor positions, the currently selected font, viewports, GCOL painting mode, the selected bitmap, and so on.</p> <p>The only graphical things that do not change with the context are things that should be considered \"global\" in nature.  That includes the contents of buffers and graphical items that make use of buffers, such as bitmaps and font definitions.  Sprites are also \"global\" in nature.  Additionally data related to the current screen mode and the system palette are global across all contexts.</p> <p>Changing the screen mode will reset the graphics system.  All saved contexts will be lost, and the current context stack cleared.</p>"},{"location":"vdp/Context-Management-API/#context-concepts","title":"Context concepts","text":"<p>There are two important concepts to understand when working with contexts, specifically the idea of a \"context stack\", and the idea of selecting a different context stack.</p>"},{"location":"vdp/Context-Management-API/#context-stacks","title":"Context Stacks","text":"<p>At any time you can choose to save the current graphics system state (context) to the context stack, or restore the last saved context from the stack.</p> <p>This allows for a simple way to save the current graphics system state, make temporary changes, and then step back to that previous state.</p> <p>This is a common concept in graphics programming APIs.  For example, in the HTML5 web canvas API, you can save the current state of the canvas, make changes, and then restore the previous state.  Similarly Apple's Core Graphics API has the same concept concept.</p> <p>You will always have an active context, and a context stack.</p>"},{"location":"vdp/Context-Management-API/#selecting-a-different-context-stack","title":"Selecting a Different Context Stack","text":"<p>The context management API also provides a way to select completely different context stacks.</p> <p>This can be useful if you want to have completely different sets of settings for different areas of your program, or applying to drawing different parts of the screen.</p> <p>As of VDP 2.12.0, the default context stack is context ID 0.  Changing screen mode will reset the currently selected context stack ID to 0.  In previous versions there was no default stack, which proved to be confusing.</p>"},{"location":"vdp/Context-Management-API/#the-api","title":"The API","text":"<p>The API to manage contexts is relatively simple, and consists of the following commands:</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-0-contextid-select-context-stack","title":"<code>VDU 23, 0, &amp;C8, 0, contextId</code>: Select context stack","text":"<p>This command will select a different context stack to use.</p> <p>If there is no context stack with the given <code>contextId</code>, a copy of the current context stack will be created and saved to the ID, and the new context stack will be selected.</p> <p>If you wish for your new context ID to have an empty stack, then you should subsequently clear the stack with the \"clear stack\" command.</p> <p>Once you have selected a context stack by ID, all subsequent changes to your context stack will be saved against that ID.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-1-contextid-delete-context-stack","title":"<code>VDU 23, 0, &amp;C8, 1, contextId</code>: Delete context stack","text":"<p>This command will delete the context stack with the given <code>contextId</code>.</p> <p>Please note that deleting a stack from the store will not affect the current context stack, and will not affect the current context.</p> <p>As of VDP 2.12.0 you cannot delete your currently selected context stack.  Attempting to do so will have no effect.  This ensures that there will always be at least one context stack available.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-2-flags-reset","title":"<code>VDU 23, 0, &amp;C8, 2, flags</code>: Reset","text":"<p>This command will reset the current context.  It accepts a bitfield of flags to indicate what aspects of the settings should be reset.  Sending a flags value of <code>0</code> will perform the same type of context reset that happens on a screen mode change.</p> <p>The following flags are supported:</p> Bit Description 0 Reset graphics painting options 1 Reset graphics positioning settings, including graphics viewport and coordinate system 2 Reset text painting options 3 Reset text cursor visual settings, including text viewport 4 Reset text cursor behaviour 5 Reset currently selected fonts 6 Reset character to bitmap mappings 7 Reserved for future use <p>These are broad reset options, resetting all settings in the given category to their default values.  More fine-grained control to reset individual settings are available via other VDU commands.</p> <p>When all flags are set to <code>0</code>, this command performs a reset equivalent to changing the screen mode.  The text cursor behaviour and character to bitmap mappings will be left unchanged, as will the selected positioning system.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-3-save-context","title":"<code>VDU 23, 0, &amp;C8, 3</code>: Save context","text":"<p>This command will save a copy of the current graphics style state to the context stack so you can later revert any changes you make to it using a \"restore\".</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-4-restore-context","title":"<code>VDU 23, 0, &amp;C8, 4</code>: Restore context","text":"<p>This command will restore the last saved context from the context stack.</p> <p>If there are no saved contexts on the stack, this command will do nothing.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-5-contextid-save-and-select-a-copy-of-a-context","title":"<code>VDU 23, 0, &amp;C8, 5, contextId</code>: Save and select a copy of a context","text":"<p>Saves the current context to the context stack.  If there is a context stack saved with the given <code>contextId</code> then a copy of the most recent context at that <code>contextId</code> will be made and activated, replacing the current context.</p> <p>If there is no context stack with the given <code>contextId</code>, then a copy of the current context will be saved to the stack, and you will be left with the current context.</p> <p>This means that in both cases the context before you called this command is saved to the stack, and to revert to it you should call the \"restore context\" command.</p> <p>Please note that this does not change the current active context stack, so the active context ID will remain the same.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-6-restore-all","title":"<code>VDU 23, 0, &amp;C8, 6</code>: Restore all","text":"<p>This command is equivalent to calling \"restore\" repeatedly until there are no more saved contexts on the stack.  It reverts back to the first context saved on the current stack.</p>"},{"location":"vdp/Context-Management-API/#vdu-23-0-c8-7-clear-stack","title":"<code>VDU 23, 0, &amp;C8, 7</code>: Clear stack","text":"<p>This command will clear all saved contexts from the current context stack.  You will be left with the current context still active, but no history to \"restore\" to.</p>"},{"location":"vdp/Copper-API/","title":"The \"Copper\" API","text":"<p>As of VDP 2.12.0 the VDP supports a set of functionality inspired by \"Copper\" effects on the Commodore Amiga.  The feature requires that a feature flag be set to enable the Copper API, which can be done using <code>VDU 23, 0, &amp;F8, &amp;310; 0;</code></p> <p>These effects work on screen modes that use a palette for generating their video output, i.e. 2, 4 and 16 color modes.  They are not supported in 64 color modes, as those modes have a fixed output palette.</p> <p>Through the use of this API, it is possible to potentially show all 64 colours that the Agon is capable of outputting on a single screen when in a 2, 4 or 16 colour mode.</p> <p>At the simplest level, this API allows for different areas of the screen to be shown in different colours.  This technique can allow for higher resolution screen modes that would otherwise be limited to showing only a few colours to show a wider range of colours.  A version of this technique was first used on machines like the BBC Micro in games such as Revs and Elite.  Revs, for instance, used this to allow the dashboard of the racing car to use a different selection of colours to the road, and the road to use a different selection of colours to the sky.  In total Revs shows 7 different colours on the screen at once, despite the screen mode it used only supporting 4 colours.</p> <p>When combined with the newly introduced VSYNC callback mechanism, it is possible to automatically change the signal list on a per-frame basis, allowing for a wide range of effects to be achieved.  This can be done completely on the VDP without your main program needing to send any additional commands once it has set things up.  For example, this can be used to add support for flashing colours (similar to the BBC Micro's mode 2), or animated palette effects that were popular on the Amiga.</p>"},{"location":"vdp/Copper-API/#how-it-works","title":"How it works","text":"<p>On palette-based screen modes, the screen framebuffer is converted on the fly whilst the VGA scanout is in progress, one row at a time, into the VGA output signal.  Up to and including VDP 2.11.0 only a single palette would be used for the signal output.  As of VDP 2.12.0, the Copper API allows for multiple palettes to be defined, and a \"signal list\" set to define which palettes should be used for scanout for different rows of the screen.</p> <p>Essentially, all drawing operations in palette-based screen modes are performed using the primary palette, palette ID 0.  The existing palette changing operations will only affect the primary palette.</p> <p>The Copper API supports 16-bit palette IDs, so in principle up to 65536 palettes could be defined.  However in practice you should never define that many.  These palettes are allocated in internal memory on the VDP, so there are practical limits to how many palettes can be defined.</p> <p>On changing screen mode, the signal list is reset and all palettes are cleared, leaving only the default palette.</p>"},{"location":"vdp/Copper-API/#copper-api-commands","title":"Copper API Commands","text":""},{"location":"vdp/Copper-API/#command-0-create-a-palette","title":"Command 0: Create a palette","text":"<p><code>VDU 23, 0, &amp;C4, 0, &lt;paletteID&gt;;</code></p> <p>This command creates a new palette with the specified ID.  The palette will initially be a copy of palette 0.</p> <p>NB this command may fail if the VDP runs out of internal memory.</p>"},{"location":"vdp/Copper-API/#command-1-delete-a-palette","title":"Command 1: Delete a palette","text":"<p><code>VDU 23, 0, &amp;C4, 1, &lt;paletteID&gt;;</code></p> <p>Removes the palette with the specified ID.  If the palette is currently in use in the signal list, it will be removed from the signal list, with its entries replaced with palette 0.</p> <p>Calling this command with palette ID 0 will have no effect.</p> <p>If you call this command with palette ID 65535 then all palettes will be deleted.</p>"},{"location":"vdp/Copper-API/#command-2-set-a-palette-entry","title":"Command 2: Set a palette entry","text":"<p><code>VDU 23, 0, &amp;C4, 2, &lt;paletteID&gt;; &lt;index&gt;, &lt;red&gt;, &lt;green&gt;, &lt;blue&gt;</code></p> <p>Changes the palette entry in the specified palette to the specified RGB value.</p> <p>The index value is the index of the palette entry to change.  This will wrap around if it is greater than the number of entries in the palette.  A 16 colour screen mode has entries numbered 0-15, a 4 colour screen mode has entries numbered 0-3, and a 2 colour screen mode has entries numbered 0-1.  Attempting to set a palette entry at index 17 will set the entry at index 1, and so on.</p> <p>The colour values for this command are 8-bit values, with 0 being the darkest and 255 being the brightest, i.e. in RGB888 format, consistent with VDU 19.</p> <p>If this command is used with a palette ID that does not yet exist then it will attempt to create a new palette with the specified ID.</p>"},{"location":"vdp/Copper-API/#command-3-setupdate-the-signal-list","title":"Command 3: Set/Update the signal list","text":"<p><code>VDU 23, 0, &amp;C4, 3, &lt;bufferId&gt;;</code></p> <p>This command is used to set the signal list.  The source list must be stored in a buffer, and the buffer ID is passed as an argument to this command.  Only the first block in a buffer is used.</p> <p>A signal list can be updated at any time, and the new signal list will take effect immediately.</p> <p>The buffered commands API can be used to create a buffer and fill it with a signal list.</p> <p>A source signal list is a set of pairs of 16-bit values stored in a buffer, where the first value is a count of rows, and the second value is the palette ID to use for those rows.  A single entry is therefore 4 bytes long.  The 16-byte values must be stored in the buffer in little-endian format.</p> <p>A source signal list can be of any length, entries are read sequentially from the source buffer.  If the total number of rows in the signal list is less than the number of rows in the screen, then the last palette in the signal list will be used for the remaining rows.  If the list has more entries than there are rows on the screen then the extra items in the signal list will be ignored.</p> <p>The output signal list will remain in effect until it is replaced by a new signal list, or until it is reset.  You are therefore free to do whatever you like with the buffer after the signal list has been set.</p> <p>By setting a signal list, and then adjusting the source buffer to contain different values, and then re-setting the signal list you can achieve a wide range of effects.  When coupled with the VSYNC callback mechanism these effects can be run completely within the VDP without needing to involve your main program.</p>"},{"location":"vdp/Copper-API/#command-4-reset-the-signal-list","title":"Command 4: Reset the signal list","text":"<p><code>VDU 23, 0, &amp;C4, 4</code></p> <p>This command resets the signal list to the default state, where the default palette is used for all rows.</p>"},{"location":"vdp/Copper-API/#using-copper-to-show-all-64-colours","title":"Using copper to show all 64 colours","text":"<p>As noted above, the Copper API allows for multiple palettes to be defined, and a signal list set to define which palettes should be used for scanout for different rows of the screen.  This therefore allows access to all 64 colours in screen modes that otherwise would only show 2, 4 or 16 colours.</p> <p>All drawing operations to the framebuffer are performed as normal, using only the primary palette for colour lookups.</p> <p>If you wish to show a bitmap image in a 16 colour screen mode in a manner similar to the Amiga's \"Hold and Modify\" mode, you can use the Copper API to set up a signal list that will show all 64 colours on the screen.  The bitmap data however will be drawn as if the primary palette is the only palette in use.  You would therefore need to prepare your bitmap using pixel values that correspond to the primary palette entries, and then prepare palettes and a signal list to change the colours during scan-out.</p>"},{"location":"vdp/Copper-API/#interactions-with-sprites","title":"Interactions with sprites","text":"<p>Software sprites are drawn into the framebuffer using the primary palette, and so their appearance on-screen will be affected by the signal list.</p> <p>Hardware sprites on the other hand are not drawn into the framebuffer, and so are not affected by the signal list.  They are shown in their natural colours using the Agon's available 64 colours.</p>"},{"location":"vdp/Enhanced-Audio-API/","title":"VDP Enhanced Audio API","text":"<p>NB: This is implemented in VDP versions 1.04 and above.</p> <p>The Agon-VDP supports audio commands via <code>VDU 23,0,&amp;85</code>, followed by further data to give the exact command required.</p> <p>The first byte usually indicates the channel, and the second byte the command.</p> <p>Parameters vary in number and meaning depending on the command.  Some parameters are bytes, some are 16-bit values sent as two bytes in little-endian order.  In the documentation below, 16-bit values are shown as <code>value1; value2;</code>, as per BBC BASIC syntax, and bytes as <code>value1, value2, value3, ...</code>.</p> <p>Examples are given in BBC BASIC.</p> <p>A common source of errors when sending commands to the VDP from BASIC via VDU commands is to forget to use a <code>;</code> after a number to indicate a 16-bit value should be sent.  If you see unexpected behaviour from your BASIC code that is the most likely source of the problem.</p> <p>When a command is processed the VDP may send a message back to MOS with the status of that command.  (Generally a return value of <code>1</code> indicates success, and <code>0</code> failure, but there are some exceptions to this, most notably the Status command.  Not all audio commands return a status.)  When the MOS receives an audio command status value it will set the audio bit of the VDP protocol flags to indicate that an audio message has been received.  It also sets two system state variable values, <code>sysvar_audioChannel</code> and <code>sysvar_audioSuccess</code> with the results of the command.  <code>sysvar_audioChannel</code> is the channel number, and <code>sysvar_audioSuccess</code> provides the status of that command.  These values can be read using a <code>mos_sysvars</code> API call, or an OSBYTE call from BASIC as documented here.</p> <p>It should be noted that VDP protocol flags are not automatically cleared by MOS, so it is the responsibility of the application to clear the audio bit of the VDP protocol flags before sending a command.  At present there is no way to do this directly from BBC BASIC.</p> <p>The full audio command set supported by the Agon-VDP is as follows:</p>"},{"location":"vdp/Enhanced-Audio-API/#command-0-play-note","title":"Command 0: Play note","text":"<p><code>VDU 23, 0, &amp;85, channel, 0, volume, frequency; duration;</code></p> <p>If the channel is not already busy, this command will play a note on the specified channel.</p> <p>The volume is a value from 0 to 127, where 0 is silent and 127 is full volume.  Values above 127 will be treated as 127.</p> <p>The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.</p> <p>The duration is a 16-bit value specifying in milliseconds the duration of the note to be played.  Specifying a value of -1 (65535) will cause the note to be played indefinitely until the channel is silenced by setting its volume to zero.  Specifying a value of zero will play the note for the duration of the attack and decay phases of any volume envelope set on the channel.  Additionally using a duration of zero on a channel that has been set to playback a sample, the sample will be played for its full duration.  (NB this is the sample duration at the time the play command was called.  Streaming in more data for the sample will not extend the duration of the note.)</p> <p>Returns 1 if the note was successfully queued for playback, or 0 if the channel was already in use.</p> <p>NB attempting to play a note on an inactive channel will return 1, but the note will not be played.  The channel must be active (see the status command) before a note can be played on it.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-1-status","title":"Command 1: Status","text":"<p><code>VDU 23, 0, &amp;85, channel, 1</code></p> <p>Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled.  The bit mask is as follows:</p> Bit Name Meaning 0 Active When set this indicates the channel is in use (has an active waveform) 1 Playing Indicates the channel is actively playing a note, and thus will reject calls to play a new note 2 Indefinite Set if the channel is playing an indefinite duration note 3 Has Volume Envelope Set if the channel has a volume envelope 4 Has Frequency Envelope Set if the channel has a frequency envelope <p>Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.</p> <p>For example, calling this command on a channel that is playing a note with no envelopes set will return a value of 3 (00000011).  A channel with a volume envelope set where playback is in the \"release\" phase of the envelope, and thus is free to play a new note, will return a value of 9 (00001001).  A completely silent channel with no envelopes set returns 0, whereas a silent channel that has a frequency envelope set will return 16 (00010000).</p>"},{"location":"vdp/Enhanced-Audio-API/#command-2-set-volume","title":"Command 2: Set volume","text":"<p><code>VDU 23, 0, &amp;85, channel, 2, volume</code></p> <p>Sets the volume of the specified channel.  The volume is a value from 0 to 127, where 0 is silent and 127 is full volume.  Values over 127 will be treated as 127 (with one exception described later).</p> <p>Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)</p> <p>Using this command provides more direct control over a channel than the play note command.  It can be used to adjust the volume of a channel that is already playing a note.</p> <p>Setting a non-zero volume level on a channel that is silent and not playing a note will cause the channel to play a note at the specified volume for an indefinite duration.  The note will be played at the frequency that was last set on the channel.</p> <p>Setting the volume to zero on a channel that is playing a note will silence the channel.  Whether this also aborts the note playback will depend on the VDP version you are using, and how you have set up the channel.</p> <p>Up to the Console8 VDP 2.4.0 release, setting the volume to zero will always abort note playback on a channel.</p> <p>From Console8 VDP 2.5.0 onwards, for channels that are playing a sample that has not reached the end of playback, setting the volume to zero will allow that sample to continue playing.  Attempting to play a new note on that channel will restart the sample.  Changing the sample will abort playback.  To guarantee stopping sample playback, set the duration to zero.  Behaviour for channels using other waveform types is unchanged.</p> <p>Returns back the volume level set or -1 (255) to indicate a failure.  Attempting to set the volume to -1 (or 255) on Console8 VDP 2.5.0 or later will not attempt to change the volume but instead will just return back the current volume level.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#special-case-volume-envelope","title":"Special case: Volume envelope","text":"<p>If the channel is actively playing a note with a volume envelope set on the channel then when setting the volume of a channel to zero, rather than silencing the channel immediately, the volume envelope will be allowed to complete (enter its \"release\" phase) before the channel is silenced.  A channel with volume envelope in its \"release\" phase is not considered to be actively playing a note, so during this phase setting the volume to zero will immediately silence the channel.</p> <p>Calling this command on a channel that has an active volume envelope adjusts the base volume level being applied to that envelope.  For more information see the documentation for the volume envelope command.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-3-set-frequency","title":"Command 3: Set frequency","text":"<p><code>VDU 23, 0, &amp;85, channel, 3, frequency;</code></p> <p>Sets the frequency of the specified channel.  The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.</p> <p>Using this command provides more direct control over a channel than the play note command.  It can be used to adjust the frequency of a channel that is already playing a note.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#special-case-frequency-envelope","title":"Special case: Frequency envelope","text":"<p>If the channel has a frequency envelope set then adjusting the frequency value whilst a note is playing will adjust the base frequency level being applied to that envelope.  For more information see the documentation for the frequency envelope command.</p>"},{"location":"vdp/Enhanced-Audio-API/#special-case-sample-playback","title":"Special case: Sample playback","text":"<p>Adjusting the frequency of a channel that is playing a sample will only result in the playback frequency being adjusted if the sample has been set to be tuneable.  By default samples are not tuneable, and so adjusting the frequency of a channel playing a sample will have no effect.  For more information see the documentation for the sample command.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-4-set-waveform","title":"Command 4: Set waveform","text":"<p><code>VDU 23, 0, &amp;85, channel, 4, waveformOrSample, [bufferId;]</code></p> <p>Sets the waveform type for a channel to use.  The <code>waveformOrSample</code> value is a single byte treated as a signed value.</p> <p>Using a negative value for the waveform indicates that a sample should be used instead.  For more information see the documentation for the sample command.</p> <p>By default a channel is set to use waveform 0 (square wave).</p> <p>Valid waveform values are as follows:</p> Value Waveform 0 Square wave 1 Triangle wave 2 Sawtooth wave 3 Sine wave 4 Noise (simple white noise with no frequency support) 5 VIC Noise (emulates a VIC6561; supports frequency) 8 Sample (specifying a 16-bit buffer ID for sample data) <p>When specifying a waveform type of <code>8</code> for a Sample, the buffer ID for the sample must be sent as the next 16-bit value.  There must be a sample created for the given buffer ID for the command to work, otherwise this command will fail.  Similarly if a negative waveform value is given to indicate a sample then the sample must have been created for the given sample number for the command to work.</p> <p>By default, a sample will ignore the frequency value set on the channel or in the play note command unless the sample has explicitly been set to be tuneable.  Samples will also, by default, automatically loop if the note played is longer than the sample itself, or it is played for an indefinite duration.  The sample will continue to loop until the note is stopped.  This behaviour can be changed with commands documented below.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-sample-management","title":"Command 5: Sample management","text":"<p><code>VDU 23, 0, &amp;85, channelOrSample, 5, sampleCommand, [parameters]</code></p> <p>These commands are used to manage samples on the VDP which can be assigned to a channel as a waveform for playback.</p> <p>Sample data is stored in buffers on the VDP, and can be manipulated using the buffered commands API.</p> <p>When a negative number is used in place of the channel number then the command is referring directly to a sample, rather than a channel.  Samples referenced in this manner are, by default, stored in buffers in the range 64256-64383 (<code>&amp;FB00</code>-<code>&amp;FB7F</code>).  To map a negative sample number to a buffer range, you need to negate it, subtract 1, and then add it to 64256.  This means sample number -1 is stored in buffer 64256, -2 is stored in buffer 64257, and so on.  Any buffer however can be used for sample data, using commands listed below that explicitly reference a buffer ID.</p> <p>Sample commands will return 1 if the command is processed successfully, or 0 to indicate a failure.</p> <p>Sample commands 5, 3 and above were added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-0-load-sample","title":"Command 5, 0: Load sample","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 0, length; lengthHighByte, &lt;sampleData&gt;</code></p> <p>This command is used to transfer a sample over to the VDP for later playback.</p> <p>As sample data can be long, rather than using this command, you are advised instead to upload your sample data to a buffer on the VDP in multiple blocks using the buffered commands API and then use command 5, 2 (documented below) to indicate that the data within a buffer is a sound sample.  That approach also allows for the use of different formats of sample data.</p> <p>When using this command, the sample data is assumed to be 8-bit signed PCM samples at 16kHz.  The sample data is sent as a series of bytes of the given length.</p> <p>The length provided to this command is a 24-bit value, sent in little-endian order.  It has been documented above as a 16-bit value followed by an 8-bit value for simplicity and/or compatibility with BBC BASIC.  Using a 24-bit length gives us the flexibility to support samples larger than 64kB.</p> <p>Specifying a sample number that has already been used will overwrite the existing sample with the new sample data, deleting all data contained within the corresponding buffer.  If the existing sample had been assigned to a channel for playback then playback will be stopped and the channel will be set to use the default waveform (square wave).</p> <p>A simple example of how to send a sample to the VDP using this command is as follows:</p> <pre><code> 10 REM Load a sample into the VDP\n 20 infile=OPENIN \"sample.raw\"\n 30 length=EXT#infile\n 40 REM Send sample info to the VDP for sample -1\n 50 VDU 23, 0, &amp;85, -1, 5, 0, length MOD 256, length DIV 256, length DIV 65536\n 60 REM Send sample data to the VDP\n 70 REPEAT\n 80   VDU BGET#infile\n 90 UNTIL EOF#infile\n100 CLOSE#infile\n110 REM Set channel 1 to use sample -1\n120 VDU 23, 0, &amp;85, 1, 4, -1\n130 REM Play sample on channel 1\n140 SOUND 1, -10, 10, length / 50\n</code></pre> <p>NB This example can be very slow as it sends the sample data byte-by-byte, taking just over 1s to send 2kb of data.  During this time your computer will be unresponsive, and it is not possible to output to screen any kind of progress as any such <code>PRINT</code> command will be interpreted as part of the sample data.  Unfortunately at present there is no way to send data in bulk to the VDP from BBC BASIC, or to read chunks of files into memory in one go.  For faster transfer of sample data you will need to write a program in assembly language and make use of file access APIs from MOS and the RST #18 vector to send larger chunks of data to the VDP.</p> <p>The VDP Buffered Commands API provides an alternative example of sending sample data to the VDP which allows for progress to be reported whilst the sample is being uploaded.</p> <p>As noted above, this command will return 1 on success or 0 for failure.  In the event of a failure the VDP will ignore and discard the sample data being sent to it.</p> <p>Failure may occur if an invalid sample number was given, or if the VDP could not allocate sufficient memory to store the sample.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-1-clear-sample","title":"Command 5, 1: Clear sample","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 1</code></p> <p>Removes the given sample number from the VDP.  If the sample had been assigned to a channel for playback then playback will be stopped and the channel will be set to use the default waveform (square wave).</p> <p>Deleting the underlying buffer using the buffered commands API will also remove the sample from the VDP.</p> <p>This command will return 1 on success or 0 for failure.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-2-create-a-sample-from-a-buffer","title":"Command 5, 2: Create a sample from a buffer","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 2, bufferId; format, [sampleRate;]</code></p> <p>This command is used to indicate that the data in the given buffer is a sound sample.  The channel number will be ignored for the purposes of this command, but will be used in the return result.</p> <p>The buffer ID is a 16-bit value giving the buffer number to use for the sample.  The buffer must have been created using the buffered commands API before this command is called.</p> <p>The format is a single byte giving the format of the sample data.  The following formats are supported:</p> Value Description 0 8-bit signed 1 8-bit unsigned <p>The format value can also have modifier bits set to modify the behaviour of the sample.  The following modifier bits are supported:</p> Value Description 8 sample rate is sent in the next 16-bits 16 sample is tuneable <p>The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).</p> <p>If the sample is indicated to be tuneable then the sample will be set by default to have a base frequency of 523Hz (C5, or the C above middle C).  This can be adjusted using the sample set frequency command 5, 3 documented below.  If the sample is not indicated to be tuneable then the sample will ignore the frequency value set on the channel or in the play note command.</p> <p>Once a sample has been created in this way, the sample can be selected for use on a channel using the following command:</p> <pre><code>VDU 23, 0, &amp;85, channel, 4, 8, bufferId;\n</code></pre> <p>Please note that if this command is called using a bufferId that has already been created as a sample then the existing sample definition will be overwritten.  This can be used, for example, to reset the parameters of a sample.  If the existing sample had been assigned to a channel for playback then playback will be stopped and the channel will be set to use the default waveform (square wave).</p> <p>This command will return 1 on success or 0 for failure.  The channel number of the response will correspond to the channel number given to this command.</p> <p>Support for changing sample rates, and tuneable samples, was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-3-set-sample-base-frequency","title":"Command 5, 3: Set sample base frequency","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 3, frequency;</code></p> <p>Sets the base frequency of the given sample, allowing playback of the sample to be tuned to different frequencies.  The 16-bit frequency value given specifies the frequency value in Hz that the sample data is deemed to represent.</p> <p>If the frequency of a sample has not been specified (or is set to zero) then the sample playback system will ignore the frequency value set on the channel or in the play note command.  Setting a base frequency allows the frequency of playback to be adjusted.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-4-set-sample-frequency-for-a-sample-by-buffer-id","title":"Command 5, 4: Set sample frequency for a sample by buffer ID","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 4, bufferId; frequency;</code></p> <p>Sets the base frequency of the sample identified by the given bufferId.  This command effectively operates the same as command 5, 3 but allows you to specify the sample by buffer ID rather than sample number.</p> <p>As with command 5, 2 the channel number will only be used for the return value and will otherwise be ignored.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-5-set-sample-repeat-start-point","title":"Command 5, 5: Set sample repeat start point","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 5, repeatStart; repeatStartHighByte</code></p> <p>Sets the start point for the sample repeat.  The repeat start point is a 24-bit value giving the offset in bytes from the start of the sample data to the point at which the sample should start repeating.  (See note against command 5, 0 for why this is a 24-bit value.)</p> <p>By default, samples will repeat from the start of the sample data.  Setting a repeat start point allows you to specify a point within the sample data from which the sample should repeat.  Setting a repeat start point to zero will cause the sample to repeat from the start of the sample data.  Setting a repeat start point to a value that goes beyond the end of the sample data will cause the sample to never repeat.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-6-set-sample-repeat-start-point-by-buffer-id","title":"Command 5, 6: Set sample repeat start point by buffer ID","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 6, bufferId; repeatStart; repeatStartHighByte</code></p> <p>Operates the same as command 5, 5 but similar to command 5, 4 allows you to specify the sample by buffer ID rather than sample number.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-7-set-sample-repeat-length","title":"Command 5, 7: Set sample repeat length","text":"<p><code>VDU 23, 0, &amp;85, sample, 5, 7, repeatLength; repeatLengthHighByte</code></p> <p>Sets the length of the sample repeat.  The repeat length is a 24-bit value giving the length in bytes of the sample repeat.  (See note against command 5, 0 for why this is a 24-bit value.)</p> <p>The default repeat length value for a sample is <code>-1</code> which indicates the sample should repeat until the end of the sample data, so by default samples will repeat.  (A length of -1 can be sent with this command as <code>&amp;FFFF; &amp;FF</code> for the length data.)</p> <p>Setting an explicit repeat length allows you to specify a length within the sample data for the sample to repeat.  Setting a length to zero, or a value that goes beyond the end of the sample data, will cause the sample to never repeat.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-5-8-set-sample-repeat-length-by-buffer-id","title":"Command 5, 8: Set sample repeat length by buffer ID","text":"<p><code>VDU 23, 0, &amp;85, channel, 5, 8, bufferId; repeatLength; repeatLengthHighByte</code></p> <p>Operates the same as command 5, 7 but similar to command 5, 4 allows you to specify the sample by buffer ID rather than sample number.</p> <p>This command will return 1 on success or 0 for failure.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-6-volume-envelope","title":"Command 6: Volume envelope","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, type, [parameters]</code></p> <p>These commands are used to set a volume envelope on a channel.</p> <p>When a volume envelope has been set on a channel then the volume level of the channel will be adjusted over time according to the envelope.  This can be used to create a variety of effects.</p> <p>The volume level given either by the play note command or the set volume command is used as the base/target volume level for the envelope.  The envelope will then adjust the volume level from this base level.</p> <p>When a volume envelope has been applied to a channel it will be applied to all notes played on that channel until the envelope is changed or removed, just like it would on a synthesiser.</p> <p>Volume envelopes have the concept of a \"release\" phase.  When a channel playing a note is in the \"release\" phase the channel may still be making a noise, but it is no longer considered to be busy and so it is free to be used for another note.</p> <p>It should be noted that volume envelopes are compatible with sample playback.  If a channel is set to play a sample and has a volume envelope set then it will be applied to the sample playback.  As the \"release\" phase of a volume envelope is not considered to be part of the duration of a note though, this means that some attention needs to be paid to the duration of notes when playing samples.  You are advised to either use envelopes without a release phase (i.e. with a release duration of <code>0</code>), or to subtract the duration of the release phase from the duration of the note when playing a sample.  Giving the complete duration of the sample when playing a note would otherwise result in the sample starting to repeat when the \"release\" phase begins.</p> <p>With all volume envelope types, it should be noted that the maximum volume level that the sound system supports is 127, and so volumes will get clipped to that level.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>The following envelope types are supported:</p>"},{"location":"vdp/Enhanced-Audio-API/#type-0-none","title":"Type 0: None","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, 0</code></p> <p>Disables the volume envelope on the given channel.</p>"},{"location":"vdp/Enhanced-Audio-API/#type-1-adsr","title":"Type 1: ADSR","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, 1, attack; decay; sustain, release;</code></p> <p>Sets the volume envelope on the given channel to use an ADSR envelope.</p> <p>Values for attack, decay and release are all 16-bit numbers giving a time for that phase in milliseconds.  The sustain value is an 8-bit number giving the level to sustain at, which is a modifier to the target level.</p> <p>This is a common type of envelope used in many synthesizers.  It is made up of four stages:</p> <ul> <li>Attack - The volume level rises from 0 to the target volume level over the given number of milliseconds.</li> <li>Decay - The volume level falls from the sustain level to the release level over the given number of milliseconds.</li> <li>Sustain - The volume level is held at the sustain level until the note is released.</li> <li>Release - The volume level falls from the sustain level to 0 over the given number of milliseconds.</li> </ul> <p>The volume level during the sustain phase is calculated using the simple formula: <pre><code>sustainLevel = (targetLevel * sustain) / 127\n</code></pre></p> <p>When playing a note on a channel that has an ADSR envelope set the note duration is handled slightly differently.  A note will always play for a minimum of the Attack and Decay phases.  Calling \"play note\" with a duration of zero will therefore play a note for the Attack and Decay phases.  The sustain phase will only be entered if the note duration is longer than the Attack and Decay phases.  The Release phase will be entered either when the note duration has elapsed or the Attack and Decay phases have completed, whichever is longer.</p> <p>An example of setting an ADSR envelope on a channel is as follows:</p> <pre><code> 10 REM Set channel 1 to use an ADSR envelope\n 20 VDU 23, 0, &amp;85, 1, 6, 1, 400; 100; 100, 2000;\n 30 REM Play a note on channel 1\n 40 VDU 23, 0, &amp;85, 1, 0, 60, 440; 1500;\n</code></pre> <p>In this example we are defining an ADSR envelope, and then playing a note.  We are using the <code>VDU`` command to play the note, rather than the</code>SOUND` command just for clarity.</p> <p>The ADSR envelope set here has an attack phase of 400ms, a decay phase of 100ms, a relative sustain level of 100 and a release phase of 2000ms.  The note we are playing is an \"A\" (440Hz) with a duration of 1500ms and a base/target volume of 60.</p> <p>What you hear when this code runs is a note that starts off quiet and over 0.4s it gradually gets louder until it reaches the target volume of 60 - this is the attack phase.  The note quickly over the next 0.1s reduces its volume down to the sustain level of 47 (calculated using (60 * 100) / 127) - this is the decay phase.  The note then holds at this volume level for a further 1s, at which point a total of 1500ms has elapsed (the note duration we sent to the play note command) - this is the sustain phase.  Finally the note gradually reduces its volume over 2s until it is silent - this is the release phase.</p> <p>As noted elsewhere, during this release phase the channel is considered to be free and so can be used to play another note.  Playing another note will interrupt the release phase and the new note will immediately play.</p>"},{"location":"vdp/Enhanced-Audio-API/#type-2-multi-phase-adsr","title":"Type 2: Multi-phase ADSR","text":"<p><code>VDU 23, 0, &amp;85, channel, 6, 2, attackCount, [level, duration;]*, sustainCount, [level, duration;]*, releaseCount, [level, duration;]*</code></p> <p>* this sub-phase data is optional, depending on the preceding count value, and will repeat as necessary to match the count.</p> <p>This command will set up a volume envelope that supports multiple sub-phases for each attack/decay, sustain, and release phases.  Conceptually this command is similar to the simpler type 1 ADSR envelope, but it allows each phase to be split into sub-phases for greater control.</p> <p>This is a variable length command, with the exact format and number of parameters determined by the command itself.</p> <p>Each sub-phase consists of two pieces of data; a target volume level, and the duration of that sub-phase in the format <code>level, duration;</code>.  The duration is a 16-bit value setting the length in ms for that sub-phase.  The target volume level is the envelope data is a number from 0-255 and specifies a relative level centred around 127.  The actual target level, to be reached by the end of that sub-phase, is calculated as follows: <pre><code>actualTarget = (noteVolume * targetLevel) / 127\n</code></pre> (This is the same formula that the type 1 ADSR envelope uses for calculating the volume level its the sustain phase.)</p> <p>Unlike a type 1 ADSR envelope, this envelope type considers \"attack\" and \"decay\" to be part of the same envelope phase.  You can simulate distinct \"attack\" and \"decay\" phases by providing separate sub-phases for each within the attack/decay phase.</p> <p>Specifying zero attack/decay sub-phases is equivalent to specifying a single attack sub-phase with target volume level 127 of 0ms duration.</p> <p>As the \"sustain\" phase of a volume envelope extends until the note duration has completed, it gets some special consideration.  The following rules will apply:</p> <ul> <li>if no sustain phases are defined then the sustain level will match the end target level of the attack/decay phase</li> <li>if sustain sub-phases only consist of zero duration entries then the envelope will automatically evenly spread the remaining note duration amongst these sub-phases</li> <li>if any sub-phases contain a duration then the sustain phase will loop through these sub-phases<ul> <li>mixing in zero duration sub-phases will cause abrupt volume level steps</li> </ul> </li> </ul> <p>Envelopes with looping sustain phases will always complete a loop cycle before moving on to the release phase.  This means that a note effectively automatically extends its duration.  The audio system will, however, consider the note to be completed once the duration has been reached, even if the note is part-way through a \"sustain\" loop, allowing playback to be interrupted to start a new note.</p> <p>Once the sustain phase has completed the envelope will process the release sub-phases.  Conventionally the final release sub-phase will typically target a volume level of 0 for silence, although this is not required.</p> <p>TODO: add some examples</p> <p>Support for this envelope type was added in Agon Console8 VDP 2.5.0.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-7-frequency-envelope","title":"Command 7: Frequency envelope","text":"<p><code>VDU 23, 0, &amp;85, channel, 7, type, [parameters]</code></p> <p>These commands are used to set a frequency envelope on a channel.</p> <p>When a frequency envelope has been set on a channel then the frequency of the channel will be adjusted over time according to the envelope.  This can be used to create a variety of effects.</p> <p>The frequency given either by the play note command or the set frequency command is used as the base/target frequency for the envelope.  The envelope will then adjust the frequency from this base frequency.</p> <p>When a frequency envelope has been applied to a channel it will be applied to all notes played on that channel until the envelope is changed or removed, just like it would on a synthesiser.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>The following envelope types are supported:</p>"},{"location":"vdp/Enhanced-Audio-API/#type-0-none_1","title":"Type 0: None","text":"<p><code>VDU 23, 0, &amp;85, channel, 7, 0</code></p> <p>Disables the frequency envelope on the given channel.</p>"},{"location":"vdp/Enhanced-Audio-API/#type-1-stepped-frequency-envelope","title":"Type 1: Stepped frequency envelope","text":"<p><code>VDU 23, 0, &amp;85, channel, 7, 1, phaseCount, controlByte, stepLength; [phase1Adjustment; phase1NumberOfSteps; phase2Adjustment; phase2NumberOfSteps; ...]</code></p> <p>The design of the stepped frequency envelope is based on the pitch envelope provided as part of the <code>ENVELOPE</code> command in BBC BASIC.</p> <p>The number of phases is set by the <code>phaseCount</code> parameter.</p> <p>The <code>controlByte</code> parameter is a bit mask that controls how the envelope will operate.  The following bits are defined:</p> Bit Name Meaning 0 Repeats If set then the envelope will repeat indefinitely whilst the note continues to play.  If not set then the envelope will only be applied once. 1 Cumulative If Repeat has been set then the envelope will apply cumulatively on each repeat of the envelope.  If it is clear then the base frequency is used on each iteration thru the envelope. 2 Restrict If set the envelope frequency generator will be restricted to returning values the range 0-65535.  If the frequency goes outside this range then the envelope will set a zero frequency.  When clear the calculated frequency is permitted to go outside this range, and the actual frequency set will be treated as <code>MOD 65536</code>. <p>Currently no other bits are defined, and are reserved for future use, so should be set to zero.</p> <p>The <code>stepLength</code> parameter is a 16-bit number giving the length of each step in milliseconds.</p> <p>Each phase is defined by two parameters.  Firstly there is an adjustment value, given as a 16-bit number.  This is the amount that the frequency will be adjusted by for each step in the phase.  Secondly there is a number of steps for the phase, given as a 16-bit number.</p> <p>(In comparison, the BBC Micro's <code>ENVELOPE</code> command has a fixed three phase design, all time values were given in centiseconds, and would automatically repeat unless the top bit of the step length value was set.  The pitch envelope could not be applied cumulatively.  Two phase envelopes were achieved by setting the number of steps in the second phase to zero.)</p> <p>The following example sets a stepped frequency envelope on channel 1:</p> <pre><code> 10 REM Set channel 1 to use a stepped frequency envelope\n 20 VDU 23, 0, &amp;85, 1, 7, 1, 2, 1, 30; 40; 6; -30; 4;\n 30 REM Play a note on channel 1\n 40 SOUND 1, -10, 100, 30\n</code></pre> <p>This will play a simple \"siren\" like sound that goes up and down, which repeats for the duration of the note (1.5s).</p> <p>The envelope described here has two phases, and the steps are each set to be 30ms long.  The first phase has an adjustment of 40, and 6 steps.  The second phase has an adjustment of -30, and 4 steps.  The envelope will therefore start at the base frequency, and then increase by 40Hz every 30ms for 6 steps.  It will then decrease by 30Hz every 30ms for 4 steps.  The envelope will then repeat from the start.</p> <p>We can change the control byte value to 3, as follows for a different effect: <pre><code> 20 VDU 23, 0, &amp;85, 1, 7, 1, 2, 3, 30; 40; 6; -30; 4;\n</code></pre></p> <p>You may have noticed that with the envelope as defined we are raising by a total of 240Hz, and then lowering by a total of 120Hz...</p> <p>With this new control byte value, on each successive loop through the frequency envelope the note will get higher and higher.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-8-enable-channel","title":"Command 8: Enable Channel","text":"<p><code>VDU 23, 0, &amp;85, channel, 8</code></p> <p>This command will enable the given channel.</p> <p>By default, an Agon Light will start up with three channels enabled, numbered 0-2.  This command can be used to enable additional channels, up to 32 of them.</p> <p>Please note that channels do not have to be enabled in order.  For example, you can enable channel 31 without having enabled channels 0-30 first.</p> <p>Attempting to enable an already enabled channel will have no effect.</p> <p>It should be noted that enabling a channel has a cost, and so it is recommended that you only enable channels that you are actually using.  The performance of the VDP with a large number of channels enabled has not been tested.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-9-disable-channel","title":"Command 9: Disable Channel","text":"<p><code>VDU 23, 0, &amp;85, channel, 9</code></p> <p>This command will disable the given channel.</p> <p>The channel is immediately disabled.  Any sound that may have been playing is instantly stopped.</p> <p>Attempting to disable an already disabled channel will have no effect.</p> <p>Re-enabling a disabled channel will give you a fresh channel, with none of the previous settings for that channel being retained.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-10-reset-channel","title":"Command 10: Reset Channel","text":"<p><code>VDU 23, 0, &amp;85, channel, 10</code></p> <p>This command will reset the given channel.</p> <p>This is equivalent to disabling and then enabling the channel.</p> <p>As with the disable command, any sound that may have been playing is instantly stopped.</p> <p>Following a reset, the channel will be in the same state as it was when it was first enabled.  This includes the frequency, volume, and envelope settings.  Resetting a channel is a fast way to stop the sound on a channel, and clear any envelopes that may have been set.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-11-seek-to-position","title":"Command 11: Seek to position","text":"<p><code>VDU 23, 0, &amp;85, channel, 11, position; positionHighByte</code></p> <p>For channels that are playing a sample, this command will seek to the given position within the sample data.  NB this is a byte offset from the start of the sample data, and not a time offset.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-12-set-duration","title":"Command 12: Set duration","text":"<p><code>VDU 23, 0, &amp;85, channel, 12, duration; durationHighByte</code></p> <p>Adjusts the duration (in ms) of any currently playing note on a channel.  If a channel is not already playing a note, then a new note will be played for the duration given.  The new note will be played at the last frequency and volume set for the channel.</p> <p>This command can be used to play notes for a duration longer than can be specified in the play note command, which can be useful for playing long sound samples.</p> <p>When used on a channel that is already playing a note, if the duration set is less than the time that the channel has currently been playing then the note will be stopped.</p> <p>If the duration is set to -1 (65535) then the note will be played indefinitely until the channel is silenced by setting its volume to zero, or by setting a duration to less than the time that the channel has currently been playing.</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-13-set-sample-rate","title":"Command 13: Set sample rate","text":"<p><code>VDU 23, 0, &amp;85, channel, 13, sampleRate;</code></p> <p>This command allows for the sample rate of a channel, or of the underlying audio system, to be adjusted.</p> <p>The primary intended use of this command is to allow for the sample rate of the underlying audio system to be adjusted.  This can be used to improve the quality of audio playback, or to reduce the processing time required by the VDP to play audio.  This is done by specifying a channel number of -1 (255).  The sample rate is a 16-bit value specifying the number of samples per second to play.</p> <p>By default when your Agon starts up the audio system's sample rate is set to 16kHz (16.384kHz to be precise).  Using a higher sample rate may result in slightly better quality audio, but will also use more processing time on the VDP.  Higher sample rates can be useful for tuned sample playback, or for playing back samples that have been recorded at a higher sample rate.</p> <p>When specifying a specific channel number, the effect of this command is to have that channel behave as if the underlying audio system is operating at the given sample rate.  This can be used to adjust the pitch of a channel relative to other channels.  This means that setting a sample rate higher than the underlying audio system will result in the channel being pitched lower than other channels, and vice versa.  Setting an individual channel to use a higher sample rate than the underlying audio system will not result in any greater clarity for that channel, and may result in a loss of quality for that channel.</p> <p>Changing the sample rate of the underlying audio system will affect all channels, and at the same time will reset the sample rate of all the channels to the same value.  This means that if you have set an individual channel to use a different sample rate than the underlying audio system then that channel will be reset to use the same sample rate as the underlying audio system.</p> <p>When changing the sample rate for the underlying audio system, the frequency of note playback is not affected by the sample rate, so changing the sample rate will not affect the pitch of notes being played.</p> <p>(NB there is a bug in the underlying audio system that means that changing the underlying sample rate will cause the pitch of notes currently being played to change.  If the next note played on a channel is at exactly the same frequency as the last note that will also play at an incorrect pitch.  Playing a note at a different frequency will clear this issue and all subsequent notes will be played at the correct pitch.  This issue does not affect sample playback.  This bug will be fixed in a future release.)</p> <p>Returns 1 on success, 0 for failure.</p> <p>Prior to Console8 VDP 2.5.0 this command did not return a status.</p> <p>This command was added in the Console8 VDP 2.2.0 release.</p>"},{"location":"vdp/Enhanced-Audio-API/#command-14-set-channel-waveform-parameters","title":"Command 14: Set channel waveform parameters","text":"<p><code>VDU 23, 0, &amp;85, channel, 14, parameter, value</code></p> <p>The exact use of this command will vary depending upon the waveform type being used by the channel.</p> Parameter Description 0 Duty cycle (0-255 for 0-100% - only applicable for channels with a square wave set) 2 Volume (0-127 for 0-100%) 3 Frequency (lower 8-bits only) &amp;83 Frequency (full 16-bit value) <p>The upper bits of the parameter byte are used to indicate the way that the value will be interpreted.  The following bits are defined:</p> Bit (Hex) Meaning 7 &amp;80 on = 16-bit value, off = 8-bit value <p>When a 16-bit value is used, the value is sent as two bytes in little-endian order, i.e. with the low byte first.  When a 8-bit value is used, the value is sent as a single byte.  If you specify a 16-bit value and only send a single byte then the next byte sent to the VDP (which you probably intended to be used for the next VDU command) will be used as the high byte of the value.</p> <p>If you provide a 16-bit value for a parameter that only supports an 8-bit value then the value will be truncated to 8-bits, i.e. the high 8-bits will be ignored.</p> <p>Future versions of this command may support setting other parameters, and the use of flags in the upper bits of the parameter byte to indicate different ways of interpreting the value provided.</p> <p>(Planned future versions of this command may support adjusting the parameter using a relative value, rather than an absolute one, or may support adjusting the parameter using a multiplier.  These features are not yet supported.)</p> <p>Returns 1 on success, 0 for failure.</p> <p>This command was added in the Console8 VDP 2.5.0 release.</p>"},{"location":"vdp/Font-API/","title":"VDU 23, 0, &amp;95: Font management","text":"<p>From Console8 VDP 2.8.0 onwards, the VDP now has an API to allow for different fonts to be uploaded to the VDP and used on your Agon.  At this time the VDP supports mono-spaced fonts only, each only at a single size.  Future versions of this API may introduce support for variable width fonts, and displaying text at different sizes.</p> <p>As with other APIs, the data for fonts is stored in buffers which are sent to the VDP using the Buffered Commands API.</p> <p>Generally when selecting a font to use, you will need to upload the font data to a buffer on the VDP, and then indicate that buffer contains a font.  Once this has been done the font can be selected and used to draw text on the screen.  The system font will always be available, and can be used by selecting font -1 (65535).</p> <p>You can define as many different fonts on the VDP as you have buffers available, and can switch between them as needed.  Your font selection is tied to your currently selected cursor, so you can select different fonts for use with your graphics cursor and your text cursor.</p> <p>The commands for the font API are as follows:</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-0-bufferid-flags-select-font","title":"<code>VDU 23, 0, &amp;95, 0, bufferId; flags</code>: Select font","text":"<p>Select a font to use for drawing text.</p> <p>The <code>bufferId</code> here must refer to a buffer that has been uploaded to the VDP, and marked as a font using <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>, as described below, or -1 (65535) for the system font.</p> <p>The <code>flags</code> parameter is a bitfield which can be used to specify options for the font.  The following flags are supported:</p> Bit Description 0 Adjust cursor position to ensure text baseline is aligned 1-7 Reserved for future use <p>If you wish to change the font within a line of text, you should use a flags setting of <code>1</code>.  This will use data within the font to ensure that the cursor position is moved to keep the text baseline aligned.</p> <p>When changing the font at the start of a new line, you should use a flags setting of <code>0</code>, as otherwise the text may overlap the previous line.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-1-bufferid-width-height-ascent-flags-create-font-from-buffer","title":"<code>VDU 23, 0, &amp;95, 1, bufferId; width, height, ascent, flags</code>: Create font from buffer","text":"<p>This command is used to mark a buffer as containing font data.  The <code>bufferId</code> must refer to a buffer that has been uploaded to the VDP, and contains font data.  The <code>width</code> and <code>height</code> parameters indicate the width and height of each character in the font in pixels, and <code>ascent</code> is the distance in pixels from the top of the character to the baseline.</p> <p>The <code>flags</code> parameter is reserved for future use, and should be set to 0.  In the future it will be used for indicating variable width fonts, and other font properties.</p> <p>Font data is assumed to be a contiguous block of data, one character at a time, with a full 256 character definitions, from character 0 to 255.  The buffer passed to this command should contain a single block of data of an appropriate size for the font.  If the data has been uploaded in multiple parts, it should be concatenated into a single block before calling this command using the appropriate commands in the buffered commands API.</p> <p>Fonts are monochrome, and the data is assumed to be one character at a time.  Each character is stored in a byte-aligned format, where each row of a character is stored in a number of bytes equal to <code>(width + 7) / 8</code>, with their pixels organised most significant bit first, with as many rows as indicated by the <code>height</code>.  \"Most significant bit first\" means that the leftmost pixel of the character is stored in the most significant bit of the first byte, so a font that is 6 pixels wide would be stored in bits 7-2, with bits 1 and 0 ignored when rendering the font.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-2-bufferid-field-value-set-or-adjust-font-property","title":"<code>VDU 23, 0, &amp;95, 2, bufferId; field, value;</code>: Set or adjust font property","text":"<p>Allows you to set or adjust properties of a font that has been created using <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>.  The <code>bufferId</code> must refer to a buffer that has been marked as containing font data.</p> <p>The <code>field</code> parameter indicates the property to set, and the <code>value</code> parameter is the value to set it to.  Whilst the <code>value</code> must be sent as a 16-bit value, most of the fields will only use the least significant 8-bits of the sent value.  The following fields are supported:</p> Field Description 0 width 1 height 2 ascent 3 flags 4 buffer for character pointers (for variable width fonts) * 5 point size (defaults to 0) * 6 inleading (defaults to 0) * 7 exleading (defaults to 0) * 8 weight (defaults to 400) * 9 character set (defaults to 255) * 10 code page (defaults to 1252) * <p>Fields 0-4 directly equate to the parameters passed to <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>.</p> <p>* Please note that as of VDP 2.8.0, whilst data can be set for these fields, setting them will not affect the rendering of the font.  They are reserved for future use.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-3-bufferid-args-reserved","title":"<code>VDU 23, 0, &amp;95, 3, bufferId; [&lt;args&gt;]</code>: Reserved","text":"<p>This function is reserved for future use, and should not be used at this time.</p> <p>(The intent is that this will be used to set the name of the font.)</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-4-bufferid-cleardelete-font","title":"<code>VDU 23, 0, &amp;95, 4, bufferId;</code>: Clear/Delete font","text":"<p>Deletes a font that has been created using <code>VDU 23, 0, &amp;95, 1, &lt;args&gt;</code>.  The <code>bufferId</code> must refer to a buffer that has been marked as containing font data.</p> <p>NB: This does not delete the buffer itself, only the font definition.  The data remains intact in the buffer, and can be re-used to create a new font if desired.</p>"},{"location":"vdp/Font-API/#vdu-23-0-95-5-bufferid-copy-system-font-to-buffer","title":"<code>VDU 23, 0, &amp;95, 5, bufferId;</code>: Copy system font to buffer","text":"<p>Copies the system font data into a buffer and makes a new font definition for it.</p> <p>The buffer at the <code>bufferId</code> will be cleared first and then the system font data will be copied into it.  The buffer will then be marked as containing font data, and can be used as a font in the same way as any other font.</p> <p>This command will let you make multiple copies of the system font which can then be modified independently of each other using the buffered commands API.</p>"},{"location":"vdp/PLOT-Commands/","title":"VDU 25: PLOT commands","text":"<p><code>VDU 25, code, x; y;</code></p> <p>The Agon VDP system supports a number of <code>PLOT</code> commands via <code>VDU 25</code>, which are used to draw lines, circles, and other shapes on the screen.  The command set is inherited from Acorn's BBC Micro, plus Acorn's Graphics eXtension ROM (GXR).</p> <p>PLOT commands sent to the VDP all require a command byte, followed by two 16-bit values for X and Y coordinates.  The command byte is used to specify the drawing operation, and the mode in which the drawing operation is performed.</p> <p>Most PLOT commands require additional coordinates than the single pair provided with the command.  The graphics system works using a concept of a \"graphics cursor\", and will keep track of the last few positions of the graphics cursor.  Every PLOT command \"pushes\" a copy of the current graphics cursor position onto a stack, and then moves the graphics cursor to the new position.  Commands that require additional coordinates will look at the last few positions on the stack to determine the additional coordinates.</p> <p>Support for PLOT commands has grown over time, but is still only a subset of those available on a BBC Micro with a GXR ROM.</p> <p>PLOT commands are essentially split into a drawing operation, and a mode that controls how the drawing operation is performed.  There are 8 different modes for each operation.  The command byte is effectively split into two parts where the lower 3 bits define the mode, and the upper 5 bits define the drawing operation.</p> <p>The complete set of PLOT codes supported by the Agon VDP follows.  For completeness, all commands from Acorn's command set are shown, including those that are not yet supported.</p> PLOT code (Decimal) Effect &amp;00-&amp;07 0-7 Solid line, includes both ends &amp;08-&amp;0F 8-15 Solid line, final point omitted &amp;10-&amp;17 16-23 Dot-dash line, includes both ends, pattern restarted \u00a7\u00a7\u00a7\u00a7 &amp;18-&amp;1F 24-31 Dot-dash line, final point omitted, pattern restarted \u00a7\u00a7\u00a7\u00a7 &amp;20-&amp;27 32-39 Solid line, first point omitted &amp;28-&amp;2F 40-47 Solid line, both points omitted &amp;30-&amp;37 48-55 Dot-dash line, first point omitted, pattern continued \u00a7\u00a7\u00a7\u00a7 &amp;38-&amp;3F 56-63 Dot-dash line, both points omitted, pattern continued \u00a7\u00a7\u00a7\u00a7 &amp;40-&amp;47 64-71 Point plot &amp;48-&amp;4F 72-79 Line fill left and right to non-background \u00a7\u00a7 &amp;50-&amp;57 80-87 Triangle fill &amp;58-&amp;5F 88-95 Line fill right to background \u00a7\u00a7 &amp;60-&amp;67 96-103 Rectangle fill &amp;68-&amp;6F 104-111 Line fill left and right to foreground \u00a7\u00a7 &amp;70-&amp;77 112-119 Parallelogram fill &amp;78-&amp;7F 120-127 Line fill right to non-foreground \u00a7\u00a7 &amp;80-&amp;87 128-135 Not supported (Flood until non-background) &amp;88-&amp;8F 136-143 Not supported (Flood until foreground) &amp;90-&amp;97 144-151 Circle outline &amp;98-&amp;9F 152-159 Circle fill &amp;A0-&amp;A7 160-167 Circular arc \u00a7\u00a7\u00a7\u00a7 &amp;A8-&amp;AF 168-175 Circular segment \u00a7\u00a7\u00a7\u00a7 &amp;B0-&amp;B7 176-183 Circular sector \u00a7\u00a7\u00a7\u00a7 &amp;B8-&amp;BF 184-191 Rectangle copy/move &amp;C0-&amp;C7 192-199 Not supported (Ellipse outline) &amp;C8-&amp;CF 200-207 Not supported (Ellipse fill) &amp;D0-&amp;D7 208-215 Not defined &amp;D8-&amp;DF 216-223 Fill path (Experimental - Not defined on Acorn systems) \u00a7\u00a7\u00a7\u00a7 &amp;E0-&amp;E7 224-231 Not defined &amp;E8-&amp;EF 232-239 Bitmap plot \u00a7 &amp;F0-&amp;F7 240-247 Not defined &amp;F8-&amp;FF 248-255 Not defined <p>Within each group of eight plot codes, the effects are as follows:</p> Plot code Effect 0  (8) Move relative 1  (9) Plot relative in current foreground colour 2  (A) Plot relative in logical inverse colour \u00a7\u00a7\u00a7 3  (B) Plot relative in current background colour 4  (C) Move absolute 5  (D) Plot absolute in current foreground colour 6  (E) Plot absolute in logical inverse colour \u00a7\u00a7\u00a7 7  (F) Plot absolute in current background colour <p>Codes 0-3 use the position data provided as part of the command as a relative position, adding the position given to the current graphical cursor position.  Codes 4-7 use the position data provided as part of the command as an absolute position, setting the current graphical cursor position to the position given.</p> <p>The various \"Line fill\" plot commands have an additional effect, which is to adjust the graphics cursor position to the right-hand edge of the filled line, if one was drawn.</p> <p>\u00a7 Support added in Agon Console8 VDP 2.1.0 \u00a7\u00a7 Support added in Agon Console8 VDP 2.2.0 \u00a7\u00a7\u00a7 Support added in Agon Console8 VDP 2.6.0 \u00a7\u00a7\u00a7\u00a7 Support added in Agon Console8 VDP 2.7.0</p>"},{"location":"vdp/PLOT-Commands/#interaction-with-gcol-paint-modes","title":"Interaction with GCOL paint modes","text":"<p>The GCOL command (<code>VDU 18, mode, colour</code>) is used to set the paint mode for the PLOT command.  The paint mode is used to control how the PLOT command interacts with the existing pixels on the screen.</p> <p>Up until Console8 VDP 2.6.0 the only fully supported GCOL paint mode was mode 0, which sets the pixel to the target colour value.  This is the default mode, and is used if no GCOL command has been issued.  There was limited support for mode 4, which inverts the pixel, but this was only supported for straight line drawing operations.</p> <p>As of Console8 VDP 2.6.0, the following modes are now available for all currently supported plot operations:</p> Mode Effect 0 Set on-screen pixel to target colour value 1 OR value with the on-screen pixel 2 AND value with the on-screen pixel 3 EOR value with the on-screen pixel 4 Invert the on-screen pixel 5 No operation 6 AND the inverse of the specified colour with the on-screen pixel 7 OR the inverse of the specified colour with the on-screen pixel <p>PLOT commands using an \"inverse\" plot code are essentially identical to setting a GCOL paint mode of 4, and will temporarily override the current GCOL paint mode if a different GCOL paint mode is set.</p>"},{"location":"vdp/PLOT-Commands/#line-drawing-plot-codes-00-3f","title":"Line drawing (PLOT codes &amp;00-&amp;3F)","text":"<p>For all of the line drawing plot codes, the position given with the PLOT command is the end point of the line.  The start point of the line is the last position on the graphics cursor stack.</p> <p>Support for plotting dotted lines was added in Agon Console8 VDP 2.7.0.  The default pattern is 1 pixel on, 1 pixel off, but this can be changed using the <code>VDU 23, 6, n1-n8</code> command which takes 8 bytes of data.  The length of pattern can be set using <code>VDU 23, 0, 242, n</code> where n is the number of pixels in the pattern.  Setting a length of zero will reset to the default pattern with a length of 8.  When drawing a line, the pattern is repeated as many times as necessary to draw the line and will be used from the top-most bit of the pattern data, repeating as necessary to draw the whole line.</p>"},{"location":"vdp/PLOT-Commands/#line-fill-codes-plot-codes-48-4f-58-5f-68-6f-78-7f","title":"Line fill codes (PLOT codes &amp;48-&amp;4F, &amp;58-5F, &amp;68-6F, &amp;78-&amp;7F)","text":"<p>These various PLOT codes will fill horizontal lines on the screen.  When executing \"drawing\" plot codes, the graphics system will scan the line to find appropriate start and end positions, depending on the PLOT code used and the screen contents.  The final calculated end position will be pushed to the graphics cursor stack.</p>"},{"location":"vdp/PLOT-Commands/#filled-triangles-plot-codes-50-57","title":"Filled triangles (PLOT codes &amp;50-&amp;57)","text":"<p>Filled triangles are drawn using the last two positions on the graphics cursor stack and the position given with the PLOT command.</p> <p>The behaviour of the triangle fill command has changed slightly in Agon Console8 VDP 2.6.0, and you may observe some slight differences in the exact pixels drawn when using this command.  Unfortunately the old behaviour was not compatible with the new GCOL paint modes, and so the behaviour had to be changed.  The behaviour is consistent with general \"best practice\" for triangle fill algorithms, and so should be more predictable and reliable.  As an example, with the revised triangle plotting it is possible to draw a fan of triangles using an EOR paint mode and you will not see the edges of the triangles \"cancel each other out\" as you would have done with the old behaviour.</p> <p>This new behaviour is not entirely consistent with the BBC Micro or GXR ROM, but it is more consistent with modern graphics systems and should be more predictable and reliable.  In practice, the differences are minimal and should not affect most programs.</p>"},{"location":"vdp/PLOT-Commands/#filled-rectangles-plot-codes-60-67","title":"Filled rectangles (PLOT codes &amp;60-&amp;67)","text":"<p>Filled rectangles are drawn using the last position on the graphics cursor stack and the position given with the PLOT command to define two corners of a rectangle.</p>"},{"location":"vdp/PLOT-Commands/#filled-parallelograms-plot-codes-70-77","title":"Filled parallelograms (PLOT codes &amp;70-&amp;77)","text":"<p>Parallelograms require three points to be defined.  They will therefore use the last two points pushed to the graphics cursor stack, coupled with the position given with the PLOT command.</p> <p>The three given points represent any three corners of the parallelogram.  The first and last (third) points are used to define opposing corners of the parallelogram.  The graphics system will calculate the fourth corner of the parallelogram as a point opposite to the second corner, and then fill the shape.</p>"},{"location":"vdp/PLOT-Commands/#circle-drawing-plot-codes-90-9f","title":"Circle drawing (PLOT codes &amp;90-&amp;9F)","text":"<p>Circle drawing requires two points to be defined.  They will therefore use the last point pushed to the graphics cursor stack, coupled with the position given with the PLOT command.  The first point is the centre of the circle, and the second point is a point on the circumference of the circle.</p>"},{"location":"vdp/PLOT-Commands/#arcs-segments-and-sectors-plot-codes-a0-b7","title":"Arcs, segments, and sectors (PLOT codes &amp;A0-&amp;B7) \u00a7\u00a7\u00a7\u00a7","text":"<p>Arcs, segments, and sectors require three points to be defined.  They will therefore use the last two points pushed to the graphics cursor stack, coupled with the position given with the PLOT command.</p> <p>Arcs, segments, and sectors are all drawn anticlockwise from a start point to an end.</p> <p>The first point defines the start of the arc, segment, or sector, which is a point on the circumference of the circle.  The second point defines the centre of the circle that the arc, segment, or sector is part of.  The distance from the first point to the second point defines the radius of the circle.  The final point (provided with the PLOT command) defines the end of the arc, segment, or sector.  This point does not have to be on the circumference of the circle, and the graphics system will calculate the point on the circumference that the arc, segment, or sector ends at.  Instead the final point is effectively used to define the angle of the arc.</p>"},{"location":"vdp/PLOT-Commands/#rectangle-copymove-plot-codes-b8-bf","title":"Rectangle copy/move (PLOT codes &amp;B8-&amp;BF)","text":"<p>These PLOT codes are interpreted slightly differently from others.  The purpose of these commands is to copy or move a rectangle of pixels from one location to another.  The rectangle is defined by the last two positions on the graphics cursor stack, and the position provided with the PLOT command is the destination to copy the rectangle to.</p> <p>A \"move\" operation will copy the rectangle to the new location, and then clear the original rectangle using the currently defined background colour.  (NB the background GCOL paint mode is not used when filling the original rectangle - the pixels will be set with the background colour).  A \"copy\" operation will copy the rectangle to the new location, but leave the original rectangle in place.</p> PLOT code Effect &amp;B8 Move cursor relative to last position &amp;B9 Relative rectangle move &amp;BA Relative rectangle copy &amp;BB Relative rectangle copy &amp;BC Move cursor to absolute position &amp;BD Absolute rectangle move &amp;BE Absolute rectangle copy &amp;BF Absolute rectangle copy"},{"location":"vdp/PLOT-Commands/#fill-path-experimental-plot-codes-d8-df","title":"Fill path - Experimental (PLOT codes &amp;D8-&amp;DF) \u00a7\u00a7\u00a7\u00a7","text":"<p>The ability to draw a filled path was added in the Agon Console8 VDP 2.7.0 release.  This command was not part of Acorn's original PLOT command set, either on the BBC Micro, in their Graphics Extension ROM, or in the later Acorn Archimedes operating systems.  For now, it should therefore be considered to be experimental.  Whilst at the time of writing this documentation it is thought that this command is not likely to change, it is possible that the command may be removed or altered in future releases.</p> <p>This command will fill a path defined by an arbitrary number of points.  The path must be at least three points long.</p> <p>As the path is is of an arbitrary length the nature of this commands operation differs from other PLOT commands.</p> <p>All new paths will be started with the last two points pushed to the graphics cursor stack, plus the position given with the PLOT command.  The path thus starts with three points and therefore, if no subsequent commands are received to extend the path, a triangle will be drawn.</p> <p>If the next VDU command received immediately after a fill path plotting command is also a matching \"Fill path\" PLOT command then the path will be extended with the new position given with the PLOT command.  If the next VDU command is not a matching \"Fill path\" PLOT command then the path will be considered to be complete, i.e. the path will be closed by connecting the last point to the first one and the graphics system will then fill the area defined by the path.</p> <p>Please note that any \"move\" PLOT command will be interpreted as closing the current path.  Whilst absolute and relative positioning PLOT commands can be combined when building up a path, changing between different codes (such as from \"foreground\" to \"background\" PLOTs) will be interpreted as closing the current path and starting a new path.</p> <p>If any other VDU commands are received after a \"Fill path\" PLOT command, then the path will be considered to be complete and the graphics system will fill the area defined by the path.  Similarly if there is a significant delay between the VDP receiving \"fill path\" PLOT commands, even if the next command uses a matching PLOT code, then the path will be considered to be complete and the graphics system will fill the area defined by the path.</p> <p>As a result of this mode of operation, it is not possible to interactively enter multiple \"fill path\" PLOT commands one after another at the BASIC command prompt using separate commands over multiple lines, as the system will interpret the character output for command entry as closing the current path.  Instead filled paths must be defined in a single command sequence, uninterrupted by other VDU commands, usually as part of a program.</p>"},{"location":"vdp/PLOT-Commands/#bitmap-plots-plot-codes-e8-ef","title":"Bitmap plots (PLOT codes &amp;E8-&amp;EF)","text":"<p>Bitmap plots will draw the currently selected bitmap to the screen.</p> <p>Before a bitmap plot can be used a valid bitmap must be selected using either <code>VDU 23, 27, 0, id</code> or <code>VDU 23, 27, &amp;20, bufferId;</code>.</p> <p>Bitmap plots will only draw non-transparent pixels to the screen.  When using \"foreground\" PLOTs, the bitmap is drawn to screen using the current foreground GCOL painting mode using the colour from the bitmap.  When using \"background\" PLOTs, the bitmap is drawn to screen using the current background GCOL painting mode using the currently selected background colour.  Inverse plot modes invert on-screen pixels that correspond to non-transparent pixels in the bitmap.</p> <p>As of Console8 VDP version 2.9.0 it is possible to set an affine transform matrix to be applied to bitmap plots.  This allows for bitmaps to be scaled, rotated, sheared, and translated when being drawn onto the screen.  The transform matrix is set using <code>VDU 23, 0, &amp;96, 1, bufferId;</code> which is documented in the System Commands documentation.  The buffered commands API provides commands to set and manipulate the transform matrix, and is documented in the Buffered Commands documentation.</p>"},{"location":"vdp/PLOT-Commands/#plot-support-prior-to-vdp-104","title":"PLOT support prior to VDP 1.04","text":"<p>Prior to VDP 1.04 the PLOT command support was very limited, did not support relative positioning, and had buggy and incorrect interpretations of some of the PLOT codes.  As of VDP 1.04 the PLOT command support has been greatly improved, and is now much more compatible with the BBC Micro and GXR ROM.</p> <p>The most significant bug was the mis-interpretation of several \"move\" commands to instead be \"draw\".  As a result, some programs written for earlier versions of the VDP firmware may no longer work correctly.  Fixing these programs however is usually very straightforward and usually just involves changing the PLOT code used.</p>"},{"location":"vdp/PLOT-Commands/#compatibility","title":"Compatibility","text":"<p>If the VDP does not recognise a plot operation, it will be ignored.  This can allow you to write programs that \"feature detect\" whether the VDP supports a particular plot operation, and then use it if it does, or fall back to an alternative if it does not.</p>"},{"location":"vdp/Screen-Modes/","title":"Screen Modes","text":"<p>The Agon VDP supports a number of different screen modes, which are listed below.</p> <p>Screen modes are selected using <code>VDU 22, mode</code>, or in BASIC using <code>MODE mode</code>.</p> <p>The list of screen modes available for use got revised and greatly expanded in VDP version 1.04.  The revision was mostly to make the screen modes more compatible with the VGA standards, and thus more compatible with modern monitors.  The original screen modes are still available, but are now considered legacy modes.</p> <p>It should be noted that whilst the Agon VDU command system is designed to be compatible with the BBC Micro, the screen modes are not.  The BBC Micro has a different set of screen modes, and the Agon VDP does not support them.</p> <p>By default, the Agon VDU system uses and adopts the BBC Micro's \"logical\" coordinate system for graphics, which means that each screen mode appears to be 1280x1024 to software with the graphics origin 0,0 point at the bottom left of the screen.  As a result programs written the BBC Micro can usually be fairly easily adapted.</p> <p>This logical coordinate system differs from the BBC Micro and later Acorn systems in that Acorn systems all used round numbers for the multiplier between the logical and physical coordinate systems.  (This meant that on later Acorn systems some screen modes used logical resolutions other than 1024x1280, depending on the physical resolution of the mode.)  On Agon systems, the multiplier for the vertical resolution is, essentially never a round number.</p> <p>To work around the limitations of the logical coordinate system, it is possible to change the graphics system to use physical coordinates instead of logical coordinates.</p> <p>There are two VDU commands that will affect the screen modes that are available, and how the drawing system works.</p>"},{"location":"vdp/Screen-Modes/#vdu-commands","title":"VDU Commands","text":""},{"location":"vdp/Screen-Modes/#vdu-22-mode","title":"<code>VDU 22, mode</code>","text":"<p>This command selects a screen mode, where the screen mode is a single byte value and must be a mode from the list below.</p> <p>Screen modes numbered above 128 are double-buffered, meaning that the screen is drawn to an off-screen buffer, and then the buffer is copied to the screen.  This prevents flickering when drawing to the screen.  Double-buffered mode numbers are equivalent to a regular mode with 128 added.  Please note that owing to memory limitations not all screen modes can be double-buffered.</p> <p>As drawing operations, when in a double-buffered mode, are only performed in the off-screen buffer this means that the screen will not be updated until the active buffer is swapped.  This means, for instance, that if you enter a double-buffered screen mode in BASIC by using <code>MODE 129</code> then commands that you type will not be visible, as your input is being written to the off-screen buffer.  Commands will still be processed, but you will only see their effect when the buffer is swapped.  Buffers are swapped using <code>VDU 23, 0, &amp;C3</code></p> <p>It may sometimes not be possible to change into a screen mode, for instance because the VDP no longer has enough memory to support the mode.  In this case the system will fall back to the current mode, and if that fails to the default mode, which is mode 1.  All modes should always be available after a reset.</p>"},{"location":"vdp/Screen-Modes/#vdu-23-0-c0-n","title":"<code>VDU 23, 0, &amp;C0, n</code>","text":"<p>Turn logical screen scaling on and off, where 1=on and 0=off.</p> <p>When logical scaling is turned off, the graphics system will no longer use the 1280x1024 logical coordinate system and instead use pixel coordinates.  The screen origin point at 0,0 will change to be the top left of the screen, and the Y axis will go down the screen instead of up.  </p> <p>Support for this was added in VDP 1.03.</p>"},{"location":"vdp/Screen-Modes/#vdu-23-0-c1-n","title":"<code>VDU 23, 0, &amp;C1, n</code>","text":"<p>Switch legacy modes on or off.</p> <p>By default, the original screen modes 0-4 are not available and are instead replaced by new modes that are more compatible with modern monitors.  For compatibility with older software, written for Agon systems running earlier versions of the VDP firmware, this command can be used to switch back to those original, legacy, screen modes.</p> <p>Support for this was added in VDP 1.04</p>"},{"location":"vdp/Screen-Modes/#vdu-23-0-c3","title":"<code>VDU 23, 0, &amp;C3</code>","text":"<p>Swap the screen buffer (double-buffered modes only) or wait for VSYNC (all modes).</p> <p>This command will swap the screen buffer, if the current screen mode is double-buffered, doing so at the next VSYNC.  If the current screen mode is not double-buffered then this command will wait for the next VSYNC signal before returning.  This can be used to synchronise the screen with the vertical refresh rate of the monitor.</p> <p>Waiting for VSYNC can be useful for ensuring smooth graphical animation, as it will prevent tearing of the screen.</p> <p>(In BASIC performing a <code>*FX 19</code> command will also wait for VSYNC, but will not swap the screen buffer.)</p> <p>Support for this was added in VDP 1.04</p>"},{"location":"vdp/Screen-Modes/#screen-modes_1","title":"Screen modes","text":"<p>Modes over 128 are double-buffered</p>"},{"location":"vdp/Screen-Modes/#from-version-104-or-greater","title":"From Version 1.04 or greater","text":"Mode Horz Vert Cols Refresh *** 0 640 480 16 60hz * 1 640 480 4 60hz 2 640 480 2 60hz 3 640 240 64 60hz 4 640 240 16 60hz 5 640 240 4 60hz 6 640 240 2 60hz ** 7 n/a n/a 16 60hz 8 320 240 64 60hz 9 320 240 16 60hz 10 320 240 4 60hz 11 320 240 2 60hz 12 320 200 64 70hz 13 320 200 16 70hz 14 320 200 4 70hz 15 320 200 2 70hz 16 800 600 4 60hz 17 800 600 2 60hz 18 1024 768 2 60hz \u00a7 19 1024 768 4 60hz \u00a7 20 512 384 64 60hz \u00a7 21 512 384 16 60hz \u00a7 22 512 384 4 60hz \u00a7 23 512 384 2 60hz \u00a7\u00a7 24 640 512 16 60hz \u00a7\u00a7 25 640 512 4 60hz \u00a7\u00a7 26 640 512 2 60hz \u00a7\u00a7 27 640 256 64 60hz \u00a7\u00a7 28 640 256 16 60hz \u00a7\u00a7 29 640 256 4 60hz \u00a7\u00a7 30 640 256 2 60hz 129 640 480 4 60hz 130 640 480 2 60hz 132 640 240 16 60hz 133 640 240 4 60hz 134 640 240 2 60hz 136 320 240 64 60hz 137 320 240 16 60hz 138 320 240 4 60hz 139 320 240 2 60hz 140 320 200 64 70hz 141 320 200 16 70hz 142 320 200 4 70hz 143 320 200 2 70hz \u00a7 145 800 600 2 60hz \u00a7 146 1024 768 2 60hz \u00a7 149 512 384 16 60hz \u00a7 150 512 384 4 60hz \u00a7 151 512 384 2 60hz \u00a7\u00a7 153 640 512 4 60hz \u00a7\u00a7 154 640 512 2 60hz \u00a7\u00a7 156 640 256 16 60hz \u00a7\u00a7 157 640 256 4 60hz \u00a7\u00a7 158 640 256 2 60hz <p>* Mode 1 is the \"default\" mode, and is the mode that the system will use on startup.  It is also the mode that the system will fall back to use if it was not possible to change to the requested mode.</p> <p>** Mode 7 is the \"Teletext\" mode, and essentially works in a very similar manner to the BBC Micro's Teletext mode, which was also mode 7.</p> <p>*** As of Console8 VDP 2.8.0, mode 0 is now the mode that the VDP will use on startup.  The fallback mode when a requested mode is not available remains mode 1.</p> <p>\u00a7 Support for screen modes 19-23, 145-146 and 149-151 was added in Console8 VDP 2.10.0</p> <p>\u00a7\u00a7 Support for screen modes 24-30, and 153-158 was added in Console8 VDP 2.13.0</p>"},{"location":"vdp/Screen-Modes/#legacy-modes-prior-to-104","title":"Legacy modes (prior to 1.04)","text":"Mode Horz Vert Cols Refresh 0 1024 768 2 60hz 1 512 384 16 60hz 2 320 200 64 75hz 3 640 480 16 60hz"},{"location":"vdp/System-Commands/","title":"VDP System Commands","text":"<p><code>VDU 23, 0</code> is reserved for commands sent to the VDP.  These are largely unique to the Agon, and are used to access some of the more sophisticated features of the VDP.</p> <p>Some of the commands are used for operating system functionality, and will not usually need to be used by user applications, whilst others allow access to features that applications will want to use.</p> <p>Please note that not all versions of the VDP support the complete command set.  The following list uses the following symbols to indicate which VDP versions support which commands:</p> <p>* Requires VDP 1.03 or above  ** Requires VDP 1.04 or above  \u00a7 Requires Console8 VDP 2.3.0 or above  \u00a7\u00a7 Requires Console8 VDP 2.4.0 or above  \u00a7\u00a7\u00a7 Requires Console8 VDP 2.6.0 or above  \u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.7.0 or above  \u00a7\u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.8.0 or above  \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.9.0 or above  \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.12.0 or above  \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.14.0 or above</p> <p>Commands between &amp;80 and &amp;89 will return their data back to the eZ80 via the VDP serial protocol.</p> <p>NB:</p> <ul> <li>Prior to MOS 1.03 the subset commands that it supported were indexed from &amp;00, not &amp;80. For example, <code>VDU 23, 0, &amp;02</code> to request the cursor position.  Commands in the range &amp;00-&amp;7F were used on Acorn systems to control the VDU hardware, so to avoid conflicts, and to allow for the possibility of supporting some of those commands, Agon commands were re-indexed from &amp;80.</li> </ul>"},{"location":"vdp/System-Commands/#vdu-23-0-0a-n-set-cursor-start-line-and-appearance","title":"<code>VDU 23, 0, &amp;0A, n</code>: Set cursor start line and appearance \u00a7\u00a7\u00a7\u00a7","text":"<p>This command defines the start line (or row) of the cursor and its appearance.  Bits 0-4 define the start line of the cursor, and bits 5-6 define the cursor appearance.  The meaning of the appearance bits are as follows:</p> Bit 6 Bit 5 Meaning 0 0 Steady 0 1 Off 1 0 Fast blink 1 1 Slow blink <p>By default, the start line is zero, and the cursor appearance is a slow blink.</p> <p>This command works in conjunction with <code>VDU 23, 0, &amp;0B, n</code>, <code>VDU 23, 0, &amp;8A, n</code>, and <code>VDU 23, 0, &amp;8B, n</code> to define how the cursor will be drawn on screen.</p> <p>The cursor start line must be less than the current font height (which is currently 8 pixels, and cannot currently be adjusted).</p> <p>Support for this command was introduced in the Console8 VDP 2.7.0.  Its behaviour is compatible with the equivalent commands on the Acorn BBC Micro and RISC OS.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-0b-n-set-cursor-end-line","title":"<code>VDU 23, 0, &amp;0B, n</code>: Set cursor end line \u00a7\u00a7\u00a7\u00a7","text":"<p>This defines the end line of the cursor.  The displayed cursor will be drawn from the start line to the end line.  The end line must be greater than the start line, and less than the current font height.</p> <p>Together with the start line, this command defines the vertical size of the cursor.</p> <p>If the start and end lines are equal then the cursor will be drawn as a horizontal line.  If the end line value is less than the start line value then the cursor will not be drawn.  If a value is given that is greater than the current font height then the cursor will be drawn to the end of the font height.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-80-n-general-poll","title":"<code>VDU 23, 0, &amp;80, n</code>: General poll","text":"<p>This command will echo back <code>n</code> to MOS (see VDP Serial Protocol)</p> <p>This command is used by MOS and the VDP to synchronise with each other during the system start-up process.  It is not intended to be used by applications.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-81-n-set-the-keyboard-locale","title":"<code>VDU 23, 0, &amp;81, n</code>: Set the keyboard locale","text":"<p>Sets the keyboard to a given locale/format.  The following locales are supported:</p> Locale Description 0 UK 1 US 2 German 3 Italian 4 Spanish 5 French 6 Belgian 7 Norwegian 8 Japanese ** 9 US International ** 10 US International Alternate ** 11 Swiss German ** 12 Swiss French ** 13 Danish ** 14 Swedish ** 15 Portuguese ** 16 Brazilian Portuguese \u00a7 17 Dvorak \u00a7 <p>Any other value will be interpreted as UK.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-82-request-text-cursor-position","title":"<code>VDU 23, 0, &amp;82</code>: Request text cursor position","text":"<p>This command will return the current text cursor position to MOS.  Once the cursor position has been returned the text cursor position data inside MOS's system state variables will be updated to reflect the current cursor position.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-83-x-y-get-ascii-code-of-character-at-character-position-x-y","title":"<code>VDU 23, 0, &amp;83, x; y;</code>: Get ASCII code of character at character position x, y","text":"<p>This command will return the ASCII code of the character at the given character position to MOS.  There is a corresponding command <code>VDU 23, 0, &amp;93, x; y;</code> that works in the graphics coordinate system.</p> <p>This command works by comparing pixels on the screen at the given position to the currently selected font, using the currently selected text colour.  This means that it may not always be accurate, or able to succeed.  Redefining system font characters after they have been drawn, changing the font, modifying the definitions of characters within the selected font, changing the text colour, may cause this command to fail.</p> <p>This command will not recognise characters that have been mapped to bitmaps using <code>VDU 23, 0, &amp;92, char, bitmapId;</code>.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-84-x-y-get-colour-of-pixel-at-pixel-position-x-y","title":"<code>VDU 23, 0, &amp;84, x; y;</code>: Get colour of pixel at pixel position x, y","text":"<p>This command will return the colour of the pixel at the given pixel position to MOS.  The corresponding MOS sysvars will be updated to reflect the read pixel colour.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-85-channel-command-args-audio-commands","title":"<code>VDU 23, 0, &amp;85, channel, command, &lt;args&gt;</code>: Audio commands","text":"<p>Sends a command to the VDP Enhanced Audio API **</p> <p>Prior to VDP 1.04 this command could only perform what is now audio command zero, which plays a note on a channel.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-86-fetch-the-screen-dimensions","title":"<code>VDU 23, 0, &amp;86</code>: Fetch the screen dimensions","text":"<p>Returns the screen dimensions to MOS.  Generally applications should not need to call this, as this information will be automatically sent to MOS when the screen mode is changed.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-87-rtc-control","title":"<code>VDU 23, 0, &amp;87</code>: RTC control *","text":"<p>This command controls the Real Time Clock within the Agon VDP.</p> <ul> <li> <p><code>VDU 23, 0, &amp;87, 0</code>: Read the RTC</p> <ul> <li>a data packet will be sent to MOS with the current RTC data, and MOS sysvars updated accordingly</li> </ul> </li> <li> <p><code>VDU 23, 0, &amp;87, 1, y, m, d, h, m, s</code>: Set the RTC</p> </li> </ul>"},{"location":"vdp/System-Commands/#vdu-23-0-88-delay-rate-led-keyboard-control","title":"<code>VDU 23, 0, &amp;88, delay; rate; led</code>: Keyboard Control *","text":"<p>This command controls the keyboard repeat delay, repeat rate, and LED status.</p> <p>Only delay values between 250 and 1000 are supported, and represents a time in milliseconds before the key will start repeating.</p> <p>The rate value represents the time between key repeats, and is given in milliseconds.  Values from 33-500 are supported.</p> <p>The LED value is a bit mask that controls the state of the keyboard LEDs.  The following bits are defined:</p> Bit Name Meaning 0 Scroll Lock If set then the Scroll Lock LED will be turned on.  If clear then it will be turned off. 1 Caps Lock If set then the Caps Lock LED will be turned on.  If clear then it will be turned off. 2 Num Lock If set then the Num Lock LED will be turned on.  If clear then it will be turned off."},{"location":"vdp/System-Commands/#vdu-23-0-89-command-args-mouse-control","title":"<code>VDU 23, 0, &amp;89, command, [&lt;args&gt;]</code>: Mouse control **","text":"<p>Commands beginning with <code>VDU 23, 0, &amp;89</code> are reserved for mouse control, and are implemented from VDP 1.04 onwards.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-0-enable-the-mouse","title":"<code>VDU 23, 0, &amp;89, 0</code>: Enable the mouse","text":"<p>Enables the mouse cursor, and will start sending mouse data packets to MOS.</p> <p>If there is no mouse connected then this command will have no effect.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-1-disable-the-mouse","title":"<code>VDU 23, 0, &amp;89, 1</code>: Disable the mouse","text":"<p>Disables the mouse cursor, and will stop sending mouse data packets to MOS.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-2-reset-the-mouse","title":"<code>VDU 23, 0, &amp;89, 2</code>: Reset the mouse","text":"<p>Resets the mouse system restoring default settings.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-3-cursorid-set-mouse-cursor","title":"<code>VDU 23, 0, &amp;89, 3, cursorId;</code>: Set mouse cursor","text":"<p>Sets the mouse cursor to the given cursor ID.</p> <p>There are several built-in mouse cursors that are available for use.  These have been inherited from fab-gl and are numbered from 0-18.  The \"Cursor\" column in the table below shows the fab-gl name for the cursor.</p> ID Cursor Description 0 PointerAmigaLike 11x11 Amiga like colored mouse pointer 1 PointerSimpleReduced 10x15 mouse pointer 2 PointerSimple 11x19 mouse pointer 3 PointerShadowed 11x19 shadowed mouse pointer 4 Pointer 12x17 mouse pointer 5 Pen 16x16 pen 6 Cross1 9x9 cross 7 Cross2 11x11 cross 8 Point 5x5 point 9 LeftArrow 11x11 left arrow 10 RightArrow 11x11 right arrow 11 DownArrow 11x11 down arrow 12 UpArrow 11x11 up arrow 13 Move 19x19 move 14 Resize1 12x12 resize orientation 1 15 Resize2 12x12 resize orientation 2 16 Resize3 11x17 resize orientation 3 17 Resize4 17x11 resize orientation 4 18 TextInput 7x15 text input <p>Additional cursors can be defined using the <code>VDU 23, 27, &amp;40, hotX, hotY</code> command.  For details of that command see the Bitmaps API documentation.  Using that API it is possible to define a custom mouse cursor using a bitmap, which can then be selected using this command passing in the 16-bit bitmapId in place of a cursorId.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-4-x-y-set-mouse-cursor-position","title":"<code>VDU 23, 0, &amp;89, 4, x; y;</code>: Set mouse cursor position","text":"<p>Explicitly moves the mouse cursor to a given position on the screen.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-5-x1-y1-x2-y2-reserved","title":"<code>VDU 23, 0, &amp;89, 5, x1; y1; x2; y2;</code>: Reserved","text":"<p>This command is reserved for future use.  It is not yet implemented.</p> <p>(When implemented it will set the mouse area, which will restrict the mouse cursor to a given area of the screen.  The mouse cursor will not be able to leave this area.)</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-6-samplerate-set-mouse-sample-rate","title":"<code>VDU 23, 0, &amp;89, 6, sampleRate</code>: Set mouse sample rate","text":"<p>Sets the rate at which mouse data will be sampled.  The rate given is a number of samples per second.  The default rate is 60.</p> <p>Valid sample rates are 10, 20, 40, 60, 80, 100, and 200 (samples/sec).  Any other values will be ignored.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-7-resolution-set-mouse-resolution","title":"<code>VDU 23, 0, &amp;89, 7, resolution</code>: Set mouse resolution","text":"<p>Sets the mouse resolution.  Values in the range 0-3 are supported, or 255 (-1) to pick the default resolution.  The default resolution is 2.</p> <p>The following resolutions are supported:</p> Value Resolution 0 1 count per mm (25 dpi) 1 2 counts per mm (50 dpi) 2 4 counts per mm (100 dpi) (default) 3 8 counts per mm (200 dpi)"},{"location":"vdp/System-Commands/#vdu-23-0-89-8-scaling-set-mouse-scaling","title":"<code>VDU 23, 0, &amp;89, 8, scaling</code>: Set mouse scaling","text":"<p>Sets the mouse scaling factor.  Only values <code>1</code> and <code>2</code> are supported to indicate 1:1 or 1:2 scaling.  Additionally a value of <code>0</code> can be sent to indicate \"default\" scaling, which is 1:1.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-9-acceleration-set-mouse-acceleration","title":"<code>VDU 23, 0, &amp;89, 9, acceleration;</code>: Set mouse acceleration","text":"<p>This sets the mouse acceleration factor to a 16-bit value.  Setting the value to <code>0</code> will result in the default acceleration being used, which is 180.  The suggested range for this is 0-2000.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-89-10-wheelacceleration-wheelacchighbyte-set-mouse-wheel-acceleration-accepts-a-24-bit-value","title":"<code>VDU 23, 0, &amp;89, 10, wheelAcceleration; wheelAccHighByte</code>: Set mouse wheel acceleration (accepts a 24-bit value)","text":"<p>Sets the wheel acceleration factor to a 24-bit value.  Setting the value to <code>0</code> will result in the default acceleration being used, which is 60000.  The suggested range for this is 0-100000.</p>"},{"location":"vdp/System-Commands/#mouse-data-packets","title":"Mouse data packets","text":"<p>Mouse data packets are sent in response to all of the above commands, and if the mouse has been enabled whenever the mouse is moved.  This ensures that mouse data is constantly updated in MOS sysvars.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-8a-n-set-the-cursor-start-column","title":"<code>VDU 23, 0, &amp;8A, n</code>: Set the cursor start column \u00a7\u00a7\u00a7\u00a7","text":"<p>This command defines the start pixel column of the text cursor.  The displayed cursor will be drawn from the start column to the end column.  The start column can be set to any value, but for the cursor to be visible it must be less than the current font width.  The default value is 0.</p> <p>Acorn systems did not support directly adjusting the number of columns used by the cursor, and so this command is not supported on those systems and is an Agon-specific extension.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-8b-n-set-the-cursor-end-column","title":"<code>VDU 23, 0, &amp;8B, n</code>: Set the cursor end column \u00a7\u00a7\u00a7\u00a7","text":"<p>This command defines the end pixel column of the cursor.  The displayed cursor will be drawn from the start column to the end column.  The end column can be set to any value, but for the cursor to be visible it must be greater than the start column, and less than the current font width.  The default value is 255, which together with the default start column value ensures the cursor is the full width of the currently selected font.</p> <p>Together with the start column, this command defines the width of the cursor.</p> <p>If the start and end column values are equal then the cursor will be drawn as a vertical line.  If a value is given that is greater than the current font width then the cursor will be drawn to the end of the font width.</p> <p>Acorn systems did not support directly adjusting the number of columns used by the cursor, and so this command is not supported on those systems and is an Agon-specific extension.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-8c-x-y-relative-cursor-movement-by-pixels","title":"<code>VDU 23, 0, &amp;8C, x; y;</code>: Relative cursor movement (by pixels) \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command will move the text cursor by the given number of pixels in the X and Y directions.  The primary purpose of this command is to allow for slight adjustments of the text cursor position to facilitate text drawing features such as superscript, subscript and manual kerning.</p> <p>Normal cursor scrolling and wrapping behaviour will be obeyed, depending on the currently set cursor behaviour.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-90","title":"<code>VDU 23, 0, &amp;90, n, b1, b2, b3, b4, b5, b6, b7, b8</code>: Redefine character n (0-255) with 8 bytes of data \u00a7","text":"<p>This command works identically to <code>VDU 23, n, b1, b2, b3, b4, b5, b6, b7, b8</code>, but allows characters 0-31 to also be redefined.</p> <p>NB from Console8 VDP 2.8.0 this command will only function if the currently selected font is the system font.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-91","title":"<code>VDU 23, 0, &amp;91</code>: Reset all system font characters to original definition \u00a7","text":"<p>This command will reset all system font characters to their original definitions.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-92","title":"<code>VDU 23, 0, &amp;92, char, bitmapId;</code>: Map character char to display bitmapId \u00a7\u00a7","text":"<p>This command will map a character to a bitmap.  The bitmap ID given must be a valid bitmap in a 16 bit buffer ID.  The purpose of this command is to allow for fast and efficient drawing of bitmaps to the screen, by allowing them to be drawn as characters.</p> <p>Any character number can be used, including those in the range of 0-31, or the usual/normal alphabetic range.  This could be used, for instance, to create a custom colour font.  It could alternatively be used with characters in the range of 128-255 to define a custom graphical tile-set, like PETSCII but in colour.</p> <p>When a character has been mapped to use a bitmap the bitmap will be used in place of that character, and will be drawn at the current text cursor position, placing the bottom left of the bitmap at the cursor position.  The cursor position will then be moved to the right by the width of a character, and not by the width of the bitmap.</p> <p>That last point is important.  It means that if you use a bitmap that is larger than a character, then the next character will overlap the bitmap.  Similarly bitmaps that are taller than a character will overwrite the line of text above the current cursor.  This can be used to create some interesting effects, but can also be a source of visual bugs if you are not careful.  If you are using oversized bitmaps, then using the <code>VDU 9</code> to move forward an additional character may be useful.</p> <p>Bitmaps mapped to characters in this way are plotted using the current foreground GCOL paint mode.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-93-x-y-get-ascii-code-of-character-at-graphics-position-x-y","title":"<code>VDU 23, 0, &amp;93, x; y;</code>: Get ASCII code of character at graphics position x, y \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command will return the ASCII code of the character at the given graphics position to MOS.  This command is similar to <code>VDU 23, 0, &amp;83, x; y;</code>, but uses coordinates from the currently selected graphics coordinate system.  The position is for the top left of the character.</p> <p>This command works by comparing pixels on the screen at the given position to the currently selected font, using the currently selected text colour.  This means that it may not always be accurate, or able to succeed.  Redefining system font characters after they have been drawn, changing the font, modifying the definitions of characters within the selected font, changing the text colour, may cause this command to fail.</p> <p>This command will not recognise characters that have been mapped to bitmaps using <code>VDU 23, 0, &amp;92, char, bitmapId;</code>.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-94-n-read-colour-palette-entry-n-returns-a-pixel-colour-data-packet","title":"<code>VDU 23, 0, &amp;94, n</code>: Read colour palette entry n (returns a pixel colour data packet) \u00a7\u00a7","text":"<p>This command will return the colour of the given palette entry to MOS.  This data is sent using a \"screen pixel\" data packet.  The corresponding MOS sysvars related to screen pixel colour will be updated to reflect the read palette entry.</p> <p>The Agon VDP system supports a 64 colour palette, so values in the range of 0-63 will return data on that palette entry.  The following special values are also supported:</p> Value Description 128 The current text foreground colour 129 The current text background colour 130 The current graphics foreground colour 131 The current graphics background colour <p>Any other colour value will not be recognise, and no response sent.</p> <p>It should be noted that before Console8 VDP 2.7.0 when reading palette entries for the current text and graphics colours, the data packet returned would reflect back the colour number <code>n</code> sent to this command, rather than responding with the actual palette colour number for that colour.  As of Console8 VDP 2.7.0 the actual palette colour number is returned.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-95-command-args-font-management-commands","title":"<code>VDU 23, 0, &amp;95, &lt;command&gt;, [&lt;args&gt;]</code>: Font management commands \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command is used to manage fonts on your system.  For more information please see the Font API documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-96-flags-bufferid-set-an-affine-transform-matrix","title":"<code>VDU 23, 0, &amp;96, &lt;flags&gt;, &lt;bufferId&gt;;</code>: Set an affine transform matrix \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>As of the time of writing, this command is experimental and subject to change.  To enable it you must turn on the affine transform feature flag, using the <code>VDU 23, 0, &amp;F8, 1; 1;</code> command.</p> <p>This command tells the graphics system to use an affine transform matrix held within the given buffer for subsequent drawing commands.  This allows for the transformation of graphics when they are drawn in a variety of ways, including scaling, rotation, and translation.</p> <p>The <code>flags</code> field is used to indicate which parts of the graphics system should use the matrix.  The following flags bits are supported:</p> Bit Name Description 0 Bitmap Apply the matrix to bitmap drawing commands 1-7 Reserved Reserved for future use <p>The <code>bufferId</code> indicates which buffer holds the matrix data to use.  The matrix is assumed to be a 3x3 matrix of 32-bit floating point values, stored in little-endian byte order.  As creating and manipulating floating point data is not supported in the eZ80 various options are provided as part of the buffered commands API to allow for the creation and manipulation of these matrices.</p> <p>The <code>bufferId</code> set is used as a reference to the matrix.  If a matrix exists in the buffer then a copy of that will be used for all applicable drawing operations when they are performed, otherwise drawing operations will occur as if no matrix was set.  If a matrix is changed after it has been set, then the new matrix will be used for subsequent drawing operations.</p> <p>Setting the <code>bufferId</code> to 65535 (or -1) will clear the matrix, and subsequent drawing operations will not be transformed.</p> <p>Please note that when an affine transform is set to be applied when drawing bitmaps, the transform is always applied as if the top left of the bitmap is the \"origin\" point for the transform  So if an affine transform is set to only perform a rotation, then the bitmap will rotate around its top left corner.  This may be slightly contrary to expectations when using OS coordinates, as when plotting a bitmap using the PLOT command you specify the location for the bottom left of the bitmap.  So when using OS coordinates, the origin point of the transformation becomes where the top-left pixel would have been.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-98-n-turn-control-keys-on-and-off","title":"<code>VDU 23, 0, &amp;98, n</code>: Turn control keys on and off \u00a7\u00a7\u00a7","text":"<p>Turns control keys on and off, where 1=on (the default) and 0=off.</p> <p>When control keys are turned on, pressing control and various letters on the keyboard will cause the keyboard to trigger VDU commands on the VDP, where the VDU command corresponds to the number of that letter in the alphabet.  For example, pressing <code>CTRL</code>+<code>N</code> will perform the VDU command <code>VDU 14</code> on the VDP and turn on \"paged mode\", as N is the fourteenth letter.</p> <p>Up to and including Console8 VDP 2.4.0, only <code>CTRL</code>+<code>N</code> and <code>CTRL</code>+<code>O</code> were supported, and would send <code>VDU 14</code> and <code>VDU 15</code> respectively, enabling and disabling \"paged mode\".  Console8 VDP 2.5.0 added support for several more letters, specifically <code>B</code>, <code>C</code>, <code>F</code>, <code>G</code>, <code>L</code>, <code>N</code> and <code>O</code>.  <code>CTRL</code>+<code>P</code> is also supported but rather than performing a VDU 16 it will toggle the printer on and off, compatible with behaviour on BBC BASIC for Windows.  (Owing to how the VDP and the eZ80 interact, it is unlikely that any more control keys will be added in the future.)</p> <p>When control keys are turned off, the keyboard will not trigger VDU commands on the VDP.</p> <p>Irrespective of whether the VDP has done anything with a control key, or whether they are enabled or not, key information will always be sent through to MOS.</p> <p>Until Console8 VDP 2.6.0, this control key behaviour on the VDP was always enabled, and could not be turned off.</p> <p>From Console8 VDP 2.6.0 onwards, the control keys can be turned off, which may help ensure that unexpected behaviour on the VDP does not occur when using applications running on MOS that may also wish to use these control key combinations.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-99-virtualkey-request-updated-keyboard-data-for-a-key","title":"<code>VDU 23, 0, &amp;99, virtualKey</code>: Request updated keyboard data for a key \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command will send an updated keycode data packet to MOS with the current state of the given key, using a vdp-gl/fab-gl virtual key code.  Usually you should not have to use this command, as the keyboard data packets are sent automatically whenever a key is pressed or released.</p> <p>(This command is used by MOS 3.0 at boot time to determine if the left shift key is pressed to signals that the boot file should not be run from the SD card.)</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9a","title":"<code>VDU 23,0, &amp;9A</code>: Temporarily enable paged mode \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command temporarily enables the VDP's \"paged mode\", as if a <code>VDU 14</code> command had been sent.  Temporary paged mode remains active until one frame after the VDP no longer has any VDU commands to process, at which point the paged mode is restored to its previous setting.</p> <p>This command is useful for applications that need to temporarily enable paged mode, but do not want to change the paged mode setting for the VDP permanently.  For example, MOS 3.0 uses this command to ensure that star commands that can output a lot of text to screen will be automatically paged.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9b-bufferid-print-the-contents-of-a-buffer-to-the-screen","title":"<code>VDU 23, 0, &amp;9B, bufferId;</code>: Print the contents of a buffer to the screen \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>If a buffer is found with the given <code>bufferId</code>, then this command will print a buffer out to the screen, using only the raw character values. This bypasses VDU command processing, so no control characters at all are supported and will be printed as-is.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9c-set-the-text-viewport-using-graphics-coordinates","title":"<code>VDU 23, 0, &amp;9C</code>: Set the text viewport using graphics coordinates \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Sets the text viewport using the rectangle described by the last two coordinates given via PLOT commands.  This command serves a similar purpose to <code>VDU 28</code>, but uses graphics coordinates instead of text coordinates, and does not require the coordinates to be sent as part of the command.  This allows for more flexibility in defining the viewport.</p> <p>Whilst the graphics cursor positions can be anywhere in the coordinate space, the text viewport will be limited to appear within the screen, and will be clipped to the screen.  If the resultant viewport has zero width or height (as the coordinates were off-screen) then the command will have no effect.  This behaviour differs from <code>VDU 28</code> which would reject the command if any of the coordinates given were off-screen.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9d-set-the-graphics-viewport-using-graphics-coordinates","title":"<code>VDU 23, 0, &amp;9D</code>: Set the graphics viewport using graphics coordinates \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Sets the graphics viewport using the rectangle described by the last two coordinates given via PLOT commands.  This command serves a similar purpose to <code>VDU 24</code>, but uses coordinates from the graphics coordinate stack, which allows for more flexibility in defining the viewport.  This can, for instance, be used to define a new viewport in coordinates that are relative to the current graphics origin.</p> <p>As per <code>VDU 23, 0, &amp;9C</code>, the viewport will be clipped to the screen if it is off-screen.  This behaviour differs from <code>VDU 24</code> which would reject the command if any of the coordinates given were off-screen.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9e-set-the-graphics-origin-using-graphics-coordinates","title":"<code>VDU 23, 0, &amp;9E</code>: Set the graphics origin using graphics coordinates \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Sets the graphics origin to the last coordinate given via PLOT commands.  This command serves a similar purpose to <code>VDU 29</code>, but uses coordinates from the graphics coordinate stack, which allows for more flexibility in defining the origin.  This can, for instance, be used to define a new origin in coordinates that are relative to the current origin.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-9f-move-the-graphics-origin-and-viewports","title":"<code>VDU 23, 0, &amp;9F</code>: Move the graphics origin and viewports \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Moves the graphics origin to the current graphics cursor position, and also moves the currently defined text and graphics viewports by the same relative amount that the origin has moved.</p> <p>As with <code>VDU 23, 0, &amp;9C</code> and <code>VDU 23, 0, &amp;9D</code> the resultant text and graphics viewports will be clipped to the screen area.  This means that this command is not reversible, i.e. if you move the origin to position <code>100,100</code> and then move it to <code>-100,-100</code> the viewports will not return to their original sizes, as they will have been shrunk in the process.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-a0-bufferid-command-args-buffered-command-api","title":"<code>VDU 23, 0, &amp;A0, &lt;bufferId&gt;, &lt;command&gt;, [&lt;args&gt;]</code>: Buffered command API **","text":"<p>Send a command to the VDP Buffered Commands API</p>"},{"location":"vdp/System-Commands/#vdu-23-0-a1-update-vdp-for-exclusive-use-of-the-agon-flash-tool","title":"<code>VDU 23, 0, &amp;A1</code>: Update VDP (for exclusive use of the agon-flash tool) **","text":"<p>This command is used by the agon-flash tool to update the VDP firmware.  It should not be used by any other software.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c0-n-turn-logical-screen-scaling-on-and-off","title":"<code>VDU 23, 0, &amp;C0, n</code>: Turn logical screen scaling on and off *","text":"<p>Turns logical screen scaling on and off, where 1=on and 0=off.</p> <p>When logical scaling is turned off, the graphics system will no longer use the 1280x1024 logical coordinate system and instead use pixel coordinates.  The screen origin point at 0,0 will change to be the top left of the screen, and the Y axis will go down the screen instead of up.</p> <p>For more information, see the Screen modes documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c1-n-switch-legacy-modes-on-or-off","title":"<code>VDU 23, 0, &amp;C1, n</code>: Switch legacy modes on or off **","text":"<p>Turns legacy screen modes on and off, where 1=on and 0=off.</p> <p>By default, the original screen modes 0-4 are not available and are instead replaced by new modes that are more compatible with modern monitors.  For compatibility with older software, written for Agon systems running earlier versions of the VDP firmware, this command can be used to switch back to those original, legacy, screen modes.</p> <p>For more information, see the Screen modes documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c3-swap-the-screen-buffer-andor-wait-for-vsync","title":"<code>VDU 23, 0, &amp;C3</code>: Swap the screen buffer and/or wait for VSYNC **","text":"<p>Swap the screen buffer (double-buffered modes only) or wait for VSYNC (all modes).</p> <p>This command will swap the screen buffer, if the current screen mode is double-buffered, doing so at the next VSYNC.  If the current screen mode is not double-buffered then this command will wait for the next VSYNC signal before returning.  This can be used to synchronise the screen with the vertical refresh rate of the monitor.</p> <p>Waiting for VSYNC can be useful for ensuring smooth graphical animation, as it will prevent tearing of the screen.</p> <p>(In BASIC performing a <code>*FX 19</code> command will perform a similar wait for VSYNC, but on the eZ80 side of the system, but will not swap the screen buffer.)</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c4-command-args-copper-functions","title":"<code>VDU 23, 0, &amp;C4, command, [&lt;args&gt;]</code>: \"Copper\" functions \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Send a command to the VDP Copper API.  This allows for the creation of different palettes and for the palettes to be changed on the fly during the scanout of the screen.</p> <p>These functions were introduced in VDP 2.12.0.  At this time, to access these APIs a feature flag must be set using <code>VDU 23, 0, &amp;F8, &amp;310; 0;</code>.  The exact feature set provided may be subject to change in future versions of the VDP firmware.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-c8-command-args-context-management-api","title":"<code>VDU 23, 0, &amp;C8, &lt;command&gt;, [&lt;args&gt;]</code>: Context management API \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>Send a command to the Context Management API.  This allows management of the current graphics context, which includes the current font, text and graphics colours, and the current GCOL paint mode.</p> <p>The context management API allows for the entire current graphics state to be saved and restored, which can be useful for applications that need to temporarily change the graphics state, but then restore it to its original state.  As part of this, the current state can be saved to a stack, and then restored later.  Additionally completely separate context stacks can be selected.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-ca-flush-current-drawing-commands","title":"<code>VDU 23, 0, &amp;CA</code>: Flush current drawing commands \u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>For performance reasons, all drawing commands (for both graphics and text) received by the VDP are actually placed in a queue, and are not immediately drawn to the screen.  This command will force all pending drawing commands to be processed and drawn to the screen.</p> <p>This command is useful for some advanced operations, such as on-the-fly redefining character data in a custom font, ensuring that all characters are drawn before the font is redefined.</p> <p>Most applications will not need to use this command, as the VDP will automatically flush the drawing queue when it receives a command that requires the screen to be updated, such as reading a screen pixel.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-f2-n-set-dot-dash-pattern-length","title":"<code>VDU 23, 0, &amp;F2, n</code>: Set dot-dash pattern length \u00a7\u00a7\u00a7\u00a7","text":"<p>This command sets the length of the dot-dash pattern used for drawing lines with dotted line plot codes.  The default length is 8, and the length can be set to any value between 1 and 64.  Setting a length of 0 will reset to the default length, and reset the pattern to the default pattern.</p> <p>The line pattern can be set using <code>VDU 23, 6, n1, n2, n3, n4, n5, n6, n7, n8</code>, where <code>n1</code> is the first byte of the pattern, <code>n2</code> is the second byte, and so on.  Bits are used most-significant-bit first.</p> <p>Support for this command was added in Console8 VDP 2.7.0.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-f8-variableid-value-set-a-vdp-variable","title":"<code>VDU 23, 0, &amp;F8, variableId; value;</code>: Set a VDP Variable \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command is used to set a VDP variable.  VDP variables are used to control various features of the VDP, including enabling new functionality that may not quite be ready for general use and/or have an API that may change in the future.  They may also allow for changing various aspects of the VDP's behaviour.</p> <p>The <code>variableId</code> is the ID of the variable to set, and the <code>value</code> is the value to set it to.  The meaning of the <code>value</code> that any particular variable is set to will be specific to the flag being set.  A value must always be provided, even if the variable does not require a value to be set.</p> <p>For details on the variables that can be set, see the VDP Variables documentation.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-f9-variableid-clear-a-vdp-variable","title":"<code>VDU 23, 0, &amp;F9, variableId;</code>: Clear a VDP Variable \u00a7\u00a7\u00a7\u00a7\u00a7\u00a7","text":"<p>This command is used to clear a VDP variable, removing them from the variable store, when possible.</p> <p>Most VDP variables that reflect the system state information cannot be cleared, and this command will ignored attempts to clear them.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-fe-n-console-mode","title":"<code>VDU 23, 0, &amp;FE, n</code>: Console mode **","text":"<p>Turns \"console mode\" on and off, where 1=on and 0=off (the default).</p> <p>This mode is primarily intended for use with debugging tooling.  It will reflect VDU command bytes through to a serial terminal attached to the VDPs USB port, and will attempt to pass keyboard input from the serial terminal back through the VDP to MOS.</p> <p>This mode is not intended for general use.  If you are looking for a way to output data to the attached serial terminal then <code>VDU 2</code> is a better option.</p>"},{"location":"vdp/System-Commands/#vdu-23-0-ff-switch-to-or-resume-terminal-mode","title":"<code>VDU 23, 0, &amp;FF</code>: Switch to or resume \"terminal mode\"","text":"<p>This command enables \"terminal mode\", which changes the behaviour of the VDP to be more like a traditional terminal.  This is useful for running CP/M in place of MOS on the eZ80, or other software that expects to be running on a terminal.</p> <p>When terminal mode is enabled, VDU commands will no longer be recognised and processed, keyboard entry in BBC BASIC/MOS is no longer supported, and the VDP protocol is essentially suspended.  Instead the VDP acts as a dumb terminal, and will send all keyboard input to the eZ80's UART0.  The eZ80 can then process this input as it sees fit.</p> <p>By default a VT100 terminal is emulated, but this can be changed by sending the appropriate escape sequences to the VDP.  Terminal support is inherited from FabGL, and so its custom escape sequences can be used to change the terminal behaviour.</p> <p>From Console8 VDP version 2.2.0, the following additional escape sequences are supported:</p> Sequence Description <code>ESC + \"_#Q!$\"</code> Quit/end terminal mode <code>ESC + \"_#S!$\"</code> Suspend terminal mode <p>Quitting terminal mode returns the VDP back to normal operation, and will resume the VDP protocol.  The screen mode will be reset to the mode that was active before terminal mode was enabled.</p> <p>Suspending terminal mode temporarily restores VDU command processing.  (Keyboard handling is unchanged.)  This could be useful to use VDU commands to perform drawing operations.  To resume terminal mode, <code>VDU 23, 0, &amp;FF</code> must be sent again.</p>"},{"location":"vdp/System-Commands/#vdp-serial-protocol","title":"VDP Serial Protocol","text":"<p>Data sent from the VDP to the eZ80's UART0 is sent as a packet in the following format:</p> <ul> <li><code>cmd</code>: The packet command, with bit 7 set</li> <li><code>len</code>: Number of data bytes</li> <li><code>data</code>: The data byte(s)</li> </ul> <p>Words are 16 bit, and sent in little-endian format</p> <p>In general, as a programmer using an Agon you should not need to worry about the format and contents of any of these packets, as they are handled by MOS.  On receipt of one of these packets, MOS will set system state variables (sysvars) accordingly.  It may also set a bit in the VDPProtocol status byte sysvar corresponding to the type of data packet received.</p> <p>If you are performing a command where you need to wait for a response from the VDP, then you will need to wait for the appropriate bit to be set in the VDP protocol byte.  Before you send a command to the VDP you should clear the bit that relates to the command you are about to send.  Once the command has been processed the VDP will set the bit again.  If the bit is not set then there may have been an error processing the command.</p> <p>Packets:</p> <ul> <li><code>0x00, value</code>: General Poll</li> <li><code>0x01, keycode, modifiers, vkey, keydown</code>: Keyboard state</li> <li><code>0x02, x, y</code>: Cursor position</li> <li><code>0x03, char</code>: Character read from screen</li> <li><code>0x04, r, g, b, index</code>: Pixel colour read from screen</li> <li><code>0x05, channel, status</code>: Audio command status (see VDP Enhanced Audio API)</li> <li><code>0x06, width; height; cols, rows, colours</code>: Screen dimensions - width and height are words</li> <li><code>0x07, year, month, day, dayOfYear, dayOfWeek, hour, minute, second</code>: RTC data *</li> <li><code>0x08, delay, rate, led</code>: Keyboard status - delay and rate are words</li> <li><code>0x09, x; y; buttons, wheelDelta, deltaX; deltaY;</code>: Mouse status - x, y, deltaX and deltaY are words</li> </ul> <p>* as of VDP 1.04 the RTC data is sent in a packed format, and is stored in the MOS sysvars in this packed format.  Prior to VDP 1.04 the <code>dayOfYear</code> value could be incorrect, as it cannot be guaranteed to fit into a byte.</p> <p>MOS VDP Protocol flag bits:</p> Bit Description 0 Cursor position 1 Character read from screen 2 Point data (pixel colour) read from screen 3 Audio status 4 Mode info / Screen dimensions 5 RTC data 6 Mouse status"},{"location":"vdp/System-Commands/#keyboard","title":"Keyboard","text":"<p>When a key is pressed, a packet is sent with the following data: - cmd: 0x01 - keycode: The ASCII value of the key pressed - modifiers: A byte with the following bits set (1 = pressed): <pre><code>0. CTRL\n1. SHIFT\n2. ALT LEFT\n3. ALT RIGHT\n4. CAPS LOCK\n5. NUM LOCK\n6. SCROLL LOCK\n7. GUI\n</code></pre> From VDP 1.03, the following key data is also returned - vkey: The FabGL virtual keycode - keydown: 1 if the key is down, 0 if the key is up</p>"},{"location":"vdp/VDP-Variables/","title":"VDP Variables","text":"<p>VDP variables provide a way to both read and change the state of the VDP.  They can be used to enable an experimental feature, read the current state of the VDP, or change the state of the VDP.</p> <p>VDU variables contain 16-bit values.  Some variables may only use the lower 8 bits.</p> <p>Variables are currently split into three general categories: test flags, system settings, and VDU variables.  In the future we will add more variables to expose the state of the audio system.  These categorites are given some broad ranges of variable IDs to allow for future expansion, and to allow for easy identification of the type of variable.</p> <p>Test flags are used to enable a feature that may either be experimental, not yet fully implemented, have an API that might change, or not fully tested.</p> <p>System settings variables provide access to VDP system information, such as memory usage, real-time clock data, and keyboard settings.</p> <p>VDU variables provide access to the graphics system state, including context-specific information that may change when switching context.</p> <p>The VDP variables system was added in Console8 VDP 2.9.0, and was initially used only for test flags.</p> <p>The Console8 VDP 2.12.0 release has added many new variables that expose the state of the VDP, and allow for changes to be made to that state.  It is also now possible to use VDP variables in buffered commands.  This allows for conditional commands to be used to check against a variable, and the contents of a variable to be read into a buffer.</p>"},{"location":"vdp/VDP-Variables/#variable-apis","title":"Variable APIs","text":"<p>There are just two API calls to directly work with VDP variables, one to set a variable, and another to clear it.  As of VDP 2.12.0 the buffered command API also allows for the reading of variables into a buffer, and for conditional commands to be used to perform their checks against a variable.</p> <p>The commands to set and clear variables are documented in the system commands documentation.  Briefly they are:</p> <ul> <li><code>VDU 23, 0, &amp;F8, variableId; value;</code>: Set a VDP Variable</li> <li><code>VDU 23, 0, &amp;F9, variableId;</code>: Clear a VDP Variable</li> </ul> <p>The buffered command API is documented in the buffered commands documentation.  The \"conditional\" commands there are now extended to allow for the use of variables, and an additional command to read the value of a variable and store it into a buffer has been added.</p>"},{"location":"vdp/VDP-Variables/#variable-id-ranges","title":"Variable ID ranges","text":"<p>All variables listed are available from VDP 2.12.0 onwards.  Variables that were introduced in 2.9.0 and 2.11.0 are marked as such.</p> <p>The broad ranges of variable IDs are as follows:</p> Variable ID range Description &amp;1-&amp;FF Test flags &amp;100-&amp;FFF System settings &amp;1000-&amp;1FFF VDU variables (graphics/text system) &amp;2000-&amp;2FFF Reserved for audio system variables &amp;3000-&amp;3FFF Reserved for future use &amp;4000-&amp;FFFF Available for general use <p>The system will not prevent you from using variables in reserved ranges, although inside the \"VDU variables\" range values that the system does not directly support will not be stored, and cannot be read.</p>"},{"location":"vdp/VDP-Variables/#test-flags","title":"Test Flags","text":"<p>As of Console8 VDP 2.9.0 the following test flags are supported:</p> Variable ID Value Description 1 0 (any) Enable the Affine Transforms feature (available from 2.9.0) 2 0 (any) Enable hardware sprites <p>If a flag is set that is not recognised then it will have no effect.  This means that if a feature graduates from being a test feature and no longer requires a flag to be set for use then, so long as the API for the feature remains the same, software that sets the flag to enable the feature will still work.</p> <p>For the current test flags that the VDP supports, any value can be set to enable the feature.  Future flags may require specific values to be set to control how the feature works.</p>"},{"location":"vdp/VDP-Variables/#system-variables","title":"System Variables","text":"<p>Broadly speaking, system variables are used to read and change the state and configuration of the VDP that are not directly related to the current graphics context state or screen mode.  Within the system variables block there are sub-blocks for different types of system information.</p> <p>The sub-ranges within system variables are broadly as follows:</p> Block Description &amp;100-&amp;1FF Communications system settings &amp;200-&amp;208 Real-time clock data &amp;209-&amp;20F Reserved for future use &amp;210-&amp;21F VDP memory information &amp;220-&amp;22F Keyboard settings &amp;230-&amp;23F Context management &amp;240-&amp;2FF Reserved for future use &amp;300-&amp;3FF Graphical system enhancement settings/flags &amp;400-&amp;4FF Bitmap/Sprite system control settings &amp;500-&amp;FFF Reserved for future use <p>Many system variables can be set and adjusted by other VDU commands</p> <p>As of Console8 VDP 2.12.0 the following system variables are supported:</p> Variable ID Value Read-only Clearable Description &amp;0101 0/1 X Full duplex UART hardware flow control flag. This is intended for internal use by MOS. NB setting this flag will break communications with MOS unless a suitable version of MOS that supports full duplex flow control.  The first version of MOS to support this is MOS 3.0 alpha 3 &amp;0102 n/a X Reserved for future use (Buffer size on MOS for VDP protocol packets) &amp;0110 0/1 X Reserved for future use (Echo back received data, for redirect/spool, with a suitable version of MOS that supports this feature) &amp;0200 0-999 Real-time clock year &amp;0201 1-12 Real-time clock month &amp;0202 1-31 Real-time clock day &amp;0203 0-23 Real-time clock hour &amp;0204 0-59 Real-time clock minute &amp;0205 0-59 Real-time clock second &amp;0206 0-999 X Real-time clock millisecond &amp;0207 0-6 X Real-time clock weekday &amp;0208 0-366 X Real-time clock day of year &amp;0210 X Free PSRAM low bytes &amp;0211 X Free PSRAM high bytes &amp;0212 X Number of buffers used &amp;0220 0-17 Keyboard layout (setting to an invalid number will set to zero) &amp;0221 0/1 Control keys on/off (setting to any non-zero value sets to 1) &amp;0230 0-255 Current active context ID &amp;0300 0 (any) X Tile engine flag (enables layers commands, available from VDP 2.11.0) &amp;0310 0 (any) X Enables copper features flag &amp;0400 0 (any) X Prefer hardware sprites flag. When set, all sprites will be set to be hardware sprites after calling the \"Reset sprites\" API, if the \"Enable hardware sprites\" test flag has also been set"},{"location":"vdp/VDP-Variables/#vdu-variables","title":"VDU Variables","text":"<p>VDU variables are numbered in the range &amp;1000-&amp;1FFF and are used to expose information on the current graphics system state.  This includes both information about the current screen mode, and the current context state.</p> <p>The set of variables are loosely based on the VDU variables available in Acorn's RISC OS operating system, and where appropriate they are numbered the same.  The Agon VDP includes many extensions to include additional information that is specific to the Agon platform.</p> <p>All variables within this range are reserved for use by the VDU system.  Any values that are not recognised will not be stored, and cannot be read.</p> <p>Flag variables use values 0 to indicate disabled, and 1 to indicate enabled.  Setting a flag to any non-zero value is counted as if setting to 1.</p> <p>Some variables provide coordinates.  For those variables that are marked as \"screen coordinates\", the origin is at the top-left of the screen, and the location is measured in pixels.  For those variables that are marked as \"character coordinates\", the origin is at the top-left of the screen, and the location is measured in characters.  Variables shown as \"OS coordinates\" will reflect the currently selected coordinate system, as defined in variable &amp;1057.  When the default coordinate system is selected, the origin is at the bottom-left of the screen, and the location is measured in OS units, where the screen is defined as 0-1279 for X and 0-1023 for Y.</p> Variable ID Value Read-only Clearable Description 0x1001 X Text columns - (characters) 0x1002 X Text rows - (characters) 0x1003 1/3/15/63 X Max logical colour number for current screen mode 0x100B X Screen width in pixels - 1 0x100C X Screen height in pixels - 1 0x100D 1/2 X Number of screen banks (1 for single-buffered modes, 2 for double-buffered) 0x1017 0-255 Current line thickness (pixels) 0x1018 Text cursor, absolute X position (chars) 0x1019 Text cursor, absolute Y position (chars) 0x1020 Frame counter low word (the frame counter is a 32-bit value) 0x1021 Frame counter high word 0x1022 Number of frames to pause on newline when the \"Ctrl\" key is held * 0x1023 Current number of frames being waited for * 0x1055 X Current screen mode number 0x1056 0/1 Legacy modes flag 0x1057 0/1 Coordinate system (0 = screen/pixel coordinates, 1 = logical/OS (default)) 0x1058 0/1/2/3 Paged mode flag (0 = disabled, 1 = enabled, 2 = disabled, but temporary paged mode is on , 3 = enabled, and temporary paged mode is on ) 0x1059 Paged mode context row count * 0x1066 0-255 Cursor behaviour flags byte, as set via VDU 23,16,x,y 0x1067 0/1 Text cursor visibility 0x1068 Text cursor block horizontal start column 0x1069 Text cursor block horizontal end column 0x106A 0-31 Text cursor block vertical start row 0x106B Text cursor block vertical end row 0x106C 0-3 Text cursor appearance, write only (0 = steady, 1 = off, 2 = fast blink, 3 = slow blink) 0x1070 X Active cursor type (0 = Text cursor, 1 = Graphics cursor) 0x1080 Graphics window, LH column, screen coordinates 0x1081 Graphics window, Bottom row, screen coordinates 0x1082 Graphics window, RH column, screen coordinates 0x1083 Graphics window, Top row, screen coordinates 0x1084 Text window, LH column, character coordinates 0x1085 Text window, Bottom row, character coordinates 0x1086 Text window, RH column, character coordinates 0x1087 Text window, Top row, character coordinates 0x1088 Graphics origin, X, OS coordinates 0x1089 Graphics origin, Y, OS coordinates 0x108A Graphics cursor, X, OS coordinates 0x108B Graphics cursor, Y, OS coordinates 0x108C Oldest Graphics cursor, X, screen coordinates 0x108D Oldest Graphics cursor, Y, screen coordinates 0x108E Previous Graphics cursor, X, screen coordinates 0x108F Previous Graphics cursor, Y, screen coordinates 0x1090 Graphics cursor, X, screen coordinates 0x1091 Graphics cursor, Y, screen coordinates 0x1097 0-7 GCOL action for foreground colour 0x1098 0-7 GCOL action for background colour 0x1099 0-63 Graphics foreground (logical) colour 0x109A 0-63 Graphics background (logical) colour 0x109B 0-63 Text foreground (logical) colour 0x109C 0-63 Text background (logical) colour 0x10A1 X Max mode number (not double-buffered) 0x10A2 X X font size, graphics cursor 0x10A3 X Y font size, graphics cursor 0x10A4 X X font spacing, graphics cursor 0x10A5 X Y font spacing, graphics cursor 0x10A7 X X font size, text cursor 0x10A8 X Y font size, text cursor 0x10A9 X X font spacing, text cursor 0x10AA X Y font spacing, text cursor 0x10F2 Dotted line pattern length 0x10F3 Line pattern, bytes 0-1 0x10F4 Line pattern, bytes 2-3 0x10F5 Line pattern, bytes 4-5 0x10F6 Line pattern, bytes 6-7 0x1100 Width of text window in chars 0x1101 Height of text window in chars 0x1118 X position of text cursor within text window 0x1119 Y position of text cursor within text window 0x111A X position of text cursor in screen coordinates 0x111B Y position of text cursor in screen coordinates 0x1200-0x123F 0-63 Palette entries.  Maps logical colours to physical screen colours. The entries used will depend on the number of colours in the current screen mode 0x1300-0x13FF Character to bitmap mapping.  Value is a 16-bit bitmap ID, or 65535 if character is not mapped.  See <code>VDU 23, 0, &amp;92, char, bitmapId;</code> 0x1400 Currently selected bitmap ID (16-bit bitmap ID) 0x1401 X Count of bitmaps used 0x1402 Current bitmap transform ID. Must be set to a buffer ID containing a valid affine transform.  The affine transforms flag must be set to change this value 0x1410 0-255 Current sprite ID 0x1411 X Number of sprites active (not necessarily visible) 0x1420 Mouse cursor ID 0x1441 0/1 Mouse cursor enabled. Mouse data can only be read if the mouse is enabled 0x1442 Mouse cursor X position in screen coordinates 0x1443 Mouse cursor Y position in screen coordinates 0x1444 0-7 X Mouse cursor button status.  Bit 0 indicates left button pressed, bit 1 the right button, and bit 2 the middle button 0x1445 X Mouse wheel delta 0x1446 Mouse sample rate 0x1447 Mouse resolution 0x1448 Mouse scaling 0x1449 Mouse acceleration 0x144A Mouse wheel acceleration <p>* Support for these variables was added in VDP 2.14.0</p>"},{"location":"vdp/VDU-Commands/","title":"An Overview of VDU Commands","text":"<p>The Agon VDP system aims to be as compatible as practical with the Acorn BBC Micro's VDU command system.  It also supports some extensions as added by later Acorn computer systems, and the various versions of BBC BASIC by R.T.Russell.  Where necessary, some extensions have been added to help facilitate the Agon's unique features and architecture.</p> <p>This documentation provides a more in-depth explanation to each top-level VDU control code, and provides links to further documentation for more detailed individual commands.</p> <p>Please note that not all versions of the VDP support the complete command set.  The first version of the VDP to support the complete top-level list of VDU commands is the Agon Console8 VDP 2.5.0.  The following list uses the following symbols to indicate which VDP versions support which commands:</p> <p>* Requires VDP 1.03 or above  ** Requires VDP 1.04 or above  \u00a7 Requires Console8 VDP 2.3.0 or above  \u00a7\u00a7 Requires Console8 VDP 2.5.0 or above  \u00a7\u00a7\u00a7 Requires Console8 VDP 2.7.0 or above  \u00a7\u00a7\u00a7\u00a7 Requires Console8 VDP 2.8.0 or above</p> <p>In general, bytes/characters in the range of 0-31 are treated as control or command codes by the VDP.  Depending on the command, the VDP will then interpret bytes that follow as parameters to the command, continuing until sufficient bytes have been read to satisfy the command.  If there are insufficient bytes to satisfy the command, then the VDP will wait until more bytes are available, and timeout after 200ms.  If too many bytes are sent for a command, then the VDP will interpret those new bytes as another command.</p> <p>Any VDU command that is the VDP does not recognise (such as <code>VDU 2</code> when running on Quark 1.04) will be ignored.  Please note that when VDP comes across a command it does not understand it will proceed to interpret the next byte it receives as the next command.  This means that code written for a later version of the VDP may not work correctly on earlier versions and produce unexpected results.  Care should be taken to ensure that code is compatible with the VDP version it is running on, and it is generally advised to try to detect features before using them.</p> <p>All other characters, i.e. those in the range of 32 to 126 and 128 to 255, are sent to the screen as ASCII, unaltered.</p>"},{"location":"vdp/VDU-Commands/#vdu-0-null-no-operation","title":"<code>VDU 0</code>: Null (no operation)","text":"<p>On encountering a <code>VDU 0</code> command, the VDP will do nothing.  This may be useful for padding out a VDU command sequence, or for inserting a placeholder for a command that will be added later.</p>"},{"location":"vdp/VDU-Commands/#vdu-1-send-next-character-to-printer-if-printer-is-enabled","title":"<code>VDU 1</code>: Send next character to \"printer\" (if \"printer\" is enabled) \u00a7\u00a7","text":"<p>Ensures that the next character received by the VDP is sent through to the \"printer\", and not to the screen.  This is useful for sending control codes to the \"printer\", or for sending data to the \"printer\" that is not intended to be displayed on the screen.  It allows characters that would not otherwise normally be sent through to the \"printer\" to be sent.</p> <p>If the \"printer\" has not been enabled then this command will just discard the next byte sent to the VDP.</p>"},{"location":"vdp/VDU-Commands/#vdu-2-enable-printer","title":"<code>VDU 2</code>: Enable \"printer\" \u00a7\u00a7","text":"<p>Enables the \"printer\".</p> <p>In the context of the Agon platform, the \"printer\" is a serial terminal that is connected to the VDP's USB port.  Typically this port is used for power, but it can also be used to send and receive data to and from the VDP.</p> <p>When the \"printer\" is enabled, the VDP will send characters it receives to the \"printer\" as well as to the screen.  It will additionally send through control codes 8-13.  To send other control codes to the \"printer\", use the <code>VDU 1</code> command.</p> <p>The VDP will not send through other control codes to the printer, and will will not send through data it receives as part of other commands.</p>"},{"location":"vdp/VDU-Commands/#vdu-3-disable-printer","title":"<code>VDU 3</code>: Disable \"printer\" \u00a7\u00a7","text":"<p>Disables the \"printer\".</p>"},{"location":"vdp/VDU-Commands/#vdu-4-write-text-at-text-cursor","title":"<code>VDU 4</code>: Write text at text cursor","text":"<p>This causes text to be written at th current text cursor position.  This is the default mode for text display.</p> <p>Text is written using the current text foreground and background colours.</p>"},{"location":"vdp/VDU-Commands/#vdu-5-write-text-at-graphics-cursor","title":"<code>VDU 5</code>: Write text at graphics cursor","text":"<p>This causes text to be written at the current graphics cursor position.</p> <p>Using this, characters may be positioned at any graphics coordinate within the graphics viewport.  This is useful for positioning text over graphics, or for positioning text at a specific location on the screen.</p> <p>Characters are plotted using the current graphics foreground colour, using the current graphics foreground plotting mode (see <code>VDU 18</code>).</p> <p>The character background is transparent, and will not overwrite any graphics that are already present at the character's location.  The exception to this is <code>VDU 27</code>, the \"delete\" character, which backspaces and deletes as per its usual behaviour, but will erase using the current graphics background colour.</p>"},{"location":"vdp/VDU-Commands/#vdu-6-enable-screen-opposite-of-vdu-21","title":"<code>VDU 6</code>: Enable screen (opposite of <code>VDU 21</code>) \u00a7\u00a7","text":"<p>This enables the screen, and re-enables VDU command processing, reversing the effect of <code>VDU 21</code>.</p>"},{"location":"vdp/VDU-Commands/#vdu-7-make-a-short-beep-bel","title":"<code>VDU 7</code>: Make a short beep (BEL)","text":"<p>Plays a short beep sound on audio channel 0.  If the audio channel is already in use, or has been disabled, then this command will have no effect.</p>"},{"location":"vdp/VDU-Commands/#vdu-8-move-cursor-back-one-character","title":"<code>VDU 8</code>: Move cursor back one character","text":"<p>Moves the text cursor one character in the negative \"X\" direction.  By default, when at the start of a line it will move to the end of the previous line (as defined by the current text viewport).  If the cursor is also at the top of the screen then the viewport will scroll down.  The cursor remains constrained to the current text viewport.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll.  The cursor is just moved left by one character width.</p> <p>Further behaviour of the cursor can be controlled using the <code>VDU 23,16</code> command.</p> <p>It should be noted that as of Console8 VDP 2.5.0, the cursor system does not support adjusting the direction of the cursor's X axis, so this command will move the cursor to the left.  This is likely to change in the future.</p>"},{"location":"vdp/VDU-Commands/#vdu-9-move-cursor-forward-one-character","title":"<code>VDU 9</code>: Move cursor forward one character","text":"<p>Moves the text cursor one character in the positive \"X\" direction.  By default, when at the end of a line it will move to the start of the next line (as defined by the current text viewport).  If the cursor is also at the bottom of the screen then the viewport will scroll up.</p> <p>Essentially this is the opposite of <code>VDU 8</code>.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll.</p>"},{"location":"vdp/VDU-Commands/#vdu-10-move-cursor-down-one-line","title":"<code>VDU 10</code>: Move cursor down one line","text":"<p>Moves the text cursor one line in the positive \"Y\" direction.  By default, when at the bottom of the screen the viewport will scroll upwards.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll, and the cursor is just moved down by one character height.</p>"},{"location":"vdp/VDU-Commands/#vdu-11-move-cursor-up-one-line","title":"<code>VDU 11</code>: Move cursor up one line","text":"<p>Moves the text cursor one line in the negative \"Y\" direction.  By default, when at the top of the screen the viewport will scroll downwards.</p> <p>Essentially this is the opposite of <code>VDU 10</code>.</p> <p>When in <code>VDU 5</code> mode and the graphics cursor is active, the viewport will not scroll.</p>"},{"location":"vdp/VDU-Commands/#vdu-12-clear-text-area-cls","title":"<code>VDU 12</code>: Clear text area (<code>CLS</code>)","text":"<p>Clears the current text viewport to the current text background colour, and moves the text cursor to the \"home\" position of the viewport (usually the top left).</p> <p>This is identical to the BASIC <code>CLS</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-13-carriage-return","title":"<code>VDU 13</code>: Carriage return","text":"<p>Moves the text cursor to the start (or column 0) of the current line.</p>"},{"location":"vdp/VDU-Commands/#vdu-14-paged-mode-on","title":"<code>VDU 14</code>: Paged mode On *","text":"<p>When paged mode is on, scrolling will stop after each page.  Output will be paused until \"Shift\" has been pressed on the keyboard.</p> <p>From VDP 2.14.0 onwards paged mode has been improved.  A page is no longer always a complete screen of output, but instead will keep up to 6 rows of context.  The VDP now also behaves better when paged mode is active, and will only pause continous output, not just when a certain number of rows has been printed.  Holding down the \"Ctrl\" key whilst text is being output will cause the VDP to pause briefly before every new line, allowing the user to skim through the text as it is printed (NB this works whether paged mode is enabled or not).  Holding both \"Ctrl\" and \"Shift\" will pause the output until either key is released.  You can customise how long the delay between lines will be when \"Ctrl\" is held, and how many lines of context will be shown through setting their corresponding VDP variables.</p>"},{"location":"vdp/VDU-Commands/#vdu-15-paged-mode-off","title":"<code>VDU 15</code>: Paged mode Off *","text":"<p>Disables paged mode.  This is the default mode.</p>"},{"location":"vdp/VDU-Commands/#vdu-16-clear-graphics-area-clg","title":"<code>VDU 16</code>: Clear graphics area (<code>CLG</code>)","text":"<p>Clears the current graphics viewport to the current graphics background colour.</p> <p>The current graphics cursor is unaffected.</p> <p>This is identical to the BASIC <code>CLG</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-17-colour-set-text-colour-colour","title":"<code>VDU 17, colour</code>: Set text colour (<code>COLOUR</code>)","text":"<p>This will set the current text colour to the given colour, as defined by the colour palette.</p> <p>Colour numbers in the range 0-127 are interpreted as foreground colours, and numbers in the range 128-255 are interpreted as background colours.</p> <p>The actual range of colours supported will depend on the screen mode you are using.  Agon systems can only actually display a maximum of 64 colours (numbered 0 to 63).  The VDP will loop around the colour palette if a colour number is given that is outside the range of colours supported by the screen mode.  This means that for instance colour 65 is always equivalent to colour 1, or when in a 16 colour screen mode selecting colour 32 would be equivalent to choosing colour 0.</p> <p>This command is identical to the BASIC <code>COLOUR</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-18-mode-colour-set-graphics-colour-gcol-mode-colour","title":"<code>VDU 18, mode, colour</code>: Set graphics colour (<code>GCOL mode, colour</code>)","text":"<p>This command will set both the current graphics colour, and the current graphics painting mode.</p> <p>As with <code>VDU 17</code> the colour number will set the foreground colour if it is in the range 0-127, or the background colour if it is in the range 128-255, and will be interpreted in the same manner.</p> <p>Up to and including Console8 VDP 2.5.0 support for the <code>mode</code> parameter was highly limited.  The only fully supported mode was mode 0, which is the default mode.  This mode sets on-screen pixels with the target colour.  From VDP 1.04 onwards there was very limited support for mode 4, which would invert on-screen pixels, but was only supported for straight line plotting operations.</p> <p>As of Console8 VDP 2.6.0, all 8 of the basic modes are supported for all currently supported plot operations.  Separate plot modes are tracked for foreground and background colours.</p> <p>The full array of available modes is as follows:</p> Mode Effect 0 Set on-screen pixel to target colour value 1 OR value with the on-screen pixel 2 AND value with the on-screen pixel 3 EOR value with the on-screen pixel 4 Invert the on-screen pixel 5 No operation 6 AND the inverse of the specified colour with the on-screen pixel 7 OR the inverse of the specified colour with the on-screen pixel <p>For more information on the various plot commands, please see the VDP PLOT command documentation</p> <p>(Acorn's graphics system supported some further GCOL mode options, which could specify the use of a fill pattern, which is not currently supported by the Agon VDP.  Support for these modes may be added in a future version of the VDP firmware.)</p> <p>This command is identical to the BASIC <code>GCOL</code> keyword.</p>"},{"location":"vdp/VDU-Commands/#vdu-19-l-p-r-g-b-define-logical-colour","title":"<code>VDU 19, l, p, r, g, b</code>: Define logical colour","text":"<p>This command sets the colour palette, by mapping a logical colour (i.e. the colour as selected via <code>VDU 17, colour</code> or <code>VDU 18, mode, colour</code>) to a physical colour.  This is useful for defining custom colours, or for redefining the default colours.</p> <p>If the physical colour number is given as 255 then the colour will be defined using the red, green, and blue values given.</p> <p>If the physical colour value is less than 64, the value is interpreted as a 6-bit colour number where the number in binary form is in the format <code>RRGGBB</code>.</p> <p>Any other physical colour value (i.e. 64 to 254) is not valid and the command will be ignored.</p> <p>If the physical colour is not 255 then the red, green, and blue values must still be provided, but will be ignored.</p> <p>The values for red, green and blue must be given in the range 0-255.  You should note that the physical Agon hardware only supports 64 colours, so the actual colour displayed may not be exactly the same as the colour requested.  The nearest colour will be chosen.</p> <p>Up to and including Console8 VDP 2.5.0 this command would have no effect when in a 64 colour screen mode, and the palette in those modes was fixed.</p> <p>From Console8 VDP 2.6.0 onwards, the command will now work in all screen modes, and will allow for the definition of custom colours.  Please note that when in a 64 colour screen mode there is no \"palette\" for the screen display per-se, so the command will not have any effect to the existing screen display.  It will only affect the colours used for subsequent graphics or text operations.</p> <p>It should be noted that from Console8 VDP 2.10.1 onwards, if you are in a screen mode with a palette (i.e. with less than 64 colours) if you redefine a palette entry to use a colour that is identical to an existing palette entry then any pixels drawn into the framebuffer of that colour will always be for the lowest numbered palette entry.  This is a limitation of the underlying graphics system the VDP uses which, whilst it maintains a palette for video signal output, only accepts commands to draw using \"real\" colours.  This could lead to some unexpected results in some limited circumstances, such as if your program is attempting to produce animations via palette cycling.  This can be worked around by ensuring that your palette contains unique entries when you are drawing to the screen, and then change the palette after drawing has been completed.  In reality most users are unlikely to encounter this issue, as they will work with a palette that does not contain duplicate entries, but it is worth being aware of.</p> <p>(This is a result of improvements in how the palette is handled.  Prior to VDP 2.10.0 the palette was not being properly changed when an entry was adjusted, which could result in the VDP using incorrect colours when drawing bitmaps.  This issue was fixed in VDP 2.10.0.  That this results in the above described behaviour is considered to be the least worst option.  This may be addressed in a future version of the VDP firmware.)</p> <p>This command is equivalent to the two ways the BASIC <code>COLOUR</code> keyword can be used to redefine the colour palette: <code>COLOUR l, p</code> or <code>COLOUR l, r, g, b</code>.</p>"},{"location":"vdp/VDU-Commands/#vdu-20-reset-palette-and-textgraphics-colours-and-drawing-modes","title":"<code>VDU 20</code>: Reset palette and text/graphics colours and drawing modes \u00a7\u00a7","text":"<p>This command will reset the colour palette to the default palette, and will reset the text and graphics colours and drawing modes to their default values.</p>"},{"location":"vdp/VDU-Commands/#vdu-21-disable-screen","title":"<code>VDU 21</code>: Disable screen \u00a7\u00a7","text":"<p>This command will \"disable the screen\", stopping any further VDU commands from being processed.  This is useful for temporarily disabling the screen, for instance when using the \"printer\" to send data to a serial terminal.  The actual screen display will not be turned off, but the VDP will stop processing VDU commands so changes to the display will not be made until the screen is re-enabled.</p> <p>The exception to this is commands <code>VDU 1</code> and <code>VDU 6</code>, which will still be processed.  If the \"printer\" has been enabled, bytes sent to the VDP still be sent through to the \"printer\", with the restrictions as described against <code>VDU 2</code>.</p> <p>Please note that the behaviour of the Agon system differs from Acorn systems when <code>VDU 21</code> has been called.  On an Agon system, when the screen has been disabled the VDP will consider each and every byte received as a new command, looking out specifically for a <code>VDU 6</code> command byte to re-enable the command interpreter.  It will not attempt to interpret any bytes received as a parameter to the previous command.  An Acorn system, on the other hand, would accept parameters for VDU commands, and just not process the command.  This means that code written for an Acorn system may not work correctly on an Agon system if it uses <code>VDU 21</code>.</p>"},{"location":"vdp/VDU-Commands/#vdu-22-n-select-screen-mode-mode-n","title":"<code>VDU 22, n</code>: Select screen mode (<code>MODE n</code>)","text":"<p>Changes the screen mode to the given mode number.</p> <p>Please see the Screen Modes documentation for more information on the screen modes supported by the Agon VDP.</p> <p>This command is identical to the BASIC <code>MODE</code> keyword.</p> <p>Changing the screen mode will reset the graphics system, returning most settings to their defaults.  The current cursor behaviour (as defined using <code>VDU 23, 16, x, y</code>) will be retained.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-n-re-program-display-character-system-commands","title":"<code>VDU 23, n</code>: Re-program display character / System Commands","text":"<p>This command serves two purposes.</p> <p>Firstly when <code>n</code> is in the range of 32-255 it will re-program the character in the system font at the given character code.  This is useful for redefining the character set, or for adding custom characters to the system character set.  The format of the command in this mode is: <pre><code>VDU 23, char_no, r1, r2, r3, r4, r5, r6, r7, r8\n</code></pre> Where <code>char_no</code> is the character number to re-program, and <code>r1</code> to <code>r8</code> are the 8 bytes of data that define the character in rows from top to bottom.  Each byte defines one row of the character, with the least significant bit of each byte defining the left-most pixel of the row, and the most significant bit defining the right-most pixel of the row.</p> <p>Please note that as of Console8 VDP 2.8.0 this form of the command will only work if the system font is the currently selected font.  For more information please see the Font API documentation.</p> <p>Additionally, rather than re-programming the display character, there is also a function available to remap the character to a bitmap, allowing these font character replacements to be multi-coloured.</p> <p>Note: There is a related VDU 23 System Command which can program the entire character range 0-255, and a reset command is also available to reset the system font back to default.</p> <p>The second purpose of this command is to send system commands to the VDP.</p> <p>The following commands are supported:</p>"},{"location":"vdp/VDU-Commands/#vdu-23-0-command-arguments-system-commands","title":"<code>VDU 23, 0, &lt;command&gt;, [&lt;arguments&gt;]</code>: System commands","text":"<p>Commands starting with <code>VDU 23, 0</code> are system commands.  These commands are used to configure the VDP and to control its behaviour.  This includes functionality such as the audio system, the buffered commands API, font API, and context management API.  For more information see the System Commands documentation.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-1-n-cursor-control","title":"<code>VDU 23, 1, n</code>: Cursor control","text":"<p>This command controls the appearance of the text cursor.</p> Value Meaning 0 Hide the cursor 1 Show the cursor 2 Make the cursor steady \u00a7\u00a7\u00a7\u00a7 3 Make the cursor flash \u00a7\u00a7\u00a7\u00a7 <p>Please note that in VDU 5 mode the cursor will not be visible, and the cursor control commands will have no effect.</p> <p>Previous versions of this documentation indicated that values 2 and 3 were supported as of Console8 VDP version 2.7.0.  Unfortunately this was incorrect as a bug prevented these values from working correctly.  (This functionality could however be used via <code>VDU 23, 0, &amp;0A</code> on that version of the VDP.)  As of Console8 VDP 2.8.0 these values are now supported.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-6-n1-n2-n3-n4-n5-n6-n7-n8-set-dotted-line-pattern","title":"<code>VDU 23, 6, n1, n2, n3, n4, n5, n6, n7, n8</code>: Set dotted line pattern \u00a7\u00a7\u00a7","text":"<p>This command sets the dotted line pattern for the various dotted line (<code>VDU 25</code>) PLOT commands.  The pattern is defined by 8 bytes, where each bit in each byte defines a pixel in the pattern.  Bits are used from the pattern most significant bit first, from bytes <code>n1</code>-<code>n8</code>, so the top-most bits (most significant bits) of the first byte (<code>n1</code>) define the start of the pattern.</p> <p>The repeat length of the pattern is set using <code>VDU 23, 0, 242, n</code>, where <code>n</code> is the number of pixels to repeat the pattern for.  The default repeat length is 8, meaning that only the <code>n1</code> byte will be used for the pattern.  Setting the repeat length to zero will reset to the default pattern, with the default repeat length.</p> <p>The current dotted line pattern will be reset on changing screen mode.</p> <p>Support for this command was added in Agon Console8 VDP 2.7.0.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-7-extent-direction-movement-scroll","title":"<code>VDU 23, 7, extent, direction, movement</code>: Scroll","text":"<p>This command scrolls in a given direction.</p> <p>The <code>extent</code> parameter controls what part of the screen will be scrolled.  A value of <code>0</code> means the current text viewport, a <code>1</code> means the whole screen, a <code>2</code> means the current graphics viewport, and <code>3</code> is interpreted as the current \"active\" viewport (as chosen using <code>VDU 4</code> or <code>VDU 5</code>).</p> <p>The `direction`` parameter can be one of the following values:</p> Value Meaning 0 Scroll right 1 Scroll left 2 Scroll down 3 Scroll up 4 Scroll in positive X direction * 5 Scroll in negative X direction * 6 Scroll in positive Y direction * 7 Scroll in negative Y direction * <p>* Support for these values was added in Agon Console8 VDP 2.5.0 for cursor behaviour values set by <code>VDU 23, 16, x, y</code>, but only for bits 1 and 2.  As of Console8 VDP 2.7.0, bit 3 of the cursor behaviour is also supported allowing the x and y directions to be swapped, thus letting X be vertical and Y be horizontal.</p> <p>The <code>movement</code> parameter controls the movement amount.  A value of <code>0</code> means that the screen will be scrolled by one character width/height in the given direction.  Any other value is interpreted as the number of pixels to scroll in the given direction.</p> <p>Support for a <code>movement</code> value of zero was added in Agon Console8 VDP 2.5.0.  Before this version a <code>movement</code> value of zero would be interpreted as no movement.</p> <p>The Agon implementation of this command differs from Acorn systems in the interpretation of the <code>movement</code> and <code>extent</code> parameter.  On Acorn systems, the only valid <code>extent</code> values are 0 or 1.  Acorn's <code>movement</code> parameter can also only be 0 or 1, but vertical movement would always be one character height, and horizontal movement one character width for a movement value of 0, and one byte for a movement value of 1, which made the results of this command vary depending on the current screen mode.  The Agon implementation of this command allows for more flexibility, and allows for scrolling by a given number of pixels in any direction, at the cost of some compatibility.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-16-setting-mask-define-cursor-movement-behaviour","title":"<code>VDU 23, 16, setting, mask</code>: Define cursor movement behaviour","text":"<p>This command controls the behaviour of the text cursor.  It is used to adjust the cursor behaviour via a bitmask.  The new setting is calculated as: <pre><code>new_setting = (current_setting AND mask) EOR setting\n</code></pre></p> <p>This method of setting the cursor behaviour allows you to set individual bits, or to clear individual bits, without needing to know the current setting.</p> <p>The interpretation of the settings byte flags is as follows:</p> Bit Value Meaning 7 0 Normal value 7 1 Undefined 6 0 Graphics cursor (VDU 5 mode) does an implicit cr/lf when it moves off right of graphics viewport 6 1 Graphics cursor carries on off edge of graphics viewport 5 0 Cursor moves right after a character is printed 5 1 Cursor does not move right after a character is printed \u00a7 4 0 Text cursor (VDU 4 mode) will scroll when it moves off the bottom of the screen 4 1 Text cursor will wrap to top of screen when it moves off the bottom of the screen \u00a7 3, 2, 1 Defines the cursor direction, as follows * 3, 2, 1 0 0 0 X direction is right, Y direction is down * 3, 2, 1 0 0 1 X direction is left, Y direction is down * 3, 2, 1 0 1 0 X direction is right, Y direction is up * 3, 2, 1 0 1 1 X direction is left, Y direction is up * 3, 2, 1 1 0 0 X direction is down, Y direction is right * 3, 2, 1 1 0 1 X direction is down, Y direction is left * 3, 2, 1 1 1 0 X direction is up, Y direction is right * 3, 2, 1 1 1 1 X direction is up, Y direction is left * 0 0 Disable scroll protection 0 1 Enable scroll protection \u00a7 <p>The default value for each setting is zero, i.e. all bits are cleared.</p> <p>* Full support for these settings was added in Agon Console8 VDP 2.7.0.  Partial support for bits 1 and 2 was added in Console8 VDP 2.5.0 but only for direction-based scrolling (<code>VDU 23, 7</code>).</p> <p>\u00a7 Whilst the Quark documentation claims that bits 4 and 5 is supported in the Quark 1.04 release, they were not actually supported in the VDP firmware.  The cursor would always move right after a character was printed, and the text cursor could never wrap to the top of the screen.  The cursor direction bits were also not supported.  Support for scroll protection was also limited to an incorrect (buggy) implementation, which would simply prevent vertical scrolling.  Full support for all of these features was added in Agon Console8 VDP 2.7.0.</p> <p>Scroll protection, when enabled, means that when in <code>VDU 4</code> mode printing a character that results in the cursor moving off the right-hand edge of the screen will cause a \"pending newline\" to be generated, rather than immediately performing a newline.  When this occurs, the cursor position will be one position greater than the right-most accessible column.  This newline will be executed just before the next character is printed if the cursor has not otherwise been moved back within the screen.  This means that sending a backspace character (<code>VDU 127</code>) or cursor left command (<code>VDU 8</code>) would cancel the pending newline, whilst a cursor right command will execute it.</p> <p>Enabling scroll protection therefore allows you to print a character to the bottom right-most character position on the screen without causing the screen to scroll.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-23-n-set-line-thickness","title":"<code>VDU 23, 23, n</code>: Set line thickness \u00a7\u00a7\u00a7","text":"<p>This command sets the line thickness for the various line drawing commands.  The line thickness is set to <code>n</code> pixels.  The default line thickness is 1 pixel.</p> <p>This command was added to Agon Console8 VDP 2.6.0.  Prior to that version, the line thickness was always 1 pixel.  PLOT commands that draw filled shapes are not affected by the line thickness.  Line plot commands that omit the first or last point may produce unexpected results when the line thickness is greater than 1.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-27-command-arguments-bitmap-and-sprite-commands","title":"<code>VDU 23, 27, &lt;command&gt;, [&lt;arguments&gt;]</code>: Bitmap and sprite commands","text":"<p>See the Bitmap and Sprite Commands documentation for more information.</p>"},{"location":"vdp/VDU-Commands/#vdu-23-28-hexload","title":"<code>VDU 23, 28</code>: Hexload","text":"<p>This command switches the VDP to a dedicated Intel Hex receiver/decoder. After sending this command, the VDP temporarily blocks all other functions and expects Intel Hex-formatted data on it's USB/serial port. The baudrate and serial configuration settings are displayed on-screen, and the VDP loops through all incoming records until the final End-of-File record is received. Starting console8-vdp 2.8.2+, the user can press the 'escape' key to abort an incoming transfer and return the VDP to it's regular function.</p> <p>Detailed documentation for the Intel Hex format can be found here</p> <p>The purpose of hexload is to enable a user to send binaries directly to ez80 memory, using a text-formatted binary (Intel Hex) from an external PC to the external USB/serial port of an Agon system. The solution has a few components that need to work together in order to make this happen:</p> <p></p> <p>A specific client that sends the VDU sequence to the VDP, to start the 'remote' Intel Hex receiver/decoder, is the component that is responsible for receiving preformatted data-records from the VDP. Data is sent to the client using VDP virtual keystroke packets, where packets contains an ASCII keycode for each received byte. The format of this data and the sequence of events of the protocol to the client is detailed below. The current hexload utility streams the incoming data directly to memory and optionally to the filesystem. The memory destination address(es) are dependent on which address records are present in the Intel Hex file sent to the VDP. If no address records are present (for example when a binary is converted to Intel Hex format before sending) the VDP defaults to the Agon 0x40000 load address.</p> <p>The MOS has no specific role, other than to accept virtual keyboard packets and send out bytes to the VDP.</p> <p>In order to reliably transfer the incoming Intel Hex stream at full serial speeds, the VDP runs a dedicated Intel Hex receiver and decodes all Intel Hex records to data packets that are sent to the MOS as virtual keystrokes. This allows the VDP to perform the bulk of Intel Hex processing, while the lower-powered ez80 can focus on data reception.</p> <p>The RTS/CTS flow control lines on the USB/serial interface are hardwired for ESP32 boot selection, per Espressif standards. Any flow control on the USB/serial interface is therefore not possible on this serial interface, which leads to potential periodic loss of incoming packets. While the Intel Hex format specifies a checksum at the end of each record, this will only detect single-bit errors and not multi-bit issues that easily arise when the USB/serial is overrun. In order to deal with this, the VDP starting 2.8.2+ allows for an extended, Agon-proprietary Intel Hex format where CRC16 verification takes place at each record between PC and VDP, and the VDP sends back it's calculated CRC16. The PC sender can detect if the VDP has received incorrect data, whereupon it retransmits a record if necessary. At the start of an extended format session, the PC sends a custom Intel Hex record that contains the full CRC32 checksum of all data to be sent to the VDP. The VDP then verifies and displays the results upon End-of-File record reception.</p> <p>The RTS/CTS flow control lines between VDP and ez80 are only in use one-way to the VDP, not from the VDP to the ez80. This creates a similar challenge in absence of flow control. The data format sent to the hexload utility periodically waits for acknowledgement and asks for a mirror of each record's checksum to be sent back to the VDP. Starting 2.8.2+, using extended format, the VDP will retransmit corrupted data to the ez80, because it has a way to temporarily pause the incoming traffic from the PC.</p>"},{"location":"vdp/VDU-Commands/#internal-data-records","title":"Internal data records","text":"<p>At each Intel Hex DATA record, the VDP sends these bytes as virtual keystrokes to MOS: 1. Start/stop byte - 0x01 indicates a data packet follows, 0x00 indicates end of transfer / return to normal VDP function 2. Three bytes of the 24-bit address of the following packet, in big-endian format (U / H / L) 3. A single byte containing the number of data bytes to be sent in this packet 4. 0-n data bytes as indicated previously</p> <p>The hexload utility should then transmit a single byte to the VDP, containing a 2s complement to the sum of all received bytes. This byte is added to the running checksum by the VDP, to detect and indicate communication errors to the Hexload utility. Address information from Intel Hex ADDRESS records, are parsed by the VDP and sent to the hexload utility as part of data packets with an address header.</p>"},{"location":"vdp/VDU-Commands/#extended-intel-hex-format","title":"Extended Intel Hex format","text":"<p>A Agon-proprietary extended format has been devised, to allow CRC16 checks at each Intel hex record's line, retransmission upon failed verification and full CRC32 verification at end of transmission. The VDP switches to reception of the extended format, upon receipt of a specific IntelHex-formatted start record:</p> <pre><code>:06 0000 FF XXXXXXXX CC\n</code></pre> <ol> <li>: start of record</li> <li>6 bytes of payload data, indicated by a single byte (2 ASCII nibbles '06')</li> <li>0x0000 start address (4 ASCII nibbles '0000' ignored / unused)</li> <li>Non-standard record type 0xFF (2 ASCII nibbles 'FF')</li> <li>The CRC32 of the entire payload to be sent, in Intel Hex format (6 ASCII nibbles)</li> <li>A regular Intel Hex checksum of a single byte (2 ASCII nibbles) This command is used by the hexload utility, and should not be used by user applications.</li> </ol> <p>After switching to the extended format, the VDP expects all subsequent Intel Hex records to have a CRC16 appended to it, containing the CRC16 of the original Intel Hex record, including the ':' character. In this way, all content can be verified. The CRC16 is sent using Intel Hex format, using 4 ASCII nibbles. The VDP then sends back it's own calculated CRC16 in binary form (2 bytes), so it allows the PC sender application to retransmit records if necessary.</p> <p>After the PC sender sends the last (End-of-file) Intel Hex record, the VDP sends back it's calculated CRC32 in binary form (4 bytes), and issues a result statement before it exits the receiver/decoder role.</p>"},{"location":"vdp/VDU-Commands/#vdu-24-left-bottom-right-top-set-graphics-viewport","title":"<code>VDU 24, left; bottom; right; top;</code>: Set graphics viewport **","text":"<p>This command sets the graphics viewport.  The graphics viewport defines the area of the screen that graphics will be drawn to.  It is also the area that will be cleared by the <code>VDU 16</code> command.</p> <p>It should be noted that the coordinates given for this command must lie within the screen area.  If the coordinates are outside of the screen area then the command will be ignored.  When using OS Coordinates (the default coordinate system) this means that the coordinates must be in the range 0-1279 for the x-axis positions, and 0-1023 for the y-axis positions.</p> <p>Coordinates given are \"inclusive\", meaning that drawing locations up to and including those given will be drawn to.  To set a graphics viewport that is a single pixel tall, therefore, the <code>bottom</code> and <code>top</code> coordinates should be the same.</p> <p>(Please note that owing to a bug in the VDP firmware, viewports of a single pixel wide or tall were not supported until Console8 VDP 2.7.0.  Prior to that version a command to set a single pixel high viewport would be ignored.)</p>"},{"location":"vdp/VDU-Commands/#vdu-25-mode-x-y-plot-command","title":"<code>VDU 25, mode, x; y;</code>: PLOT command","text":"<p>This command is used for graphics plotting, and is equivalent to the BASIC <code>PLOT</code> command.</p> <p>The aim for this command is to support all of Acorn's original <code>PLOT</code> modes, however currently only a limited number of plotting modes are supported.  Support for plot modes has expanded over time, and will continue to expand in the future.</p> <p>For more information see the PLOT Commands documentation.</p>"},{"location":"vdp/VDU-Commands/#vdu-26-reset-graphics-and-text-viewports","title":"<code>VDU 26</code>: Reset graphics and text viewports **","text":"<p>This command resets the graphics and text viewports to their default values, homes the text cursor, and resets the graphics origin.  The default graphics viewport is the whole screen, and the default text viewport is the whole screen.</p> <p>NB prior to Console8 VDP 2.8.0, this command had a bug and did not reset the graphics origin.</p>"},{"location":"vdp/VDU-Commands/#vdu-27-char-output-character-to-screen","title":"<code>VDU 27, char</code>: Output character to screen \u00a7","text":"<p>Sends the next character to the screen.  This allows for characters outside of the normal ASCII range of 32-126 and 128-255 to be drawn on the screen.</p>"},{"location":"vdp/VDU-Commands/#vdu-28-left-bottom-right-top-set-text-viewport","title":"<code>VDU 28, left, bottom, right, top</code>: Set text viewport **","text":"<p>This defines a text viewport.  The text viewport defines the area of the screen that text will be drawn to.  It is also the area that will be cleared by the <code>VDU 12</code> command.</p> <p>The coordinates given are character positions, based on the currently selected font, not pixel positions.</p>"},{"location":"vdp/VDU-Commands/#vdu-29-x-y-set-graphics-origin","title":"<code>VDU 29, x; y;</code>: Set graphics origin","text":"<p>This command sets the graphics origin.  This sets where on the screen graphics coordinates are relative to for drawing commands.</p>"},{"location":"vdp/VDU-Commands/#vdu-30-home-cursor","title":"<code>VDU 30</code>: Home cursor","text":"<p>When in <code>VDU 4</code> mode, this moves the text cursor to the home (top left) position of the current text viewport.  When in `VDU 5`` mode, this moves the graphics cursor to the home position of the current graphics viewport.</p>"},{"location":"vdp/VDU-Commands/#vdu-31-x-y-move-text-cursor-to-x-y-text-position","title":"<code>VDU 31, x, y</code>: Move text cursor to x, y text position","text":"<p>Moves the text cursor to the given text position.  The coordinates given are character positions based on the currently selected font, not pixel positions.</p> <p>This is equivalent to the BASIC <code>TAB(x, y)</code> statement.</p> <p>Please note that if you have changed the text viewport, the coordinates given will be relative to the text viewport, not the whole screen.</p> <p>The position of the text cursor is not constrained to the text viewport, so it is possible to move the cursor outside of the viewport.  A tab command attempting to move the cursor outside of the text viewport will be ignored.</p>"},{"location":"vdp/VDU-Commands/#vdu-127-backspace","title":"<code>VDU 127</code>: Backspace","text":"<p>Moves the text cursor back one character, and deletes the character at that position.</p>"}]}